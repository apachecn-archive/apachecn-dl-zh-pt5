<html><head/><body>


	
		<title>B16341_02_ePub</title>
		
	
	
		<div><div/>
		</div>
		<div><h1 id="_idParaDest-44"><a id="_idTextAnchor044"/> 2。加载和处理数据</h1>
		</div>
		<div><p class="callout-heading">概观</p>
			<p class="callout">在本章中，您将学习如何在TensorFlow中加载和处理用于建模的各种数据类型。您将实现将数据输入TensorFlow模型的方法，以便优化模型定型。</p>
			<p class="callout">到本章结束时，你将知道如何输入表格数据、图像、文本和音频数据，并对它们进行预处理，以便它们适用于训练张量流模型。</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>简介</h1>
			<p>在前一章中，您学习了如何使用TensorFlow创建、利用和应用线性变换到张量。本章从张量的定义以及如何使用TensorFlow库中的<code>Variable</code>类创建它们开始。然后，您创建了各种等级的张量，并学习了如何使用该库应用张量加法、整形、转置和乘法。这些都是线性变换的例子。您通过介绍优化方法和激活函数以及如何在TensorFlow库中访问它们来总结了这一章。</p>
			<p>在TensorFlow中训练机器学习模型时，必须为模型提供训练数据。可用的原始数据可能有多种格式，例如，表格CSV文件、图像、音频或文本文件。不同的数据源以不同的方式加载和预处理，以便为张量流模型提供数值张量。例如，虚拟助理使用语音查询作为输入交互，然后应用机器学习模型来破译输入语音并执行特定动作作为输出。为了创建该任务的模型，必须将语音输入的音频数据加载到内存中。还需要包括将音频输入转换成文本的预处理步骤。接下来，文本被转换成用于模型训练的数值张量。这个例子展示了从非表格、非数字数据(如音频数据)中创建模型的复杂性。</p>
			<p>本章将探讨一些用于构建机器学习模型的常见数据类型。您将以高效的方式将原始数据加载到内存中，然后执行一些预处理步骤，将原始数据转换为适合训练机器学习模型的数值张量。幸运的是，机器学习库已经取得了显著的进步，这意味着具有图像、文本和音频等数据类型的训练模型对于从业者来说是非常容易获得的。</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>探索数据类型</h1>
			<p>根据来源的不同，原始数据可以有不同的形式。常见的数据形式包括表格数据、图像、视频、音频和文本。例如，温度记录器(用于记录一段时间内给定位置的温度)的输出是表格。表格数据由行和列构成，在温度记录器的例子中，每一列可以表示每条记录的特征，例如时间、位置和温度，而每一行可以表示每条记录的值。下表显示了数字表格数据的示例:</p>
			<div><div><img src="img/B16341_02_01.jpg" alt="Figure 2.1: An example of 10 rows of tabular data that consists of numerical values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图2.1:由数值组成的10行表格数据的例子</p>
			<p>图像数据代表原始数据的另一种常见形式，这种形式在构建机器学习模型时很流行。这些模型很受欢迎，因为有大量的可用数据。随着智能手机和安全摄像头记录下生活中的所有瞬间，他们产生了大量可用于训练模型的数据。</p>
			<p>用于训练的图像数据的维度不同于用于表格数据的维度。每个图像都有一个高度和宽度维度，还有一个颜色通道增加了第三个维度，图像数量增加了第四个维度。这样，图像数据模型的输入张量是四维张量，而表格数据的输入张量是二维的。下图显示了取自<code>Open Images</code>数据集(<a href="https://storage.googleapis.com/openimages/web/index.html">https://storage.googleapis.com/openimages/web/index.html</a>)的船只和飞机的标记训练示例示例；这些图像已经过预处理，因此它们都具有相同的高度和宽度。例如，该数据可用于训练二进制分类模型，以将图像分类为船只或飞机:</p>
			<div><div><img src="img/B16341_02_02.jpg" alt="Figure 2.2: A sample of image data that can be used for training machine learning models"/>
				</div>
			</div>
			<p class="figure-caption">图2.2:可用于训练机器学习模型的图像数据样本</p>
			<p>可用于构建机器学习模型的其他类型的原始数据包括文本和音频。像图像一样，它们在机器学习社区中的受欢迎程度源于大量可用的数据。音频和文本都面临着大小不确定的挑战。在本章的后面，您将探索如何克服这一挑战。下图显示了一个采样速率为44.1 kHz的音频样本，这意味着音频数据每秒采样44，100次。这是输入到虚拟助理的原始数据类型的一个示例，虚拟助理从中解读请求并采取相应的行动:</p>
			<div><div><img src="img/B16341_02_03.jpg" alt="Figure 2.3: A visual representation of audio data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图2.3:音频数据的可视化表示</p>
			<p>现在，您已经了解了在构建机器学习模型时可能会遇到的一些数据类型，在下一节中，您将发现预处理不同类型数据的方法。</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor047"/>数据预处理</h1>
			<p>数据预处理是指将原始数据转换为适合机器学习模型用作输入的形式的过程。每种不同的数据类型都需要不同的预处理步骤，最低要求是得到的张量只由数字元素组成，如整数或小数。需要数值张量，因为模型依赖于线性变换，如加法和乘法，这些只能在数值张量上执行。</p>
			<p>虽然许多数据集只有数值字段，但也有许多数据集没有。它们可能包含字符串、布尔、分类或日期数据类型的字段，这些数据类型都必须转换为数字字段。有些可能微不足道；布尔字段可以被映射，使得<code>true</code>值等于<code>1</code>并且<code>false</code>值等于<code>0</code>。因此，将布尔型字段映射到数值型字段是很简单的，所有必要的信息都会保留下来。但是，在转换其他数据类型(如日期字段)时，您可能会在转换为数值字段时丢失信息，除非另有明确说明。</p>
			<p>使用Unix时间将日期字段转换为数字字段时，可能会发生信息丢失的一个例子。Unix time表示自Unix纪元以来经过的秒数；即1970年1月1日00:00:00 UTC，闰秒被忽略。使用Unix时间删除了月份、星期几、一天中的小时等的显式指示，这些在训练模型时可能是重要的特征。</p>
			<p>将字段转换为数值数据类型时，尽可能多地保留信息上下文非常重要，因为这将有助于任何经过训练的模型理解要素和目标之间的关系。下图演示了如何将日期字段转换为一系列数值字段:</p>
			<div><div><img src="img/B16341_02_04.jpg" alt="Figure 2.4: A numerical encoding of a date column&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图2.4:日期列的数字编码</p>
			<p>如上图所示，在左侧，日期字段表示给定的日期，而在右侧，有一个提供数字信息的方法:</p>
			<ul>
				<li>年份是从日期中提取的，日期是一个整数。</li>
				<li>月份是一次性编码的。一年中的每个月都有一列，如果日期的月份与列的名称对应，则月份是二进制编码的。</li>
				<li>创建一个列，指示日期是否发生在周末。</li>
			</ul>
			<p>这只是对这里的<code>date</code>列进行编码的一种方法；并非所有上述方法都是必要的，还有许多方法可以使用。将所有字段适当地编码成数字字段对于创建能够学习特征和目标之间的关系的高性能机器学习模型是重要的。</p>
			<p>数据规范化是另一种用于加速训练过程的预处理技术。归一化过程会重新调整字段的比例，使它们都具有相同的比例。这也将有助于确保模型的重量具有相同的比例。</p>
			<p>在上图中，<code>year</code>列的数量级为<code>10</code> 3，其他列的数量级为<code>10</code> 0。这意味着两列之间有三个数量级。数值比例相差很大的字段将导致模型不太精确，因为可能无法找到最小化误差函数的最佳权重。这可能是由于在训练之前被定义为超参数的容限或学习率在权重被更新时对于两种尺度都不是最优的。在前面的示例中，重新调整<code>year</code>列的大小，使其与其他列具有相同的数量级可能是有益的。</p>
			<p>在本章中，您将探索各种可用于预处理表格数据、图像数据、文本数据和音频数据的方法，以便将其用于训练机器学习模型。</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>处理表格数据</h1>
			<p>在本节中，您将学习如何将表格数据加载到Python开发环境中，以便将其用于TensorFlow建模。您将使用pandas和scikit——学习利用对处理数据有用的类和函数。您还将探索可用于预处理这些数据的方法。</p>
			<p>通过使用熊猫<code>read_csv</code>函数并将路径传递给数据集，可以将表格数据加载到内存中。该函数非常适用于加载表格数据，并且易于使用，可以按如下方式使用:</p>
			<pre>df = pd.read_csv('path/to/dataset')</pre>
			<p>为了标准化数据，您可以使用scikit-learn中提供的缩放器。有多个可应用的定标器；<code>StandardScaler</code>将对数据进行标准化，以便数据集的字段具有平均值<code>0</code>和标准偏差<code>1</code>。另一个常用的缩放器是<code>MinMaxScaler</code>，它将重新缩放数据集，使字段具有最小值<code>0</code>和最大值<code>1</code>。</p>
			<p>要使用缩放器，必须将其初始化并适合数据集。通过这样做，数据集可以由缩放器进行变换。事实上，拟合和转换过程可以通过使用<code>fit_transform</code>方法在一个步骤中完成，如下所示:</p>
			<pre>scaler = StandardScaler()
transformed_df = scaler.fit_transform(df)</pre>
			<p>在第一个练习中，您将学习如何使用pandas和scikit——学习加载数据集并对其进行预处理，以便它适合建模。</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>练习2.01:加载表格数据和重新调整数值字段</h2>
			<p>数据集<code>Bias_correction_ucl.csv</code>包含韩国首尔第二天最高和最低气温预报的偏差校正信息。这些字段表示给定日期的温度测量值、测量指标的气象站、与天气相关的指标(如湿度)的模型预测以及第二天的温度预测。您需要对数据进行预处理，使所有列的平均值为<code>0</code>，标准差为<code>1</code>，呈正态分布。您将使用<code>Present_Tmax</code>列来演示效果，该列代表给定气象站给定日期的最高温度。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">数据集可以在这里找到:<a href="https://packt.link/l83pR">https://packt.link/l83pR</a>。</p>
			<p>执行以下步骤来完成本练习:</p>
			<ol>
				<li>打开一个新的Jupyter笔记本来实现这个练习。将文件另存为<code>Exercise2-01.ipnyb</code>。</li>
				<li>In a new Jupyter Notebook cell, import the pandas library, as follows:<pre>import pandas as pd</pre><p class="callout-heading">注意</p><p class="callout">你可以在下面的链接找到关于熊猫的文档:<a href="https://pandas.pydata.org/docs/">https://pandas.pydata.org/docs/</a>。</p></li>
				<li>Create a new pandas DataFrame named <code>df</code> and read the <code>Bias_correction_ucl.csv</code> file into it. Examine whether your data is properly loaded by printing the resultant DataFrame:<pre>df = pd.read_csv(<strong class="bold">'Bias_correction_ucl.csv'</strong>)
df</pre><p class="callout-heading">注意</p><p class="callout">确保根据CSV文件在系统上的位置更改其路径(突出显示)。如果您从存储CSV文件的同一个目录运行Jupyter笔记本，那么您可以不做任何修改就运行前面的代码。</p><p>输出如下所示:</p><div><img src="img/B16341_02_05.jpg" alt="Figure 2.5: The output from printing the DataFrame&#13;&#10;"/></div><p class="figure-caption">图2.5:打印数据帧的输出</p></li>
				<li>使用DataFrame的<code>drop</code>方法删除<code>date</code>列，并传入该列的名称。<code>date</code>列将被删除，因为它是一个非数值字段，当非数值字段存在时，将无法重新调整。因为您要删除一列，所以应该传递<code>axis=1</code>参数和<code>inplace=True</code>参数:<pre>df.drop('Date', inplace=True, axis=1)</pre></li>
				<li>Plot a histogram of the <code>Present_Tmax</code> column that represents the maximum temperature across dates and weather stations within the dataset:<pre>ax = df['Present_Tmax'].hist(color='gray')
ax.set_xlabel("Temperature")
ax.set_ylabel("Frequency")</pre><p>输出如下所示:</p><div><img src="img/B16341_02_06.jpg" alt="Figure 2.6: A Temperature versus Frequency histogram of the Present_Tmax column&#13;&#10;"/></div><p class="figure-caption">图2.6:Present _ Tmax列的温度与频率直方图</p><p>生成的直方图显示了<code>Present_Tmax</code>列的值的分布。你可以看到温度值从20摄氏度到38摄氏度不等。绘制特征值的直方图是查看值的分布以了解是否需要将缩放作为预处理步骤的好方法。</p></li>
				<li>Import the <code>StandardScaler</code> class from scikit-learn's preprocessing package. Initialize the scaler, fit the scaler, and transform the DataFrame using the scaler's <code>fit_transform</code> method. Create a new DataFrame, <code>df2</code>, using the transformed DataFrame since the result of the <code>fit_transform</code> method is a NumPy array. The standard scaler will transform the numerical fields so that the mean of the field is <code>0</code> and the standard deviation is <code>1</code>:<pre>from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
df2 = scaler.fit_transform(df)
df2 = pd.DataFrame(df2, columns=df.columns)</pre><p class="callout-heading">注意</p><p class="callout">得到的变换数据的平均值和标准偏差值可以输入到定标器中。</p></li>
				<li>Plot a histogram of the transformed <code>Present_Tmax</code> column:<pre>ax = df2['Present_Tmax'].hist(color='gray')
ax.set_xlabel("Normalized Temperature")
ax.set_ylabel("Frequency")</pre><p>输出如下所示:</p><div><img src="img/B16341_02_07.jpg" alt="Figure 2.7: A histogram of the rescaled Present_Tmax column&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.7:重新调整后的Present_Tmax列的直方图</p>
			<p>产生的直方图显示温度值的范围从大约<code>-3</code>到<code>3</code>摄氏度，如直方图的<em class="italic"> x </em>轴上的范围所示。通过使用标准定标器，这些值将始终具有平均值<code>0</code>和标准偏差<code>1</code>。使特征标准化可以加速模型训练过程。</p>
			<p>在本练习中，您成功地使用pandas库导入了表格数据，并使用scikit-learn库执行了一些预处理。数据的预处理包括删除<code>date</code>列并缩放数值字段，使其具有平均值<code>0</code>和标准偏差<code>1</code>。</p>
			<p>在下面的活动中，您将使用pandas库加载表格数据，并使用scikit-learn中的<code>MinMax</code> scaler缩放该数据。您将在先前练习中使用的相同数据集上执行此操作，该练习描述了韩国首尔气温预报的偏差校正。</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>活动2.01:加载表格数据并使用最小最大缩放器重新缩放数值字段</h2>
			<p>在本练习中，您需要加载表格数据，并使用<code>MinMax</code>缩放器缩放数据。数据集<code>Bias_correction_ucl.csv</code>包含韩国首尔第二天最高和最低气温预报的偏差校正信息。这些字段表示给定日期的温度测量值、测量指标的气象站、与天气相关的指标(如湿度)的模型预测以及第二天的温度预测。您需要缩放列，使每列的最小值为<code>0</code>，最大值为<code>1</code>。</p>
			<p>执行以下步骤来完成本练习:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来执行此活动。</li>
				<li>导入熊猫和<code>Bias_correction_ucl.csv</code>数据集。</li>
				<li>使用pandas <code>read_csv</code>函数读取数据集。</li>
				<li>删除数据框中的<code>date</code>列。</li>
				<li>绘制<code>Present_Tmax</code>列的直方图。</li>
				<li>导入<code>MinMaxScaler</code>并使其适合并转换特征数据框。</li>
				<li>Plot a histogram of the transformed <code>Present_Tmax</code> column.<p>您应该会得到类似如下的输出:</p><div><img src="img/B16341_02_08.jpg" alt="Figure 2.8: Expected output of Activity 2.01&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.8:活动2.01的预期产出</p>
			<p class="callout-heading">注意</p>
			<p class="callout">此活动的解决方案可通过<a href="B16341_Solution_ePub.xhtml#_idTextAnchor255">此链接</a>找到。</p>
			<p>转换非数值字段(如分类或日期字段)的一种方法是对它们进行一次性编码。<code>0</code>除了对应正确列的那个。新创建的虚拟列的列标题对应于唯一值。通过使用pandas库的<code>get_dummies</code>函数并传入要编码的列，可以实现一键编码。一个可选参数是提供一个前缀特性，该特性为列标题添加一个前缀。这对于引用列很有用:</p>
			<pre>dummies = pd.get_dummies(df['feature1'], prefix='feature1')</pre>
			<p class="callout-heading">注意</p>
			<p class="callout">使用<code>get_dummies</code>功能时，<code>NaN</code>值被转换为全零。</p>
			<p>在下面的练习中，您将学习如何预处理非数值字段。您将使用在之前的练习和活动中使用的相同数据集，该数据集描述了韩国首尔气温预测的偏差校正。</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>练习2.02:预处理非数字数据</h2>
			<p>在本练习中，您将通过使用<code>get_dummies</code>函数对来自<code>date</code>列的年份和月份进行一次性编码来预处理<code>date</code>列。您将把一次性编码的列与原始数据帧连接起来，并确保结果数据帧中的所有字段都是数值型的。</p>
			<p>执行以下步骤来完成本练习:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来实现这个练习。将文件另存为<code>Exercise2-02.ipnyb</code>。</li>
				<li>在一个新的Jupyter笔记本单元格中，导入熊猫库，如下:<pre>import pandas as pd</pre></li>
				<li>Create a new pandas DataFrame named <code>df</code> and read the <code>Bias_correction_ucl.csv</code> file into it. Examine whether your data is properly loaded by printing the resultant DataFrame:<pre>df = pd.read_csv(<strong class="bold">'Bias_correction_ucl.csv'</strong>)</pre><p class="callout-heading">注意</p><p class="callout">确保根据CSV文件在系统上的位置更改其路径(突出显示)。如果您从存储CSV文件的同一个目录运行Jupyter笔记本，那么您可以不做任何修改就运行前面的代码。</p></li>
				<li>使用pandas <code>to_datetime</code>函数:<pre>df['Date'] = pd.to_datetime(df['Date'])</pre>将<code>date</code>列的数据类型更改为<code>Date</code></li>
				<li>Create dummy columns for <code>year</code> using the pandas <code>get_dummies</code> function. Pass in the year of the <code>date</code> column as the first argument and add a prefix to the columns of the resultant DataFrame. Print out the resultant DataFrame:<pre>year_dummies = pd.get_dummies(df['Date'].dt.year, \
                              prefix='year')
year_dummies</pre><p>输出如下所示:</p><div><img src="img/B16341_02_09.jpg" alt="Figure 2.9: Output of the get_dummies function applied to the year of the date column&#13;&#10;"/></div><p class="figure-caption">图2.9:应用于日期年列的get_dummies函数的输出</p><p>得到的数据帧只包含0和1。<code>1</code>对应于原始<code>date</code>列中的值。对于新创建的数据帧中的所有列，空值将为0。</p></li>
				<li>Repeat this for the month by creating dummy columns from the month of the <code>date</code> column. Print out the resulting DataFrame:<pre>month_dummies = pd.get_dummies(df['Date'].dt.month, \
                               prefix='month')
month_dummies</pre><p>输出如下所示:</p><div><img src="img/B16341_02_10.jpg" alt="Figure 2.10: The output of the get_dummies function applied &#13;&#10;to the month of the date column&#13;&#10;"/></div><p class="figure-caption">图2.10:get _ dummies函数的输出应用于日期列的月份</p><p>结果数据帧现在在<code>date</code>列中只包含该月的0和1。</p></li>
				<li>连接原始数据帧和您在<em class="italic">步骤5 </em>和<em class="italic">步骤6 </em> : <pre>df = pd.concat([df, month_dummies, year_dummies], \                axis=1)</pre>中创建的虚拟数据帧</li>
				<li>删除原来的<code>date</code>列，因为它现在是多余的:<pre>df.drop('Date', axis=1, inplace=True)</pre></li>
				<li>Verify that all the columns are now of the numerical data type:<pre>df.dtypes</pre><p>输出如下所示:</p><div><img src="img/B16341_02_11.jpg" alt="Figure 2.11: Output of the dtypes attribute of the resultant DataFrame &#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.11:结果数据帧的dtypes属性的输出</p>
			<p>在这里，您可以看到结果数据帧的所有数据类型都是数字。这意味着它们现在可以被传递到人工神经网络中进行建模。</p>
			<p>在本练习中，您成功地导入了表格数据，并使用pandas和scikit-learn库预处理了<code>date</code>列。您利用了<code>get_dummies</code>函数将分类数据转换成数字数据类型。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">从日期数据类型获得数字数据类型的另一种方法是使用<code>pandas.Series.dt</code>访问器对象。关于可用选项的更多信息可以在这里找到:<a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.html">https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.html</a>。</p>
			<p>处理非数字数据是创建性能模型的重要步骤。如果可能，应该将任何领域知识传授给训练数据特征。例如，当使用日期预测温度时，就像本章前面的练习和活动中使用的数据集一样，对月份进行编码会很有帮助，因为温度很可能与一年中的月份高度相关。然而，对星期几进行编码可能没有用，因为星期几和温度之间可能没有相关性。使用该领域知识可以帮助模型学习特征和目标之间的潜在关系。</p>
			<p>在下一节中，您将学习如何处理图像数据，以便将其输入到机器学习模型中。</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>处理图像数据</h1>
			<p>各种组织每天都在生成大量图像，这些图像可用于为诸如对象检测、图像分类和对象分割等任务创建预测模型。当处理图像数据和一些其他原始数据类型时，通常需要对数据进行预处理。用最少的预处理从原始数据创建模型是使用人工神经网络建模的最大好处之一，因为特征工程步骤是最少的。特征工程通常涉及使用领域知识从原始数据中创建特征，这非常耗时，并且不能保证模型性能的提高。利用没有特征工程的人工神经网络简化了训练过程，并且不需要领域知识。</p>
			<p>例如，在医学图像中定位肿瘤需要来自那些经过多年训练的专家的专业知识，但是对于ann来说，所需要的只是用于训练的足够的标记数据。通常需要对这些图像进行少量的预处理。这些步骤是可选的，但是有助于标准化培训过程和创建性能模型。</p>
			<p>一个预处理步骤是重新缩放。由于图像的颜色值是介于<code>0</code>和<code>255</code>之间的整数，因此它们被缩放到介于<code>0</code>和<code>1</code>之间的值，类似于<em class="italic">活动2.01 </em>、<em class="italic">加载表格数据并用最小最大缩放器</em>重新缩放数值字段。您将在本节稍后探索的另一个常见预处理步骤是图像增强，它本质上是增强图像以添加更多训练示例并构建更健壮的模型的行为。</p>
			<p>本节还将介绍批处理。批处理一次加载一批训练数据。与一次加载数据相比，这会导致训练时间变慢；但是，这确实允许您在非常大的数据集上训练模型。对图像或音频的训练就是这样的例子，通常需要大音量来实现高性能的结果。</p>
			<p>例如，典型的图像大小可能是100 KB。对于包含100万幅图像的训练数据集，您将需要100 GB的内存，这对于大多数人来说可能是无法实现的。如果以32幅图像为一批来训练该模型，则存储器需求要少几个数量级。批量训练允许您增加训练数据，您将在后面的部分中探索这一点。</p>
			<p>可以使用名为<code>ImageDataGenerator</code>的类将图像加载到内存中，该类可以从Keras的预处理包中导入。这是一个最初来自Keras的类，现在可以在TensorFlow中使用。载入图像时，您可以重新缩放图像。通常的做法是用1/255像素的值来重新缩放图像。这意味着值从0到255的图像现在将具有从0到1的值。</p>
			<p><code>ImageDataGenerator</code>可通过重新缩放进行初始化，如下所示:</p>
			<pre>datagenerator = ImageDataGenerator(rescale = 1./255)</pre>
			<p>一旦初始化了<code>ImageDataGenerator</code>类，就可以使用<code>flow_from_directory</code>方法并传入图像所在的目录。该目录应该包括标有类标签的子目录，并且它们应该包含相应类的图像。要传入的另一个参数是图像的期望大小、批处理大小和类模式。类别模式决定了生成的标签数组的类型。使用<code>flow_from_directory</code>方法进行二进制分类，批量大小为25，图像大小为64x64，如下所示:</p>
			<pre>dataset = datagenerator.flow_from_directory\
          ('path/to/data',\
           target_size = (64, 64),\
           batch_size = 25,\
           class_mode = 'binary')</pre>
			<p>在下面的练习中，您将利用<code>ImageDataGenerator</code>类将图像加载到内存中。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">所提供的图像数据来自开放图像数据集，其完整描述可在此处找到:<a href="https://storage.googleapis.com/openimages/web/index.html">https://storage.googleapis.com/openimages/web/index.html</a>。</p>
			<p>可以通过使用Matplotlib绘制图像来查看图像。这是验证图像与其各自标签匹配的有用练习。</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>练习2.03:加载图像数据进行批处理</h2>
			<p>在本练习中，您将学习如何加载图像数据进行批处理。<code>image_data</code>文件夹包含一组船只和飞机的图片。您将加载船只和飞机的图像进行批处理，并重新缩放它们，使图像值的范围在<code>0</code>和<code>1</code>之间。然后，您的任务是从数据生成器中打印一批带标签的图像。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">你可以在这里找到<code>image_data</code>:https://packt.link/jZ2oc<a href="https://packt.link/jZ2oc"/>。</p>
			<p>执行以下步骤来完成本练习:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来实现这个练习。将文件另存为<code>Exercise2-03.ipnyb</code>。</li>
				<li>在一个新的Jupyter笔记本单元格中，从<code>tensorflow.keras.preprocessing.image</code> : <pre>from tensorflow.keras.preprocessing.image \      import ImageDataGenerator</pre>导入<code>ImageDataGenerator</code>类</li>
				<li>实例化<code>ImageDataGenerator</code>类并传递带有值<code>1./255</code>的<code>rescale</code>参数来转换图像值，使它们在<code>0</code>和<code>1</code>之间:<pre>train_datagen = ImageDataGenerator(rescale =  1./255)</pre></li>
				<li>使用数据生成器的<code>flow_from_directory</code>方法将数据生成器指向图像数据。传入目标大小、批量大小和分类模式的参数:<pre>training_set = train_datagen.flow_from_directory\                ('image_data',\                 target_size = (64, 64),\                 batch_size = 25,\                 class_mode = 'binary')</pre></li>
				<li>创建一个函数来显示批处理中的图像。该函数将绘制5x5阵列中的前25幅图像及其相关标签:<pre>import matplotlib.pyplot as plt def show_batch(image_batch, label_batch):\     lookup = {v: k for k, v in \               training_set.class_indices.items()}     label_batch = [lookup[label] for label in \                    label_batch]     plt.figure(figsize=(10,10))     for n in range(25):         ax = plt.subplot(5,5,n+1)         plt.imshow(image_batch[n])         plt.title(label_batch[n].title())         plt.axis('off')</pre></li>
				<li>Take a batch from the data generator and pass it to the function to display the images and their labels:<pre>image_batch, label_batch = next(training_set)
show_batch(image_batch, label_batch)</pre><p>输出如下所示:</p><div><img src="img/B16341_02_12.jpg" alt="Figure 2.12: The images from a batch&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.12:一批图像</p>
			<p>在这里，您可以看到一批船只和飞机图像的输出，这些图像可以输入到一个模型中。请注意，所有图像的大小都相同，这是通过修改图像的纵横比实现的。这确保了图像在传入人工神经网络时的一致性。</p>
			<p>在本练习中，您学习了如何成批导入图像，以便它们可用于训练神经网络。一次加载一批图像，通过限制每批的训练图像数量，可以确保不超过机器的RAM。</p>
			<p>在下一节中，您将看到如何在加载图像时对其进行放大。</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>图像增强</h1>
			<p>图像增强是修改图像以增加可用训练样本数量的过程。这个过程可以包括放大图像、旋转图像或者垂直或水平翻转图像。如果增强过程不改变图像的上下文，这可以被执行。例如，一个香蕉的图像，当水平翻转时，仍然可以被识别为一个香蕉，并且新的香蕉图像可能是任一方向的。在这种情况下，在训练过程中为两个方向提供一个模型将有助于建立一个健壮的模型。</p>
			<p>然而，如果你有一张船的图像，垂直翻转它可能不合适，因为这并不代表船在图像中通常是如何颠倒的。图像增强的最终目标是增加训练图像的数量，这些训练图像与日常出现的对象相似，并保留上下文。这将有助于训练好的模型在新的、看不见的图像上表现良好。下图是一个图像放大的例子，其中一个香蕉的图像被放大了三倍；左边的图像是原始图像，右边的是增强图像。</p>
			<p>右上图是水平翻转的原图，右中图是放大15%的原图，右下图是旋转10度的原图。在这个增强过程之后，你有一个香蕉的四个图像，每个图像都有香蕉在不同的位置和方向:</p>
			<div><div><img src="img/B16341_02_13.jpg" alt="Figure 2.13: An example of image augmentation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图2.13:图像增强的一个例子</p>
			<p>当每批图像加载时，可以使用TensorFlow的<code>ImageDataGenerator</code>类来实现图像放大。类似于图像缩放，可以应用各种图像放大过程。常见增强过程的论据包括以下几点:</p>
			<ul>
				<li><code>horizontal_flip</code>:水平翻转图像。</li>
				<li><code>vertical_flip</code>:垂直翻转图像。</li>
				<li><code>rotation_range</code>:将图像旋转给定的角度。</li>
				<li><code>width_shift_range</code>:将图像沿其宽度轴移动到给定的分数或像素数。</li>
				<li><code>height_shift_range</code>:将图像沿其高度轴移动至给定的分数或像素量。</li>
				<li><code>brightness_range</code>:将图像的亮度修改到给定量。</li>
				<li><code>shear_range</code>:将图像剪切到给定的量。</li>
				<li><code>zoom_range</code>:将图像放大到给定的量。</li>
			</ul>
			<p>当实例化<code>ImageDataGenerator</code>类时，可以应用图像增强，如下所示:</p>
			<pre>datagenerator = ImageDataGenerator(rescale = 1./255,\
                                   shear_range = 0.2,\
                                   rotation_range= 180,\
                                   zoom_range = 0.2,\
                                   horizontal_flip = True)</pre>
			<p>在以下活动中，您将使用TensorFlow的<code>ImageDataGenerator</code>类执行图像增强。这个过程就像传入参数一样简单。您将使用在<em class="italic">练习2.03 </em>、<em class="italic">加载图像数据进行批处理</em>中使用的相同数据集，其中包含船只和飞机的图像。</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>活动2.02:加载图像数据进行批处理</h2>
			<p>在本活动中，您将加载图像数据进行批处理，并在处理过程中扩充图像。<code>image_data</code>文件夹包含一组船只和飞机的图像。您需要加载图像数据进行批处理，并通过随机扰动(如旋转、水平翻转图像和对图像添加剪切)来调整输入数据。这将从现有的图像数据中创建额外的训练数据，并且通过增加不同训练示例的数量，即使只有少数可用，也将导致更准确和更鲁棒的机器学习模型。然后，您的任务是从数据生成器中打印一批带标签的图像。</p>
			<p>此活动的步骤如下:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来执行此活动。</li>
				<li>从<code>tensorflow.keras.preprocessing.image</code>导入<code>ImageDataGenerator</code>类。</li>
				<li>实例化<code>ImageDataGenerator</code>并设置<code>rescale=1./255</code>、<code>shear_range=0.2</code>、<code>rotation_range=180</code>、<code>zoom_range=0.2</code>和<code>horizontal_flip=True</code>参数。</li>
				<li>使用<code>flow_from_directory</code>方法将数据生成器指向图像，同时传入目标尺寸为<code>64x64</code>，批次尺寸为<code>25</code>，类别模式为<code>binary</code>。</li>
				<li>创建一个函数来显示5x5数组中的前25个图像及其相关标签。</li>
				<li>Take a batch from the data generator and pass it to the function to display the images and their labels.<p class="callout-heading">注意</p><p class="callout">此活动的解决方案可通过<a href="B16341_Solution_ePub.xhtml#_idTextAnchor256">此链接</a>找到。</p></li>
			</ol>
			<p>在本练习中，您批量扩充了图像，以便它们可以用于训练人工神经网络。您已经看到，当图像被用作输入时，它们可以被扩充以生成大量有效的训练示例。</p>
			<p>您学习了如何批量加载图像，这使您能够对大量数据进行训练，而这些数据可能一次放不进您的机器的内存。您还了解了如何使用<code>ImageDataGenerator</code>类来扩充图像，这实际上是从训练集中的图像生成新的训练示例。</p>
			<p>在下一节中，您将学习如何加载和预处理文本数据。</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>文本处理</h1>
			<p>文本数据代表一大类容易获得的原始数据。例如，文本数据可以来自维基百科等网页、转录的语音或社交媒体对话——所有这些数据都在大规模增加，必须经过处理才能用于训练机器学习模型。</p>
			<p>由于以下几个不同的原因，处理文本数据可能会很困难:</p>
			<ul>
				<li>存在成千上万个不同的单词。</li>
				<li>不同的语言带来了挑战。</li>
				<li>文本数据通常大小不一。</li>
			</ul>
			<p>有许多方法可以将文本数据转换成数字表示。一种方法是对单词进行一次性编码，就像你在<em class="italic">练习2.02 </em>、<em class="italic">预处理非数字数据</em>中对日期字段所做的那样。然而，这在训练模型时出现了问题，因为具有许多唯一单词的大型数据集将导致稀疏的数据集，并可能导致训练速度缓慢和潜在的不准确模型。此外，如果遇到不在训练数据中的新单词，则模型不能使用该单词。</p>
			<p>用来表示文本数据的一种流行方法是将整段文本转换成嵌入向量。存在预训练的模型来将原始文本转换成向量。这些模型通常是在大量文本上训练的。使用来自预训练模型的单词嵌入向量具有一些明显的优点:</p>
			<ul>
				<li>产生的向量具有固定的大小。</li>
				<li>向量保持上下文信息，因此它们受益于迁移学习。</li>
				<li>不需要对数据做进一步的预处理，嵌入的结果可以直接输入到人工神经网络中。</li>
			</ul>
			<p>虽然TensorFlow Hub将在下一章中更深入地讨论，但以下是如何使用预训练模型作为预处理步骤的示例。要加载预训练的模型，您需要导入<code>tensorflow_hub</code>库。通过这样做，可以加载模型的URL。然后，可以通过调用<code>KerasLayer</code>类将模型加载到环境中，该类包装了模型，以便可以像使用任何其他TensorFlow模型一样使用它。它可以按如下方式创建:</p>
			<pre>import tensorflow_hub as hub
model_url = "url_of_model"
hub_layer = hub.KerasLayer(model_url, \
                           input_shape=[], dtype=tf.string, \
                           trainable=True)</pre>
			<p>由<code>dtype</code>参数指示的输入数据的数据类型应该被用作<code>KerasLayer</code>类的输入，以及指示权重是否可训练的布尔自变量。一旦使用<code>tensorflow_hub</code>库加载了模型，就可以在文本数据上调用它，如下所示:</p>
			<pre>hub_layer(data)</pre>
			<p>这将通过预训练模型运行数据。输出将基于预训练模型的架构和权重。</p>
			<p>在以下练习中，您将探索如何加载包含文本字段的数据、批处理数据集，以及将预训练模型应用于文本字段以将字段转换为嵌入向量。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">预训练的模型可以在这里找到:<a href="https://tfhub.dev/google/tf2-preview/gnews-swivel-20dim/1">https://tfhub.dev/google/tf2-preview/gnews-swivel-20dim/1</a>。</p>
			<p class="callout">数据集可以在这里找到:<a href="https://archive.ics.uci.edu/ml/datasets/Drug+Review+Dataset+%28Drugs.com%29">https://archive . ics . UCI . edu/ml/datasets/Drug+Review+Dataset+% 28 drugs . com % 29</a>。</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>练习2.04:加载张量流模型的文本数据</h2>
			<p>数据集<code>drugsComTrain_raw.tsv</code>包含与患者对特定药物的评论相关的信息，以及其相关状况和表明患者对药物满意度的评级。在本练习中，您将加载文本数据进行批处理。您将应用TensorFlow Hub的预训练模型对患者评论执行单词嵌入。您只需要在包含文本数据的<code>review</code>字段上工作。</p>
			<p>执行以下步骤:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来实现这个练习。将文件另存为<code>Exercise2-04.ipnyb</code>。</li>
				<li>在新的Jupyter笔记本单元格中，导入TensorFlow库:<pre>import tensorflow as tf</pre></li>
				<li>使用库的<code>make_csv_dataset</code>函数创建一个TensorFlow数据集对象。将<code>batch_size</code>参数设置为等于<code>1</code>，将<code>field_delim</code>参数设置为<code>'\t'</code>，因为数据集是用制表符分隔的:<pre>df = tf.data.experimental.make_csv_dataset\      ('../Datasets/drugsComTest_raw.tsv', \       batch_size=1, field_delim='\t')</pre></li>
				<li>创建一个函数，将数据集对象作为输入，并对数据集进行混洗、重复和批处理:<pre>def prep_ds(ds, shuffle_buffer_size=1024, \             batch_size=32):     # Shuffle the dataset     ds = ds.shuffle(buffer_size=shuffle_buffer_size)     # Repeat the dataset     ds = ds.repeat()     # Batch the dataset     ds = ds.batch(batch_size)     return ds</pre></li>
				<li>将函数应用于您在<em class="italic">步骤3 </em>中创建的数据集对象，设置<code>batch_size</code>等于<code>5</code> : <pre>ds = prep_ds(df, batch_size=5)</pre></li>
				<li>Take the first batch and print it out:<pre>for x in ds.take(1):\
    print(x)</pre><p>您应该会得到类似如下的输出:</p><div><img src="img/B16341_02_14.jpg" alt="Figure 2.14: A batch from the dataset object&#13;&#10;"/></div><p class="figure-caption">图2.14:来自数据集对象的批处理</p><p>输出以张量格式表示输入数据。</p></li>
				<li>从TensorFlow Hub导入预训练的单词嵌入模型，创建一个Keras层:<pre>import tensorflow_hub as hub embedding = "https://tfhub.dev/google/tf2-preview"\             "/gnews-swivel-20dim/1" hub_layer = hub.KerasLayer(embedding, input_shape=[], \                            dtype=tf.string, \                            trainable=True)</pre></li>
				<li>Take one batch from the dataset, flatten the tensor corresponding to the <code>review</code> field, apply the pretrained layer, and print it out: <pre>for x in ds.take(1):\
    print(hub_layer(tf.reshape(x['review'],[-1])))</pre><p>这将显示以下输出:</p><div><img src="img/B16341_02_15.jpg" alt="Figure 2.15: A batch of the review column after the pretrained model &#13;&#10;has been applied to the text&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.15:预训练模型应用于文本后的一批评论列</p>
			<p>前面的输出表示第一批药物综述的嵌入向量。乍一看，特定值可能没有多大意义，但是嵌入中编码的是基于数据集的上下文信息，嵌入模型是在该数据集上训练的。批次大小等于<code>5</code>，嵌入向量大小为<code>20</code>，这意味着在应用预拉伸层后，结果大小为<code>5x20</code>。</p>
			<p>在本练习中，您学习了如何导入可能包含各种数据类型的表格数据。您获取了<code>review</code>字段，并应用了一个预训练的单词嵌入模型来将文本转换成数字张量。最后，您对文本数据进行了预处理和批处理，使其适合大规模训练。这是表示文本的一种方式，以便可以将其输入TensorFlow中的机器学习模型。事实上，可以使用其他预训练的单词嵌入模型，并且在TensorFlow Hub上可以获得。在下一章中，您将了解更多关于如何利用TensorFlow Hub的信息。</p>
			<p>在本节中，您了解了一种用于机器学习模型的预处理文本数据的方法。有很多不同的方法可以用来从文本中生成一个数值张量。例如，你可以对单词进行一次性编码，删除停用词，对单词进行词干分析和词条分类，或者甚至做一些简单的事情，比如计算每篇评论中的单词数。本节中演示的方法很有优势，因为它实现起来很简单。此外，单词嵌入将难以用其他方法编码的上下文信息合并到文本中，例如一键编码。</p>
			<p>最终，将任何领域知识应用于预处理步骤以尽可能多地保留上下文信息，这取决于从业者。这将允许任何后续模型学习特征和目标变量之间的基本函数。</p>
			<p>在下一节中，您将学习如何加载和处理音频数据，以便这些数据可以用于TensorFlow模型。</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>音频处理</h1>
			<p>本节将演示如何批量加载音频数据，以及如何对其进行处理，以便将其用于训练机器学习模型。有一些先进的信号处理发生预处理音频文件。其中一些步骤是可选的，但它们提供了一种处理音频数据的综合方法。因为每个音频文件可能有数百KB，所以您将利用批处理，就像处理图像数据一样。批处理可以通过创建数据集对象来实现。从原始数据创建数据集对象的一般方法是使用TensorFlow的<code>from_tensor_slice</code>函数。该函数通过沿张量的第一维对其进行切片来生成数据集对象。它可以按如下方式使用:</p>
			<pre>dataset = tf.data.Dataset\
            .from_tensor_slices([1, 2, 3, 4, 5])</pre>
			<p>使用TensorFlow可以将音频数据加载到Python环境中，方法是使用<code>read_file</code>函数将文件读入内存，然后使用<code>decode_wav</code>函数对文件进行解码。当使用<code>decode_wav</code>函数时，采样率(代表一秒钟内有多少数据点)以及想要使用的通道必须作为参数传入。例如，如果为所需通道传递了值<code>-1</code>，那么所有音频通道都将被解码。导入音频文件可以通过以下方式实现:</p>
			<pre>sample_rate = 44100
audio_data = tf.io.read_file('path/to/file')
audio, sample_rate = tf.audio.decode_wav\
                     (audio_data,\
                      desired_channels=-1,\
                      desired_samples=sample_rate)</pre>
			<p>与文本数据一样，您必须对数据进行预处理，以便生成的数值张量与数据大小相同。这是通过在将数据转换到频域后对音频文件进行采样来实现的。对音频进行采样可以被认为是将音频文件分割成大小始终相同的块。例如，30秒的音频文件可以分成30个1秒不重叠的音频样本，同样，15秒的音频文件可以分成15个1秒不重叠的样本。因此，您的结果是45个大小相等的音频样本。</p>
			<p>可以对音频数据执行的另一个常见预处理步骤是将音频样本从时域转换到频域。解释时域中的数据有助于理解音频的强度或音量，而频域可以帮助您发现存在哪些频率。这对于分类声音是有用的，因为不同的对象具有不同的特征声音，这些特征声音将出现在频域中。使用<code>stft</code>功能可以将音频数据从时域转换到频域。</p>
			<p>该函数对输入数据进行短时傅立叶变换。该函数的参数包括帧长度，它是一个整数值，表示样本中的窗口长度；帧步长，它是描述要步进的样本数的整数值；以及<strong class="bold">快速傅立叶变换</strong> ( <strong class="bold"> FFT </strong>)长度，其是指示要应用的FFT的长度的整数值。频谱图是短时傅立叶变换的绝对值，因为它对于视觉解释是有用的。短时傅立叶变换和频谱图可以如下创建:</p>
			<pre>stfts = tf.signal.stft(audio, frame_length=1024,\
                       frame_step=256,\
                       fft_length=1024)
spectrograms = tf.abs(stfts)</pre>
			<p>另一个可选的预处理步骤是生成<strong class="bold">梅尔频率倒谱系数</strong>(<strong class="bold">MFCC</strong>)。顾名思义，MFCCs是梅尔频率倒谱的系数。倒谱是音频信号的短期功率谱的表示。MFCCs通常用于语音识别和音乐信息检索的应用中。因此，理解如何生成MFCCs的每个步骤可能并不重要，但是理解它们可以作为预处理步骤来应用以增加音频数据管道的信息密度是有益的。</p>
			<p>MFCCs是通过创建矩阵将线性比例扭曲到mel比例来生成的。可使用<code>linear_to_mel_weight_matrix</code>并通过输入最终mel光谱中的波段数、源光谱图中的频段数、采样率以及mel光谱中包含的较低和较高频率来创建该矩阵。一旦创建了线性-mel权重矩阵，使用<code>tensordot</code>函数沿第一轴应用光谱图的张量收缩。</p>
			<p>在此之后，应用数值的对数来生成对数mel光谱图。最后，可以应用<code>mfccs_from_log_mel_spectrograms</code>函数来生成在对数mel光谱图中传递的MFCCs。这些步骤可以应用如下:</p>
			<pre>lower_edge_hertz, upper_edge_hertz, num_mel_bins \
    = 80.0, 7600.0, 80
linear_to_mel_weight_matrix \
    = tf.signal.linear_to_mel_weight_matrix\
      (num_mel_bins, num_spectrogram_bins, sample_rate, \
       lower_edge_hertz, upper_edge_hertz)
mel_spectrograms = tf.tensordot\
                   (spectrograms, \
                    linear_to_mel_weight_matrix, 1)
mel_spectrograms.set_shape\
    (spectrograms.shape[:-1].concatenate\
    (linear_to_mel_weight_matrix.shape[-1:]))
log_mel_spectrograms = tf.math.log(mel_spectrograms + 1e-6)
mfccs = tf.signal.mfccs_from_log_mel_spectrograms\
        (log_mel_spectrograms)[..., :num_mfccs]</pre>
			<p>在下面的练习中，您将了解如何处理音频数据。与您在<em class="italic">练习2.03 </em>、<em class="italic">加载图像数据进行批处理</em>和<em class="italic">练习</em> <em class="italic"> 2.04 </em>、<em class="italic">加载TensorFlow模型的文本数据</em>中所做的类似，您将批量加载数据以进行高效和可扩展的训练。您将使用TensorFlow的通用<code>read_file</code>函数加载音频文件，然后使用TensorFlow的<code>decode_wav</code>函数解码音频数据。然后，您将创建一个从每个音频样本生成MFCCs的函数。最后，将生成一个数据集对象，该对象可以传递到TensorFlow模型中进行训练。您将利用的数据集是谷歌的语音命令数据集，它由一秒钟长的话语组成。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">数据集可以在这里找到:<a href="https://packt.link/Byurf">https://packt.link/Byurf</a>。</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>练习2.05:为TensorFlow模型加载音频数据</h2>
			<p>在本练习中，您将学习如何载入音频数据进行批处理。数据集<code>data_speech_commands_v0.02</code>包含了人们以44.1 kHz的采样率说出单词<code>zero</code>一秒钟的语音样本，这意味着每秒钟有44100个数据点。您将应用一些常见的音频预处理技术，包括将数据转换到傅立叶域，对数据进行采样以确保数据与模型具有相同的大小，以及为每个音频样本生成MFCCs。这将生成预处理的数据集对象，该对象可以输入到TensorFlow模型中进行训练。</p>
			<p>执行以下步骤:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来实现这个练习。将文件另存为<code>Exercise2-05.ipnyb</code>。</li>
				<li>在一个新的Jupyter笔记本单元格中，导入<code>tensorflow</code>和<code>os</code>库:<pre>import tensorflow as tf import os</pre></li>
				<li>分别使用TensorFlow的<code>read_file</code>函数和<code>decode_wav</code>函数创建一个加载音频文件的函数。返回合成张量的转置:<pre>def load_audio(file_path, sample_rate=44100):     # Load audio at 44.1kHz sample-rate     audio = tf.io.read_file(file_path)     audio, sample_rate = tf.audio.decode_wav\                          (audio,\                           desired_channels=-1,\                           desired_samples=sample_rate)     return tf.transpose(audio)</pre></li>
				<li>使用<code>os.list_dir</code> : <pre>prefix = " ../Datasets/data_speech_commands_v0.02"\         "/zero/" paths = [os.path.join(prefix, path) for path in \          os.listdir(prefix)]</pre>将音频数据的路径作为列表载入</li>
				<li>Test the function by loading in the first audio file from the list and plotting it:<pre>import matplotlib.pyplot as plt
audio = load_audio(paths[0])
plt.plot(audio.numpy().T)
plt.xlabel('Sample')
plt.ylabel('Value')</pre><p>输出如下所示:</p><div><img src="img/B16341_02_16.jpg" alt="Figure 2.16: A visual representation of an audio file&#13;&#10;"/></div><p class="figure-caption">图2.16:音频文件的可视化表示</p><p>该图示出了语音样本的波形。给定时间的振幅对应于声音的音量；高振幅与高音量相关。</p></li>
				<li>创建一个从音频数据生成MFCCs的函数。首先，将传入音频信号的短时傅立叶变换作为第一个参数，将设置为<code>1024</code>的帧长度作为第二个参数，将设置为<code>256</code>的帧步长作为第三个参数，将FFT长度作为第四个参数。然后，取结果的绝对值来计算光谱图。频谱图面元的数量由沿短时傅立叶变换的最后一个轴的长度给出。接下来，将梅尔权重矩阵的上界和下界分别定义为<code>80</code>和<code>7600</code>，并将梅尔箱的数量定义为<code>80</code>。然后，使用TensorFlow的信号包中的<code>linear_to_mel_weight_matrix</code>计算mel权重矩阵。接下来，使用TensorFlow的<code>tensordot</code>函数通过张量收缩沿着光谱图的轴1计算mel光谱图，该光谱图具有mel权重矩阵。然后，在使用TensorFlow的<code>mfccs_from_log_mel_spectrograms</code>函数最终计算MFCCs之前，取mel光谱图的对数。然后，从函数<pre>def apply_mfccs(audio, sample_rate=44100, num_mfccs=13):     stfts = tf.signal.stft(audio, frame_length=1024, \                            frame_step=256, \                            fft_length=1024)     spectrograms = tf.abs(stfts)     num_spectrogram_bins = stfts.shape[-1]#.value     lower_edge_hertz, upper_edge_hertz, \     num_mel_bins = 80.0, 7600.0, 80     linear_to_mel_weight_matrix = \       tf.signal.linear_to_mel_weight_matrix\       (num_mel_bins, num_spectrogram_bins, \        sample_rate, lower_edge_hertz, upper_edge_hertz)     mel_spectrograms = tf.tensordot\                        (spectrograms, \                         linear_to_mel_weight_matrix, 1)     mel_spectrograms.set_shape\     (spectrograms.shape[:-1].concatenate\     (linear_to_mel_weight_matrix.shape[-1:]))     log_mel_spectrograms = tf.math.log\                            (mel_spectrograms + 1e-6)     #Compute MFCCs from log_mel_spectrograms     mfccs = tf.signal.mfccs_from_log_mel_spectrograms\             (log_mel_spectrograms)[..., :num_mfccs]     return mfccs</pre>返回MFCCs</li>
				<li>Apply the function to generate the MFCCs for the audio data you loaded in <em class="italic">Step 5</em>:<pre>mfcc = apply_mfccs(audio)
plt.pcolor(mfcc.numpy()[0])
plt.xlabel('MFCC log coefficient')
plt.ylabel('Sample Value')</pre><p>输出如下所示:</p><div><img src="img/B16341_02_17.jpg" alt="Figure 2.17: A visual representation of the MFCCs of an audio file&#13;&#10;"/></div><p class="figure-caption">图2.17:音频文件的MFCCs的可视化表示</p><p>前面的图显示了在<em class="italic"> x </em>轴上的MFCC值和在<em class="italic"> y </em>轴上的音频样本的各个点。MFCCs是在<em class="italic">步骤5 </em>中显示的原始音频信号的不同表示，已被证明在与语音识别相关的应用中是有用的。</p></li>
				<li>加载<code>AUTOTUNE</code>以便可以使用CPU的所有可用线程。创建一个接受数据集对象的函数，混洗它，使用您在<em class="italic">步骤3 </em>中创建的函数加载音频，使用您在<em class="italic">步骤6 </em>中创建的函数生成MFCCs，重复数据集对象，批处理它，并预取它。使用<code>AUTOTUNE</code>根据您的可用CPU: <pre>AUTOTUNE = tf.data.experimental.AUTOTUNE def prep_ds(ds, shuffle_buffer_size=1024, \             batch_size=64):     # Randomly shuffle (file_path, label) dataset     ds = ds.shuffle(buffer_size=shuffle_buffer_size)     # Load and decode audio from file paths     ds = ds.map(load_audio, num_parallel_calls=AUTOTUNE)     # generate MFCCs from the audio data     ds = ds.map(apply_mfccs)     # Repeat dataset forever     ds = ds.repeat()     # Prepare batches     ds = ds.batch(batch_size)     # Prefetch     ds = ds.prefetch(buffer_size=AUTOTUNE)     return ds</pre>的缓冲区大小进行预取</li>
				<li>使用您在<em class="italic">步骤8 </em>中创建的函数生成训练数据集。为此，使用TensorFlow的<code>from_tensor_slices</code>函数创建一个数据集对象，并传递音频文件的路径。之后，您可以使用您在<em class="italic">步骤8 </em>中创建的函数:<pre>ds = tf.data.Dataset.from_tensor_slices(paths) train_ds = prep_ds(ds)</pre></li>
				<li>Take the first batch of the dataset and print it out:<pre>for x in train_ds.take(1):\
    print(x)</pre><p>输出如下所示:</p><div><img src="img/B16341_02_18.jpg" alt="Figure 2.18: A batch of the audio data after the MFCCs have been generated&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.18:生成MFCCs后的一批音频数据</p>
			<p>输出以张量形式显示第一批MFCC频谱值。</p>
			<p>在本练习中，您导入了音频数据。您处理了数据集并对数据集进行了批处理，使其适用于大规模训练。该方法是一种综合方法，其中数据被加载并转换到频域，产生频谱图，然后最终产生MFCCs。</p>
			<p>在下一个活动中，您将加载音频数据并获取输入的绝对值，然后对这些值进行对数缩放。这将确保数据集中没有负值。您将使用在<em class="italic">练习2.05 </em>、<em class="italic">加载TensorFlow模型的音频数据</em>中使用的相同音频数据集，即Google的语音命令数据集。这个数据集由1秒长的话语组成。</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>活动2.03:加载音频数据进行批处理</h2>
			<p>在本活动中，您将加载音频数据进行批处理。将要执行的音频预处理技术包括取绝对值和使用1加上该值的对数。这将确保结果值是非负的和对数标度的。结果将是预处理的数据集对象，该对象可以输入到TensorFlow模型中进行训练。</p>
			<p>此活动的步骤如下:</p>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本来执行此活动。</li>
				<li>导入TensorFlow和<code>os</code>库。</li>
				<li>分别使用TensorFlow的<code>read_file</code>函数和<code>decode_wav</code>函数创建一个函数来加载和解码音频文件。从函数中返回结果张量的转置。</li>
				<li>使用<code>os.list_dir</code>将文件路径作为列表加载到音频数据中。</li>
				<li>创建一个函数，该函数接受一个数据集对象，对其进行混洗，使用您在<em class="italic">步骤2 </em>中创建的函数加载音频，并将绝对值和<code>log1p</code>函数应用于数据集。该函数将<code>1</code>与数据集中的每个值相加，然后对结果应用对数。接下来，重复dataset对象，对其进行批处理，并使用与批处理大小相等的缓冲区大小预取它。</li>
				<li>使用TensorFlow的<code>from_tensor_slices</code>函数创建一个数据集对象，并传入音频文件的路径。然后，将您在<em class="italic">步骤4 </em>中创建的函数应用于在<em class="italic">步骤5 </em>中创建的数据集。</li>
				<li>取出第一批数据集并打印出来。</li>
				<li>Plot the first audio file from the batch.<p>输出将如下所示:</p><div><img src="img/B16341_02_19.jpg" alt="Figure 2.19: Expected output of Activity 2.03&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图2.19:活动2.03的预期产出</p>
			<p class="callout-heading">注意</p>
			<p class="callout">此活动的解决方案可通过<a href="B16341_Solution_ePub.xhtml#_idTextAnchor257">此链接</a>找到。</p>
			<p>在本练习中，您学习了如何批量载入和预处理音频数据。您使用了在<em class="italic">练习2.05 </em>、<em class="italic">加载TensorFlow模型的音频数据</em>中使用的大多数函数，来加载数据并解码原始数据。<em class="italic">练习2.05 </em>、<em class="italic">加载TensorFlow模型音频数据</em>与<em class="italic">活动2.03 </em>、<em class="italic">加载音频数据批量处理</em>的区别在于预处理步骤；<em class="italic">练习2.05 </em>、<em class="italic">加载TensorFlow模型的音频数据</em>，涉及生成音频数据的MFCCs，而<em class="italic">活动2.03 </em>、<em class="italic">加载音频数据进行批处理</em>，涉及对数缩放数据。两者都展示了通用的预处理技术，可用于所有涉及音频数据建模的应用。</p>
			<p>在本节中，您已经探索了如何为TensorFlow建模批量加载音频数据。该综合方法展示了许多先进的信号处理技术，为希望将音频数据用于自己应用的从业者提供了一个良好的起点。</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>总结</h1>
			<p>在本章中，您学习了如何加载不同形式的数据，并对各种数据类型执行一些预处理步骤。您从CSV文件形式的表格数据开始。因为数据集由一个CSV文件组成，所以您利用pandas库将文件加载到内存中。</p>
			<p>然后，通过缩放字段并将所有字段转换为数字数据类型来对数据进行预处理。这一点很重要，因为张量流模型只能根据数字数据进行训练，如果所有场的规模相同，训练过程在速度和精度方面都会得到提高。</p>
			<p>接下来，您探索了如何加载图像数据。您对数据进行了批处理，因此不必一次加载整个数据集，这允许您扩充图像。图像增强是有用的，因为它增加了训练样本的有效数量，并且可以帮助使模型更加健壮。</p>
			<p>然后，您学习了如何加载文本数据并利用预先训练的模型。这有助于您将文本嵌入到保留文本上下文信息的向量中。这允许文本数据输入到张量流模型中，因为它们需要数字张量作为输入。</p>
			<p>最后，最后一节介绍了如何加载和处理音频数据，并展示了一些先进的信号处理技术，包括生成MFCCss，MFCC可用于生成信息密集的数值张量，以便输入到TensorFlow模型中。</p>
			<p>加载和预处理数据以便可以将其输入到机器学习模型中是训练任何机器学习模型的重要且必要的第一步。在下一章中，您将探索TensorFlow提供的许多资源，以帮助开发模型构建。</p>
		</div>
		<div><div/>
		</div>
	

</body></html>