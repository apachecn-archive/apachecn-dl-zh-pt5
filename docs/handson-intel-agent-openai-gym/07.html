<html><head/><body>

  
    <title>Creating Custom OpenAI Gym Environments - CARLA Driving Simulator</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">创建定制的开放式健身环境-卡拉驾驶模拟器</h1>
                
            
            
                
<p class="calibre2">在第一章中，我们看了OpenAI Gym环境目录中可用的各种学习环境。然后我们在<a href="part0078.html#2ACBS0-22c7fc7f93b64d07be225c00ead6ce12" class="calibre9">第5章</a>、<em class="calibre13">实现您的第一个学习代理——解决山地汽车问题</em>中探索了环境列表和它们的术语，并先睹为快。我们还开发了我们的代理来解决山地汽车和手推车杆的问题，以及一些雅达利游戏环境。现在，你应该对OpenAI Gym提供的各种环境类型和风格有了很好的理解。大多数情况下，一旦我们学会了如何开发我们自己的智能代理，我们就想用这些知识和技能来开发智能代理，以解决新的问题，我们已经面临的问题，甚至是我们感兴趣的问题。例如，你可能是一名希望为游戏角色添加智能行为的游戏开发人员，或者是一名希望为机器人注入人工智能的机器人工程师，或者你可能是一名希望将强化学习应用于自动驾驶的自动驾驶工程师。你可能是一个想要将一个小工具变成智能<strong class="calibre4">物联网</strong> ( <strong class="calibre4"> IoT </strong>)设备的修补匠，或者你甚至可能是一个想要使用机器学习来提高实验室诊断能力的医疗保健专业人员。应用的潜力几乎是无限的。</p>
<p class="calibre2">我们选择OpenAI Gym作为我们的学习环境的原因之一是因为它简单而标准的界面，将环境的类型和性质与环境代理界面分离。在这一章中，我们将看看如何根据你自己的个人或职业需要来创造你自己的环境。这将使您能够使用代理实现、培训和测试脚本、参数管理器以及我们在前面章节中针对您自己的设计或问题开发的日志记录和可视化例程。</p>


            

            
        
    



  
    <title>Understanding the anatomy of Gym environments</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">理解健身房环境的解剖</h1>
                
            
            
                
<p class="calibre2">任何Gym兼容的环境都应该子类化<kbd class="calibre12">gym.Env</kbd>类并实现<kbd class="calibre12">reset</kbd>和<kbd class="calibre12">step</kbd>方法以及<kbd class="calibre12">observation_space</kbd>和<kbd class="calibre12">action_space</kbd>属性和特性。还有机会实现其他可选的方法，为我们的定制环境添加额外的功能。下表列出并描述了其他可用的方法:</p>
<table border="1" class="calibre41">
<tbody class="calibre36">
<tr class="calibre37">
<td class="calibre75"><div> <strong class="calibre1">方法</strong> </div></td>
<td class="calibre76"><div> <strong class="calibre1">功能描述</strong> </div></td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">observation_space</kbd> </div></td>
<td class="calibre76">环境返回的观察结果的形状和类型。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">action_space</kbd> </div></td>
<td class="calibre76">环境接受的行动的形式和类型。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">reset()</kbd> </div></td>
<td class="calibre76">在一集开始或结束时重置环境的例程。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">step(...)</kbd> </div></td>
<td class="calibre76">计算必要信息以推进环境、模拟或游戏到下一步的例程。该例程包括在环境中应用选择的动作，计算奖励，产生下一个观察，以及确定一个情节是否已经结束。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">_render()</kbd> </div></td>
<td class="calibre76">(可选)这会渲染健身房环境的状态或观察。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">_close()</kbd> </div></td>
<td class="calibre76">(可选)这将关闭健身房环境。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">_seed</kbd> </div></td>
<td class="calibre76">(可选)这为健身房环境中的随机函数播种了一个自定义种子，使环境的行为对于给定的种子来说是可重现的。</td>
</tr>
<tr class="calibre37">
<td class="calibre75"><div> <kbd class="calibre12">_configure</kbd> </div></td>
<td class="calibre76">(可选)这将启用额外的环境配置。</td>
</tr>
</tbody>
</table>
<p class="calibre2"/>


            

            
        
    



  
    <title>Creating a template for custom Gym environment implementations</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">为自定义健身房环境实施创建模板</h1>
                
            
            
                
<p class="calibre2">基于我们已经讨论过的健身房环境的剖析，我们现在将展示一个名为<kbd class="calibre12">CustomEnv</kbd>的定制环境类实现的基本版本，它将是<kbd class="calibre12">gym.Env</kbd>的子类，并实现使其成为健身房兼容环境所需的基本方法和参数。最小实现的模板如下:</p>
<pre class="calibre17">import gym<br class="title-page-name"/><br class="title-page-name"/>class CustomEnv(gym.Env):<br class="title-page-name"/>    """<br class="title-page-name"/>    A template to implement custom OpenAI Gym environments<br class="title-page-name"/><br class="title-page-name"/>    """<br class="title-page-name"/><br class="title-page-name"/>    metadata = {'render.modes': ['human']}<br class="title-page-name"/>    def __init__(self):<br class="title-page-name"/>        self.__version__ = "0.0.1"<br class="title-page-name"/>        # Modify the observation space, low, high and shape values according to your custom environment's needs<br class="title-page-name"/>        self.observation_space = gym.spaces.Box(low=0.0, high=1.0, shape=(3,))<br class="title-page-name"/>        # Modify the action space, and dimension according to your custom environment's needs<br class="title-page-name"/>        self.action_space = gym.spaces.Box(4)<br class="title-page-name"/><br class="title-page-name"/>    def step(self, action):<br class="title-page-name"/>        """<br class="title-page-name"/>        Runs one time-step of the environment's dynamics. The reset() method is called at the end of every episode<br class="title-page-name"/>        :param action: The action to be executed in the environment<br class="title-page-name"/>        :return: (observation, reward, done, info)<br class="title-page-name"/>            observation (object):<br class="title-page-name"/>                Observation from the environment at the current time-step<br class="title-page-name"/>            reward (float):<br class="title-page-name"/>                Reward from the environment due to the previous action performed<br class="title-page-name"/>            done (bool):<br class="title-page-name"/>                a boolean, indicating whether the episode has ended<br class="title-page-name"/>            info (dict):<br class="title-page-name"/>                a dictionary containing additional information about the previous action<br class="title-page-name"/>        """</pre>
<pre class="calibre17"><br class="title-page-name"/>        # Implement your step method here<br class="title-page-name"/>        #   - Calculate reward based on the action<br class="title-page-name"/>        #   - Calculate next observation<br class="title-page-name"/>        #   - Set done to True if end of episode else set done to False<br class="title-page-name"/>        #   - Optionally, set values to the info dict<br class="title-page-name"/>        # return (observation, reward, done, info)<br class="title-page-name"/><br class="title-page-name"/>    def reset(self):<br class="title-page-name"/>        """<br class="title-page-name"/>        Reset the environment state and returns an initial observation<br class="title-page-name"/><br class="title-page-name"/>        Returns<br class="title-page-name"/>        -------<br class="title-page-name"/>        observation (object): The initial observation for the new episode after reset<br class="title-page-name"/>        :return:<br class="title-page-name"/>        """<br class="title-page-name"/><br class="title-page-name"/>        # Implement your reset method here<br class="title-page-name"/>        # return observation<br class="title-page-name"/><br class="title-page-name"/>    def render(self, mode='human', close=False):<br class="title-page-name"/>        """<br class="title-page-name"/><br class="title-page-name"/>        :param mode:<br class="title-page-name"/>        :return:<br class="title-page-name"/>        """<br class="title-page-name"/>        return</pre>
<p class="calibre2">在我们完成我们的环境类实现之后，我们应该用OpenAI Gym registry注册它，这样我们就可以使用<kbd class="calibre12">gym.make(ENV_NAME)</kbd>来创建环境的一个实例，就像我们之前对Gym环境所做的那样。</p>


            

            
        
    



  
    <title>Registering custom environments with OpenAI Gym</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">向OpenAI Gym注册自定义环境</h1>
                
            
            
                
<pre>CustomEnv class we implemented is as follows:</pre>
<pre class="calibre17">from gym.envs.registration import register<br class="title-page-name"/><br class="title-page-name"/>register(<br class="title-page-name"/>    id='CustomEnv-v0',<br class="title-page-name"/>    entry_point='custom_environments.envs:CustomEnv',<br class="title-page-name"/>)</pre>
<p class="calibre2">我们将在本章的后面使用这个模板来创建一个自定义的体育馆环境，它使用了一个非常复杂的驾驶模拟器。</p>


            

            
        
    



  
    <title>Creating an OpenAI Gym-compatible CARLA driving simulator environment</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">创建一个开放的健身房兼容卡拉驾驶模拟器环境</h1>
                
            
            
                
<p class="calibre2">CARLA是一个建立在非真实引擎4游戏引擎之上的驾驶模拟器环境，与一些竞争对手相比，它的渲染更加真实。你可以在https://carla.org的官方网站上了解更多关于卡拉模拟器的信息。在本节中，我们将研究如何创建一个定制的OpenAI Gym兼容的汽车驾驶环境来培训我们的学习代理。这是一个相当复杂的环境，需要一个GPU来运行——这与我们迄今为止看到的其他健身房环境不同。一旦您理解了如何为CARLA创建一个与健身房兼容的定制环境界面，您就有足够的信息来为您自己的定制环境开发界面，不管它们有多复杂。</p>
<p class="calibre2">卡拉的最新版本是卡拉0.8.2。虽然大多数(如果不是全部的话)核心环境接口，尤其是<kbd class="calibre12">PythonClient</kbd>库，可能会保持不变，但未来的变化有可能需要在这个定制环境实现中进行调整。如果发生这种情况，本书的代码库将相应地更新以支持CARLA的新版本。当你写这一章的时候，你可能想确保你使用的是本书代码库中最新版本的代码(这也是订阅GitHub通知的另一个原因)。尽管如此，本章中讨论的定制环境实现构建块将保持普遍适用，并将引导您定义自己的与OpenAI Gym接口兼容的定制环境。自定义CARLA环境接口的完整代码可以在本书的代码库中的<kbd class="calibre12">ch7/carla-gym</kbd>下找到。</p>
<p class="calibre2">在我们开始一个健身房兼容的卡拉环境之前，让我们先来看看卡拉模拟器。所以，让我们继续下载CARLA发布版的二进制文件。在下一节中，我们将使用<kbd class="calibre12">VER_NUM</kbd>来表示版本号，因此在运行以下命令之前，请确保将<kbd class="calibre12">VER_NUM</kbd>文本替换为您正在使用的版本号:</p>
<ol class="calibre14">
<li class="calibre11" value="1">首先，使用下面的bash命令在您的主目录中创建一个名为<kbd class="calibre12">software</kbd>的文件夹:</li>
</ol>
<pre class="calibre77"><strong class="calibre1">mkdir ~/software &amp;&amp; cd ~/software</strong></pre>
<ol start="2" class="calibre14">
<li class="calibre11" value="2">使用<a href="https://github.com/carla-simulator/carla/releases/tag/0.8.2" class="calibre9">https://github . com/CARLA-simulator/CARLA/releases/tag/VER编号</a>的官方发布页面上的链接，下载用于Linux的CARLA二进制发布版本(<a href="https://drive.google.com/open?id=1ZtVt1AqdyGxgyTm69nzuwrOYoPUn_Dsm" class="calibre9">CARLA _ VER _编号. tar.gz </a>)。(0.8.2版本的直接链接是:<a href="https://drive.google.com/open?id=1ZtVt1AqdyGxgyTm69nzuwrOYoPUn_Dsm" class="calibre9">https://drive.google.com/open?id = 1 ztvt 1 aqdygxgytm 69 nzuwroyopun _ Dsm</a>。)然后，提取到<kbd class="calibre12">~/software</kbd>。现在在<kbd class="calibre12">~/software/CARLA_VER_NUM</kbd>文件夹中应该有一个名为<kbd class="calibre12">CarlaUE4.sh</kbd>的文件。</li>
<li class="calibre11" value="3">使用以下命令将<kbd class="calibre12">CARLA_SERVER</kbd>环境变量设置为指向计算机上的<kbd class="calibre12">CarlaUE4.sh</kbd>:</li>
</ol>
<pre class="calibre77"><strong class="calibre1">export CARLA_SERVER=~/software/CARLA_VER_NUM/CarlaUE4.sh</strong></pre>
<p class="calibre2">现在您已经准备好试运行CARLA驾驶模拟器了！只需执行<kbd class="calibre12">$CARLA_SERVER</kbd>或者直接执行<kbd class="calibre12">~/software/CARLA_VER_NUM/CarlaUE4.sh</kbd>。对于CARLA版本0.8.2，该命令将为<kbd class="calibre12">~/software/CARLA_0.8.2/CarlaUE4.sh</kbd>。您现在应该会看到一个CARLA模拟器屏幕，如下面的屏幕截图所示:</p>
<p class="cdpaligncenter4"><img src="img/00149.jpeg" class="calibre78"/></p>
<p class="calibre2">前面的截图显示了车辆(代理)在卡拉的一个起始位置。下面的屏幕截图显示了车辆在CARLA环境中的另一个起始位置:</p>
<p class="cdpaligncenter4"><img src="img/00150.jpeg" class="calibre79"/></p>
<p class="calibre2">一旦车辆初始化，您应该能够使用键盘上的<em class="calibre13"> w </em>、<em class="calibre13"> a </em>、<em class="calibre13"> s </em>、<em class="calibre13"> d </em>键来控制车辆。<em class="calibre13"> w </em>键将向前移动汽车，<em class="calibre13"> a </em>键将向左转动汽车，并且...剩下的你大概就能想出来了！</p>
<p class="calibre2">现在让我们继续，从配置和初始化开始我们的Gym兼容的CARLA环境实现。</p>


            

            
        
    



  
    <title>Configuration and initialization</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">配置和初始化</h1>
                
            
            
                
<p class="calibre2">我们将首先定义一些特定于环境的配置参数，并简要地看一下场景配置。然后，我们将启动<kbd class="calibre12">CarlaEnv</kbd>类实现的初始化过程，它将从<kbd class="calibre12">Gym.Env</kbd>类继承而来。</p>


            

            
        
    



  
    <title>Configuration</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">配置</h1>
                
            
            
                
<p class="calibre2">让我们首先使用字典为环境定义一个配置参数列表，如下所示:</p>
<pre class="calibre17"># Default environment configuration<br class="title-page-name"/>ENV_CONFIG = {<br class="title-page-name"/>    "enable_planner": True,<br class="title-page-name"/>    "use_depth_camera": False,<br class="title-page-name"/>    "discrete_actions": True,<br class="title-page-name"/>    "server_map": "/Game/Maps/" + city,<br class="title-page-name"/>    "scenarios": [scenario_config["Lane_Keep_Town2"]],<br class="title-page-name"/>    "framestack": 2, # note: only [1, 2] currently supported<br class="title-page-name"/>    "early_terminate_on_collision": True,<br class="title-page-name"/>    "verbose": False,<br class="title-page-name"/>    "render_x_res": 800,<br class="title-page-name"/>    "render_y_res": 600,<br class="title-page-name"/>    "x_res": 80,<br class="title-page-name"/>    "y_res": 80<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre12">scenario_config</kbd>定义了几个对创建各种驾驶场景有用的参数。场景配置在<kbd class="calibre12">scenarios.json</kbd>文件中有描述，该文件可以在本书位于<kbd class="calibre12">ch7/carla-gym/carla_gym<br class="title-page-name"/> /envs/scenarios.json</kbd>的代码库中找到。</p>


            

            
        
    



  
    <title>Initialization</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">初始化</h1>
                
            
            
                
<p class="calibre2">在<kbd class="calibre12">__init__</kbd>方法中，我们定义了初始化参数以及动作和状态空间，正如我们在上一节中看到的，这是必要的。实现非常简单，如下所示:</p>
<pre class="calibre17">def __init__(self, config=ENV_CONFIG):<br class="title-page-name"/>        self.config = config<br class="title-page-name"/>        self.city = self.config["server_map"].split("/")[-1]<br class="title-page-name"/>        if self.config["enable_planner"]:<br class="title-page-name"/>            self.planner = Planner(self.city)<br class="title-page-name"/><br class="title-page-name"/>        if config["discrete_actions"]:<br class="title-page-name"/>            self.action_space = Discrete(len(DISCRETE_ACTIONS))<br class="title-page-name"/>        else:<br class="title-page-name"/>            self.action_space = Box(-1.0, 1.0, shape=(2,))<br class="title-page-name"/>        if config["use_depth_camera"]:<br class="title-page-name"/>            image_space = Box(<br class="title-page-name"/>                -1.0, 1.0, shape=(</pre>
<pre class="calibre17"><br class="title-page-name"/>                    config["y_res"], config["x_res"],<br class="title-page-name"/>                    1 * config["framestack"]))<br class="title-page-name"/>        else:<br class="title-page-name"/>            image_space = Box(<br class="title-page-name"/>                0.0, 255.0, shape=(<br class="title-page-name"/>                    config["y_res"], config["x_res"],<br class="title-page-name"/>                    3 * config["framestack"]))<br class="title-page-name"/>        self.observation_space = Tuple(<br class="title-page-name"/>            [image_space,<br class="title-page-name"/>             Discrete(len(COMMANDS_ENUM)),  # next_command<br class="title-page-name"/>             Box(-128.0, 128.0, shape=(2,))])  # forward_speed, dist to goal<br class="title-page-name"/><br class="title-page-name"/>        self._spec = lambda: None<br class="title-page-name"/>        self._spec.id = "Carla-v0"<br class="title-page-name"/><br class="title-page-name"/>        self.server_port = None<br class="title-page-name"/>        self.server_process = None<br class="title-page-name"/>        self.client = None<br class="title-page-name"/>        self.num_steps = 0<br class="title-page-name"/>        self.total_reward = 0<br class="title-page-name"/>        self.prev_measurement = None<br class="title-page-name"/>        self.prev_image = None<br class="title-page-name"/>        self.episode_id = None<br class="title-page-name"/>        self.measurements_file = None<br class="title-page-name"/>        self.weather = None<br class="title-page-name"/>        self.scenario = None<br class="title-page-name"/>        self.start_pos = None<br class="title-page-name"/>        self.end_pos = None<br class="title-page-name"/>        self.start_coord = None<br class="title-page-name"/>        self.end_coord = None<br class="title-page-name"/>        self.last_obs = None</pre>


            

            
        
    



  
    <title>Implementing the reset method</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">实现重置方法</h1>
                
            
            
                
<p class="calibre2">你可能已经注意到了，在每一集的开始，我们称之为健身房环境的<kbd class="calibre12">reset</kbd>方法。对于CARLA环境，我们希望通过CARLA客户端更新CARLA服务器以重启关卡。</p>
<p class="calibre2">所以，让我们继续开始我们的<kbd class="calibre12">reset</kbd>方法的实现。</p>


            

            
        
    



  
    <title>Customizing the CARLA simulation using the CarlaSettings object</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">使用CarlaSettings对象自定义CARLA模拟</h1>
                
            
            
                
<p class="calibre2">当我们开始一个新的情节时，我们希望能够配置开始状态(代理或车辆开始的位置)、目标状态(代理或车辆的预期目的地)、情节的复杂性(通过情节中车辆或行人的数量来衡量)、观察的类型和来源(车辆上配置的传感器)等等。</p>
<p class="calibre2">CARLA项目使用服务器-客户端架构管理UE4环境与外部配置和控制之间的接口，其中有两台服务器。</p>
<p class="calibre2">对于CARLA环境，我们可以使用<kbd class="calibre12">CarlaSettings</kbd>对象或<kbd class="calibre12">CarlaSettings.ini</kbd>文件配置环境的开始状态、目标状态、复杂程度和传感器源。</p>
<p class="calibre2">现在让我们创建一个<kbd class="calibre12">CarlaSettings</kbd>对象并配置一些设置，如下所示:</p>
<pre class="calibre17">settings = CarlaSettings()  # Initialize a CarlaSettings object with default values<br class="title-page-name"/>settings.set(<br class="title-page-name"/>            SynchronousMode=True,<br class="title-page-name"/>            SendNonPlayerAgentsInfo=True,  # To receive info about all other objs<br class="title-page-name"/>            NumberOfVehicles=self.scenario["num_vehicles"],<br class="title-page-name"/>            NumberOfPedestrians=self.scenario["num_pedestrians"],<br class="title-page-name"/>            WeatherId=self.weather)
SynchronousMode to <kbd class="calibre12">True</kbd> to enable the synchronous mode, in which the CARLA server halts the execution of each frame until a control message is received. Control messages are based on the actions the agent takes and are sent through the CARLA client.</pre>


            

            
        
    



  
    <title>Adding cameras and sensors to a vehicle in CARLA</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">在卡拉的一辆车上安装摄像头和传感器</h1>
                
            
            
                
<p class="calibre2">要在CARLA环境中添加RGB彩色摄像机，请使用以下代码:</p>
<pre class="calibre17"># Create a RGB Camera Object<br class="title-page-name"/>camera1 = Camera('CameraRGB')<br class="title-page-name"/># Set the RGB camera image resolution in pixels<br class="title-page-name"/>camera1.set_image_size(640, 480)<br class="title-page-name"/># Set the camera/sensor position relative to the car in meters<br class="title-page-name"/>camera1.set_positions(0.25, 0, 1.30)<br class="title-page-name"/># Add the sensor to the Carla Settings object<br class="title-page-name"/>settings.add_sensor(camera1)</pre>
<p class="calibre2">您还可以使用以下代码片段添加深度测量传感器或相机:</p>
<pre class="calibre17"># Create a depth camera object that can provide us the ground-truth depth of the driving scene<br class="title-page-name"/>camera2 = Camera("CameraDepth",PostProcessing="Depth")<br class="title-page-name"/># Set the depth camera image resolution in pixels<br class="title-page-name"/>camera2.set_image_size(640, 480)<br class="title-page-name"/># Set the camera/sensor position relative to the car in meters<br class="title-page-name"/>camera2.set_position(0.30, 0, 1.30)<br class="title-page-name"/># Add the sensor to the Carla settings object<br class="title-page-name"/>settings.add_sensor(camera)Setting up the start and end positions in the scene for the Carla Simulation</pre>
<p class="calibre2">要将<kbd class="calibre12">LIDAR</kbd>添加到CARLA环境中，请使用以下代码:</p>
<pre class="calibre17"># Create a LIDAR object. The default LIDAR supports 32 beams<br class="title-page-name"/>lidar = Lidar('Lidar32')<br class="title-page-name"/># Set the LIDAR sensor's specifications<br class="title-page-name"/>lidar.set(<br class="title-page-name"/>    Channels=32,  # Number of beams/channels<br class="title-page-name"/>    Range=50,     # Range of the sensor in meters<br class="title-page-name"/>    PointsPerSecond=1000000,  # Sample rate<br class="title-page-name"/>    RotationFrequency=10,  # Frequency of rotation<br class="title-page-name"/>    UpperFovLimit=10,  # Vertical field of view upper limit angle<br class="title-page-name"/>    LowerFovLimit=-30) # Vertical field of view lower limit angle<br class="title-page-name"/># Set the LIDAR position &amp; rotation relative to the car in meters<br class="title-page-name"/>lidar.set_position(0, 0, 2.5)<br class="title-page-name"/>lidar.set_rotation(0, 0, 0)<br class="title-page-name"/># Add the sensor to the Carla settings object<br class="title-page-name"/>settings.add_sensor(lidar)</pre>
<p class="calibre2">一旦我们根据所需的驾驶模拟配置创建了CARLA设置对象，我们就可以将它发送到CARLA服务器来设置环境并开始模拟。</p>
<p class="calibre2">一旦我们将CARLA设置对象发送到CARLA服务器，它就会响应一个包含ego车辆可用起始位置的场景描述对象，如下所示:</p>
<pre class="calibre17">scene = self.client.load_settings(settings)<br class="title-page-name"/>available_start_spots = scene.player_start_spots</pre>
<p class="calibre2">我们现在可以为宿主或自我车辆选择一个特定的开始位置，甚至可以随机选择一个开始点，如下面的代码片段所示:</p>
<pre class="calibre17">start_spot = random.randint(0, max(0, available_start_spots))</pre>
<p class="calibre2">我们还可以使用以下代码片段将此开始点首选项发送到服务器，并请求开始新的一集:</p>
<pre class="calibre17">self.client.start_episode(start_spot)</pre>
<p class="calibre2">注意，前一行是一个阻塞函数调用，它将阻塞动作，直到CARLA服务器真正开始播放这一集。</p>
<p class="calibre2">我们现在可以从这个起始位置开始一步一步地看完这一集。在下一节中，我们将看到实现CARLA环境的<kbd class="calibre12">step()</kbd>方法需要什么，该方法用于遍历环境直到一集结束:</p>
<pre class="calibre17">def _reset(self):<br class="title-page-name"/>        self.num_steps = 0<br class="title-page-name"/>        self.total_reward = 0<br class="title-page-name"/>        self.prev_measurement = None<br class="title-page-name"/>        self.prev_image = None<br class="title-page-name"/>        self.episode_id = datetime.today().strftime("%Y-%m-%d_%H-%M-%S_%f")<br class="title-page-name"/>        self.measurements_file = None<br class="title-page-name"/><br class="title-page-name"/>        # Create a CarlaSettings object. This object is a wrapper around<br class="title-page-name"/>        # the CarlaSettings.ini file. Here we set the configuration we<br class="title-page-name"/>        # want for the new episode.<br class="title-page-name"/>        settings = CarlaSettings()<br class="title-page-name"/>        # If config["scenarios"] is a single scenario, then use it if it's an array of scenarios, randomly choose one and init<br class="title-page-name"/>        self.config = update_scenarios_parameter(self.config)<br class="title-page-name"/><br class="title-page-name"/>        if isinstance(self.config["scenarios"],dict):<br class="title-page-name"/>            self.scenario = self.config["scenarios"]<br class="title-page-name"/>        else: #ininstance array of dict<br class="title-page-name"/>            self.scenario = random.choice(self.config["scenarios"])<br class="title-page-name"/>        assert self.scenario["city"] == self.city, (self.scenario, self.city)<br class="title-page-name"/>        self.weather = random.choice(self.scenario["weather_distribution"])<br class="title-page-name"/>        settings.set(<br class="title-page-name"/>            SynchronousMode=True,<br class="title-page-name"/>            SendNonPlayerAgentsInfo=True,<br class="title-page-name"/>            NumberOfVehicles=self.scenario["num_vehicles"],<br class="title-page-name"/>            NumberOfPedestrians=self.scenario["num_pedestrians"],<br class="title-page-name"/>            WeatherId=self.weather)<br class="title-page-name"/>        settings.randomize_seeds()<br class="title-page-name"/><br class="title-page-name"/>        if self.config["use_depth_camera"]:<br class="title-page-name"/>            camera1 = Camera("CameraDepth", PostProcessing="Depth")<br class="title-page-name"/>            camera1.set_image_size(<br class="title-page-name"/>                self.config["render_x_res"], self.config["render_y_res"])<br class="title-page-name"/>            camera1.set_position(30, 0, 130)<br class="title-page-name"/>            settings.add_sensor(camera1)<br class="title-page-name"/><br class="title-page-name"/>        camera2 = Camera("CameraRGB")<br class="title-page-name"/>        camera2.set_image_size(<br class="title-page-name"/>            self.config["render_x_res"], self.config["render_y_res"])<br class="title-page-name"/>        camera2.set_position(30, 0, 130)<br class="title-page-name"/>        settings.add_sensor(camera2)<br class="title-page-name"/><br class="title-page-name"/>        # Setup start and end positions<br class="title-page-name"/>        scene = self.client.load_settings(settings)<br class="title-page-name"/>        positions = scene.player_start_spots<br class="title-page-name"/>        self.start_pos = positions[self.scenario["start_pos_id"]]<br class="title-page-name"/>        self.end_pos = positions[self.scenario["end_pos_id"]]<br class="title-page-name"/>        self.start_coord = [<br class="title-page-name"/>            self.start_pos.location.x // 100, self.start_pos.location.y // 100]<br class="title-page-name"/>        self.end_coord = [<br class="title-page-name"/>            self.end_pos.location.x // 100, self.end_pos.location.y // 100]<br class="title-page-name"/>        print(<br class="title-page-name"/>            "Start pos {} ({}), end {} ({})".format(<br class="title-page-name"/>                self.scenario["start_pos_id"], self.start_coord,<br class="title-page-name"/>                self.scenario["end_pos_id"], self.end_coord))<br class="title-page-name"/><br class="title-page-name"/>        # Notify the server that we want to start the episode at the<br class="title-page-name"/>        # player_start index. This function blocks until the server is ready<br class="title-page-name"/>        # to start the episode.<br class="title-page-name"/>        print("Starting new episode...")<br class="title-page-name"/>        self.client.start_episode(self.scenario["start_pos_id"])<br class="title-page-name"/><br class="title-page-name"/>        image, py_measurements = self._read_observation()<br class="title-page-name"/>        self.prev_measurement = py_measurements<br class="title-page-name"/>        return self.encode_obs(self.preprocess_image(image), py_measurements)</pre>


            

            
        
    



  
    <title>Implementing the step function for the CARLA environment</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">为CARLA环境实现step函数</h1>
                
            
            
                
<p class="calibre2">一旦我们通过向CARLA服务器发送CARLA设置对象并调用<kbd class="calibre12">client.start_episode(start_spot)</kbd>来初始化CARLA模拟器，驾驶模拟将开始。然后，我们可以使用<kbd class="calibre12">client.read_data()</kbd>方法获取给定步骤中模拟产生的数据。我们可以使用下面一行代码来实现这一点:</p>
<pre class="calibre17">measurements, sensor_data = client.read_data()</pre>


            

            
        
    



  
    <title>Accessing camera or sensor data</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">访问摄像机或传感器数据</h1>
                
            
            
                
<p class="calibre2">我们可以使用返回的<kbd class="calibre12">sensor_data</kbd>对象的<kbd class="calibre12">data</kbd>属性在任何给定的时间步长检索传感器数据。要检索RGB相机帧，请输入以下代码:</p>
<pre class="calibre77">rgb_image = sensor_data['CameraRGB'].data</pre>
<p class="calibre2"><kbd class="calibre12">rgb_image</kbd>是一个NumPy n-d数组，您可以像通常访问和操作NumPy n-d数组一样访问和操作它。</p>
<p class="calibre2">例如，要在(<em class="calibre13"> x </em>，<em class="calibre13"> y </em>)图像平面坐标处访问RGB摄像机图像的像素值，您可以使用以下行:</p>
<pre class="calibre77">pixel_value_at_x_y = rgb_image[X, Y]</pre>
<p class="calibre2">要检索深度相机帧，请输入以下代码:</p>
<pre class="calibre77">depth_image = sensor_data['CameraDepth'].data</pre>


            

            
        
    



  
    <title>Sending actions to control agents in CARLA</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">向CARLA中的控制代理发送操作</h1>
                
            
            
                
<p class="calibre2">我们可以通过TCP客户端向CARLA服务器发送所需的转向、油门、刹车、手刹和倒车(档位)命令，从而在CARLA中控制汽车。下表显示了CARLA中的汽车将遵守的命令的值、范围和描述:</p>
<table border="1" class="calibre41">
<tbody class="calibre36">
<tr class="calibre37">
<td class="calibre48"><strong class="calibre1">命令/动作名称</strong></td>
<td class="calibre48"><strong class="calibre1">值类型，范围</strong></td>
<td class="calibre48"><strong class="calibre1">描述</strong></td>
</tr>
<tr class="calibre37">
<td class="calibre48">引导</td>
<td class="calibre48"><kbd class="calibre12">Float</kbd>，[-1.0，+1.0]</td>
<td class="calibre48">标准化转向角</td>
</tr>
<tr class="calibre37">
<td class="calibre48">喉咙</td>
<td class="calibre48"><kbd class="calibre12">Float</kbd>，【0.0，1.0】</td>
<td class="calibre48">标准化油门输入</td>
</tr>
<tr class="calibre37">
<td class="calibre48">刹车</td>
<td class="calibre48"><kbd class="calibre12">Float</kbd>，【0.0，1.0】</td>
<td class="calibre48">标准化制动输入</td>
</tr>
<tr class="calibre37">
<td class="calibre48">手制动器</td>
<td class="calibre48"><kbd class="calibre12">Boolean</kbd>，真/假</td>
<td class="calibre48">这告诉汽车是否接合手制动(<kbd class="calibre12">True</kbd>)或不接合(<kbd class="calibre12">False</kbd>)</td>
</tr>
<tr class="calibre37">
<td class="calibre48">反面的</td>
<td class="calibre48"><kbd class="calibre12">Boolean</kbd>，真/假</td>
<td class="calibre48">这告诉汽车是否处于倒档(<kbd class="calibre12">True</kbd>)或不处于倒档(<kbd class="calibre12">False</kbd>)</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">如CARLA文档中所述，实际转向角度将取决于车辆。例如，默认的野马车辆具有70度的最大转向角，如车辆的前轮UE4蓝图文件中所定义的。这是在卡拉控制汽车所需的五个不同的命令。在这五个命令中，其中三个(steer、throttle和brake)是实值浮点数。尽管它们的范围被限制在-1和+1或0和1之间，但是(唯一的)可能值的数量是巨大的。例如，如果我们对介于0和1之间的节流值使用单精度浮点表示，则有<img class="fm-editor-equation75" src="img/00151.jpeg"/>，这意味着该节流命令有1，056，964，608个不同的可能值。这同样适用于制动命令，因为它也位于0和1之间。转向命令的可能浮点值大约是两倍，因为它位于-1和+1之间。由于单个控制消息由五个命令中每个命令的一组值组成，因此不同动作(或控制消息)的数量是每个命令的唯一值的乘积，大致顺序如下:</p>
<div><img class="fm-editor-equation76" src="img/00152.jpeg"/></div>
<p class="calibre2">正如你所看到的，这产生了一个巨大的行动空间，对于深度学习代理来说，回归到这样一个巨大的行动空间可能是一个非常困难的问题。所以，让我们简化动作空间，用两种口味定义动作空间——一种用于连续空间，另一种用于离散空间，这对应用不同的强化学习算法很有用。例如，基于深度Q学习的算法(没有自然化优势函数)只能在离散动作空间上工作。</p>


            

            
        
    



  
    <title>Continuous action space in CARLA</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">卡拉的连续行动空间</h1>
                
            
            
                
<p class="calibre2">开车时，我们一般不会同时加速和刹车；因为CARLA中的动作空间是连续的，代理每走一步都会施加一个动作，所以加速和减速的命令一个可能就够了。现在让我们将油门和刹车指令合并为一个取值范围为-1到+1的指令，刹车指令取值范围为-1到0，油门或加速指令取值范围为0到1。我们可以使用以下命令来定义它:</p>
<pre class="calibre17">action_space = gym.space.Box(-1.0, 1.0, shape=2(,))</pre>
<p class="calibre2"><kbd class="calibre12">action[0]</kbd>表示转向命令，而<kbd class="calibre12">action[1]</kbd>表示油门和刹车命令的组合值。现在，我们将把<kbd class="calibre12">hand_brake</kbd>和<kbd class="calibre12">reverse</kbd>都设置为假。接下来，我们将看看如何定义一个离散的行动空间，以便我们为我们的代理选择我们想要的。</p>


            

            
        
    



  
    <title>Discrete action space in CARLA</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">卡拉的离散行动空间</h1>
                
            
            
                
<p class="calibre2">我们已经看到全动作空间相当大(按<img class="fm-editor-equation77" src="img/00153.jpeg"/>的顺序)。你可能玩过电子游戏，在那里你只用一个带四个箭头按钮的操纵杆或键盘上的箭头键来控制速度和方向(汽车指向的方向)来驾驶，那么为什么我们不能在这里要求代理以类似的方式控制汽车呢？这就是离散行动空间背后的想法。虽然我们无法对汽车进行精确控制，但我们可以确保离散化的空间在模拟环境中为我们提供良好的控制。</p>
<p class="calibre2">让我们首先使用我们在连续动作空间案例中使用的类似约定——其中我们使用一个浮点值来表示油门(加速)和刹车(减速)动作，从而在内部使用一个二维有界空间。这意味着在这种情况下，动作空间可以定义如下:</p>
<pre class="calibre17">action_space = gym.spaces.Discrete(NUM_DISCRETE_ACTIONS)</pre>
<p class="calibre2">正如您在这里看到的，<kbd class="calibre12">NUM_DISCRETE_ACTONS</kbd>等于可用的不同动作的数量，我们将在本节稍后定义。</p>
<p class="calibre2">然后，我们将使用二维有界空间离散化该空间，并将其作为离散动作空间暴露给代理。为了保持尽可能少的动作，同时仍然允许对汽车的控制，我们使用下面的动作列表:</p>
<table border="1" class="calibre41">
<tbody class="calibre36">
<tr class="calibre37">
<td class="calibre48"><strong class="calibre1">动作指数</strong></td>
<td class="calibre48"><strong class="calibre1">动作描述</strong></td>
<td class="calibre48"><strong class="calibre1">动作数组值</strong></td>
</tr>
<tr class="calibre37">
<td class="calibre48">0</td>
<td class="calibre48">海岸</td>
<td class="calibre48">[0.0, 0.0]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">一</td>
<td class="calibre48">向左转</td>
<td class="calibre48">[0.0, -0.5]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">2</td>
<td class="calibre48">向右转</td>
<td class="calibre48">[0.0, 0.5]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">3</td>
<td class="calibre48">向前</td>
<td class="calibre48">[1.0, 0.0]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">四</td>
<td class="calibre48">刹车</td>
<td class="calibre48">[-0.5, 0.0]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">5</td>
<td class="calibre48">左转加速</td>
<td class="calibre48">[1.0, -0.5]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">6</td>
<td class="calibre48">向右加速</td>
<td class="calibre48">[1.0, 0.5]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">七</td>
<td class="calibre48">左转减速</td>
<td class="calibre48">[-0.5, -0.5]</td>
</tr>
<tr class="calibre37">
<td class="calibre48">8</td>
<td class="calibre48">向右转并减速</td>
<td class="calibre48">[-0.5, 0.5]</td>
</tr>
</tbody>
</table>
<p class="calibre2"/>
<p class="calibre2">现在让我们在<kbd class="calibre12">carla_env</kbd>实现脚本的<kbd class="calibre12">DISCRETE_ACTIONS</kbd>字典中定义前面的一组离散动作，如下所示:</p>
<pre class="calibre17">DISCRETE_ACTIONS = {<br class="title-page-name"/>    0: [0.0, 0.0],    # Coast<br class="title-page-name"/>    1: [0.0, -0.5],   # Turn Left <br class="title-page-name"/>    2: [0.0, 0.5],    # Turn Right<br class="title-page-name"/>    3: [1.0, 0.0],    # Forward<br class="title-page-name"/>    4: [-0.5, 0.0],   # Brake<br class="title-page-name"/>    5: [1.0, -0.5],   # Bear Left &amp; accelerate<br class="title-page-name"/>    6: [1.0, 0.5],    # Bear Right &amp; accelerate<br class="title-page-name"/>    7: [-0.5, -0.5],  # Bear Left &amp; decelerate<br class="title-page-name"/>    8: [-0.5, 0.5],   # Bear Right &amp; decelerate<br class="title-page-name"/>}</pre>


            

            
        
    



  
    <title>Sending actions to the CARLA simulation server</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">向CARLA模拟服务器发送操作</h1>
                
            
            
                
<p class="calibre2">现在我们已经定义了CARLA Gym环境的动作空间，我们可以看看如何将我们定义的连续或离散动作转换为CARLA模拟服务器将接受的值。</p>
<p class="calibre2">由于我们在连续和离散动作空间中对二维有界动作值遵循了相同的约定，因此我们可以使用以下代码片段简单地将动作转换为转向、油门和制动命令:</p>
<pre class="calibre17">throttle = float(np.clip(action[0], 0, 1)<br class="title-page-name"/>brake = float(np.abs(np.cllip(action[0], -1, 0)<br class="title-page-name"/>steer = float(p.clip(action[1], -1, 1)<br class="title-page-name"/>hand_brake = False<br class="title-page-name"/>reverse = False</pre>
<p class="calibre2">如你所见，这里是<kbd class="calibre12">action[0]</kbd>代表油门和刹车，<kbd class="calibre12">action[1]</kbd>代表转向角度。</p>
<p class="calibre2">我们将利用CARLA <kbd class="calibre12">PythonClient</kbd>库中的<kbd class="calibre12">CarlaClient</kbd>类实现来处理与CARLA服务器的通信。如果您想了解如何使用协议缓冲区处理与服务器的通信，可以看看<kbd class="calibre12">ch7/carla-gym/carla_gym/envs/carla/client.py</kbd>中的<kbd class="calibre12">CarlaClient</kbd>类的实现。</p>
<p class="calibre2">要为CARLA环境实现奖励功能，请输入以下代码:</p>
<pre class="calibre17">def calculate_reward(self, current_measurement):<br class="title-page-name"/>        """<br class="title-page-name"/>        Calculate the reward based on the effect of the action taken using the previous and the current measurements<br class="title-page-name"/>        :param current_measurement: The measurement obtained from the Carla engine after executing the current action<br class="title-page-name"/>        :return: The scalar reward<br class="title-page-name"/>        """<br class="title-page-name"/>        reward = 0.0<br class="title-page-name"/><br class="title-page-name"/>        cur_dist = current_measurement["distance_to_goal"]<br class="title-page-name"/><br class="title-page-name"/>        prev_dist = self.prev_measurement["distance_to_goal"]<br class="title-page-name"/><br class="title-page-name"/>        if env.config["verbose"]:<br class="title-page-name"/>            print("Cur dist {}, prev dist {}".format(cur_dist, prev_dist))<br class="title-page-name"/><br class="title-page-name"/>        # Distance travelled toward the goal in m<br class="title-page-name"/>        reward += np.clip(prev_dist - cur_dist, -10.0, 10.0)<br class="title-page-name"/><br class="title-page-name"/>        # Change in speed (km/hr)<br class="title-page-name"/>        reward += 0.05 * (current_measurement["forward_speed"] - self.prev_measurement["forward_speed"])<br class="title-page-name"/><br class="title-page-name"/>        # New collision damage<br class="title-page-name"/>        reward -= .00002 * (<br class="title-page-name"/>            current_measurement["collision_vehicles"] + current_measurement["collision_pedestrians"] +<br class="title-page-name"/>            current_measurement["collision_other"] - self.prev_measurement["collision_vehicles"] -<br class="title-page-name"/>            self.prev_measurement["collision_pedestrians"] - self.prev_measurement["collision_other"])<br class="title-page-name"/><br class="title-page-name"/>        # New sidewalk intersection<br class="title-page-name"/>        reward -= 2 * (<br class="title-page-name"/>            current_measurement["intersection_offroad"] - self.prev_measurement["intersection_offroad"])<br class="title-page-name"/><br class="title-page-name"/>        # New opposite lane intersection<br class="title-page-name"/>        reward -= 2 * (<br class="title-page-name"/>            current_measurement["intersection_otherlane"] - self.prev_measurement["intersection_otherlane"])<br class="title-page-name"/><br class="title-page-name"/>        return reward</pre>


            

            
        
    



  
    <title>Determining the end of episodes in the CARLA environment</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">在卡拉环境中确定剧集的结尾</h1>
                
            
            
                
<p class="calibre2">我们已经实现了<kbd class="calibre12">meta hod</kbd>来计算奖励，并为定制的CARLA环境定义了允许的操作、观察和重置方法。根据我们的定制健身房环境创建模板，这些是我们需要实现的必需方法，用于创建与OpenAI健身房接口兼容的定制环境。</p>
<p class="calibre2">虽然这是真的，但我们还需要注意一件事，以便代理可以不断地与我们的环境进行交互。还记得我们在<a href="part0078.html#2ACBS0-22c7fc7f93b64d07be225c00ead6ce12" class="calibre9">第五章</a>、<em class="calibre13">开发我们的Q-learning agent的时候，实现你的第一个学习Agent——解决山地车问题</em>吗，对于山地车环境，200步后总会自行复位的环境？或者在车杆环境中，如果杆降到某个阈值以下，环境会自动重置？或者在Atari游戏中，如果一个代理失去了他们最后的生命，环境会自动重置？是的，我们需要查看确定何时重置环境的例程，这在我们的定制CARLA Gym环境实现中是缺失的。</p>
<p class="calibre2">虽然我们可以选择任何标准来重新设置卡拉健身房环境，但有三点需要考虑，如下所示:</p>
<ul class="calibre10">
<li class="calibre11">当代理控制的宿主或自我汽车与汽车、行人、建筑物或其他路边物体发生碰撞时，这可能是致命的(类似于在Atari游戏中丧生)</li>
<li class="calibre11">当宿主或自我车到达其目的地或最终目标时</li>
<li class="calibre11">当超过时间限制时(类似于我们在山地汽车健身房环境中的200时间步长限制)</li>
</ul>
<p class="calibre2">我们可以使用这些条件来形成决定一集结束的标准。确定<kbd class="calibre12">.step(...)</kbd>将返回的<kbd class="calibre12">done</kbd>变量的值的伪代码如下(注意，完整的代码可以在本书的<kbd class="calibre12">ch7/carla-gym/carla_gym/envs/</kbd>代码库中找到):</p>
<pre class="calibre17"># 1. Check if a collision has occured<br class="title-page-name"/>m = measurements_from_carla_server<br class="title-page-name"/>collided = m["collision_vehicles"] &gt; 0 or m["collision_pedestrians"] &gt; 0 or m["collision_other"] &gt; 0<br class="title-page-name"/><br class="title-page-name"/># 2. Check if the ego/host car has reached the destination/goal<br class="title-page-name"/>planner = carla_planner<br class="title-page-name"/>goal_reached = planner["next_command"] == "REACHED_GOAL"<br class="title-page-name"/><br class="title-page-name"/># 3. Check if the time-limit has been exceeded<br class="title-page-name"/>time_limit = scenario_max_steps_config<br class="title-page-name"/>time_limit_exceeded = num_steps &gt; time_limit<br class="title-page-name"/><br class="title-page-name"/># Set "done" to True if either of the above 3 criteria becomes true<br class="title-page-name"/>done = collided or goal_reached or time_limit_exceeded</pre>
<p class="calibre2">现在，我们已经完成了创建基于CARLA驾驶模拟器的自定义健身房兼容环境所需的所有组件！在下一节中，我们将测试环境并最终看到它的运行。</p>


            

            
        
    



  
    <title>Testing the CARLA Gym environment</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">测试卡拉健身房环境</h1>
                
            
            
                
<p class="calibre2">为了使测试我们的环境实现的基础变得容易，我们将实现一个简单的<kbd class="calibre12">main()</kbd>例程，这样我们就可以将环境作为脚本运行。这将向我们显示基本接口是否设置正确，以及环境实际上是什么样子！</p>
<pre>CarlaEnv and runs five episodes with a fixed action of going forward. The <kbd class="calibre12">ENV_CONFIG</kbd> action, which we created during initialization, can be changed to use discrete or continuous action spaces, as follows:</pre>
<pre class="calibre17"># Part of <a href="https://github.com/PacktPublishing/Hands-On-Intelligent-Agents-with-OpenAI-Gym/tree/master/ch6" class="calibre80">https://github.com/PacktPublishing/Hands-On-Intelligent-Agents-with-OpenAI-Gym/ch7/carla-gym/carla_gym/envs/carla_env.py</a><br class="title-page-name"/>if __name__ == "__main__":<br class="title-page-name"/>    for _ in range(5):<br class="title-page-name"/>        env = CarlaEnv()<br class="title-page-name"/>        obs = env.reset()<br class="title-page-name"/>        done = False<br class="title-page-name"/>        t = 0<br class="title-page-name"/>        total_reward = 0.0<br class="title-page-name"/>        while not done:<br class="title-page-name"/>            t += 1<br class="title-page-name"/>            if ENV_CONFIG["discrete_actions"]:<br class="title-page-name"/>                obs, reward, done, info = env.step(3) # Go Forward<br class="title-page-name"/>            else:<br class="title-page-name"/>                obs, reward, done, info = env.step([1.0, 0.0]) # Full throttle, zero steering angle<br class="title-page-name"/>            total_reward += reward<br class="title-page-name"/>            print("step#:", t, "reward:", round(reward, 4), "total_reward:", round(total_reward, 4), "done:", done)</pre>
<p class="calibre2">现在，继续测试我们刚刚创建的环境！请记住，卡拉需要一个GPU来顺利运行，系统环境<kbd class="calibre12">CARLA_SERVER</kbd>变量被定义并指向系统上的<kbd class="calibre12">CarlaUE4.sh</kbd>文件。准备好之后，您可以通过在<kbd class="calibre12">rl_gym_book</kbd> conda环境中运行以下命令来测试我们创建的环境:</p>
<pre class="calibre17"><strong class="calibre1">(rl_gym_book) praveen@ubuntu:~/rl_gym_book/ch7$ python carla-gym/carla_gym/envs/carla_env.py</strong></pre>
<p class="calibre2">前面的命令应打开一个小的CARLA模拟器窗口，并为<kbd class="calibre12">carla_env.py</kbd>脚本中使用的场景配置初始化车辆。这应该类似于下面的屏幕截图:</p>
<div><img src="img/00154.jpeg" class="calibre81"/>  <img src="img/00155.jpeg" class="calibre82"/></div>
<p class="calibre2">如你所见，默认情况下，车辆被设定为直线行驶。注意，<kbd class="calibre12">carla_env.py</kbd>脚本还会产生一个控制台输出，显示环境中的当前时间步长、计算出的瞬时奖励、剧集中的总奖励以及<kbd class="calibre12">done</kbd>的值(对或错)，这些对于测试我们的环境都很有用。随着车辆开始向前移动，您应该会看到奖励值增加！</p>
<p class="calibre2">控制台输出如下:</p>
<p class="cdpaligncenter4"><img src="img/00156.jpeg" class="calibre83"/></p>
<p class="calibre2">所以，你现在有你的自定义卡拉健身房环境工作！您可以使用<kbd class="calibre12">ch7/carla-gym/carla_gym/envs/scenarios.json</kbd>文件中的定义创建几种不同的驾驶场景。然后，您可以为这些场景中的每一个创建新的定制CARLA环境，在您注册了定制环境之后，您可以使用常规的<kbd class="calibre12">gym.make(...)</kbd>命令，例如<kbd class="calibre12">gym.make("Carla-v0")</kbd>。</p>
<p class="calibre2">书中代码库中的代码使用我们在本章前面讨论过的方法来处理OpenAI Gym注册中心的环境注册。您现在可以使用OpenAI Gym来创建我们构建的定制环境的实例。</p>
<p class="calibre2">以下屏幕截图显示了可用于测试自定义健身房环境的Python命令:</p>
<p class="cdpaligncenter4"><img src="img/00157.jpeg" class="calibre84"/></p>
<p class="calibre2">就是这样！剩下的和其他健身房环境差不多。</p>


            

            
        
    



  
    <title>Summary</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  


  
        

                            
                    <h1 class="header-title" id="calibre_pb_0">摘要</h1>
                
            
            
                
<p class="calibre2">在本章中，我们一步一步地介绍了自定义健身房环境的实现，从一个模板开始，该模板展示了OpenAI健身房环境的基本结构，为代理提供了所有必要的接口。我们还研究了如何在Gym注册表中注册一个定制环境实现，这样我们就可以使用熟悉的<kbd class="calibre12">gym.make(ENV_NAME)</kbd>命令来创建一个现有环境的实例。然后，我们看了如何为基于开源驾驶模拟器CARLA的非远程引擎创建一个健身房兼容的环境实现。然后，我们快速浏览了安装和运行CARLA所需的步骤，然后开始一部分一部分地实现<kbd class="calibre12">CarlaEnv</kbd>类，仔细地涵盖了实现与OpenAI Gym兼容的定制环境所涉及的所有重要细节。</p>
<p class="calibre2">在下一章中，我们将通过实际操作的例子从头开始构建一个高级智能体，然后最终使用我们在本章中创建的自定义CARLA环境来训练一个智能智能体，它可以学会自己驾驶汽车！</p>


            

            
        
    
</body></html>