<html><head/><body>


	
		<title>B15385_Solution_Final_RK_ePub</title>
		
	
	
		<div><h1 id="_idParaDest-234"><a id="_idTextAnchor261"/>附录</h1>
		</div>
		<div><h1 id="_idParaDest-235"><a id="_idTextAnchor262"/> 1。深度学习的构建模块</h1>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor263"/>活动1.01:使用优化器求解二次方程</h2>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor264"/>解决方案</h2>
			<p>让我们解下面的二次方程:</p>
			<div><div><img src="img/B15385_01_29.jpg" alt="Figure 1.29: Quadratic equation to be solved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.29:待求解的二次方程</p>
			<p>我们已经知道这个二次方程的解是<code>x=5</code>。</p>
			<p>我们可以使用优化器来解决这个问题。对于优化器，<code>x</code>是变量，成本函数是左侧表达式，如下所示:</p>
			<div><div><img src="img/B15385_01_30.jpg" alt="Figure 1.30: Left-hand side expression&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.30:左侧表达式</p>
			<p>优化器将找到表达式最小的<code>x</code>的值——在本例中，它是<code>0</code>。请注意，这只适用于完全平方的二次方程，比如本例。左边的表达式是一个完美的正方形，可以用下面的等式来解释:</p>
			<div><div><img src="img/B15385_01_31.jpg" alt="Figure 1.31: Perfect square&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图1.31:完美的正方形</p>
			<p>现在，让我们看看解决这个问题的代码:</p>
			<ol>
				<li>打开一个新的Jupyter笔记本，将其重命名为<em class="italic"> Activity 1.01 </em>。</li>
				<li>进口<code>tensorflow</code> : <pre>import tensorflow as tf</pre></li>
				<li>创建变量<code>x</code>并将其初始化为0.0: <pre>x=tf.Variable(0.0)</pre></li>
				<li>将<code>loss</code>函数构造为<code>lambda</code>函数:<pre>loss=lambda:abs(x**2-10*x+25)</pre></li>
				<li>创建一个学习率为<code>.01</code> : <pre>optimizer=tf.optimizers.Adam(.01)</pre>的优化器实例</li>
				<li>运行优化器10，000次迭代。您可以从一个较小的数字开始，比如1000，并不断增加迭代次数，直到您得到解决方案:<pre>for i in range(10000):     optimizer.minimize(loss,x)</pre></li>
				<li>Print the value of <code>x</code>:<pre>tf.print(x)</pre><p>输出如下所示:</p><pre>4.99919891</pre></li>
			</ol>
			<p>这是我们的二次方程的解。值得注意的是，不管迭代多少次，你都不会得到一个完美的5。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考https://packt.live/3gBTFGA的<a href="https://packt.live/3gBTFGA"/>。</p>
			<p class="callout">你也可以在https://packt.live/2Dqa2Id在线运行这个例子。您必须执行整个笔记本才能获得想要的结果。</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor265"/> 2。神经网络</h1>
			<h2 id="_idParaDest-239">活动2.01:建立一个多层神经网络来对声纳信号进行分类</h2>
			<h2 id="_idParaDest-240">解决方案<a id="_idTextAnchor267"/></h2>
			<p>让我们看看解决方案是什么样的。请记住，这是一种解决方案，但可能有多种变化:</p>
			<ol>
				<li value="1">导入所有需要的库:<pre>import tensorflow as tf import pandas as pd from sklearn.preprocessing import LabelEncoder # Import Keras libraries from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense</pre></li>
				<li>Load and examine the data:<pre>df = pd.read_csv('sonar.csv')
df.head()</pre><p>输出是:</p><div><img src="img/B15385_02_37.jpg" alt="Figure 2.37: Contents of sonar.csv&#13;&#10;"/></div><p class="figure-caption">图2.37:sonar . CSV的内容</p><p>观察有60个特征，目标有两个值—岩石和矿井。</p><p>这意味着这是一个二元分类问题。在建立神经网络之前，我们先准备好数据。</p></li>
				<li>Separate the features and the labels:<pre>X_input = df.iloc[:, :-1]
Y_label = df['Class'].values</pre><p>在这段代码中，<code>X_input</code>是选择除了<code>Class</code>列之外的所有列，<code>Y_label</code>只是选择了<code>Class</code>列。</p></li>
				<li>Labels are in text format. We need to encode them as numbers before we can use them with our model:<pre>labelencoder_Y = LabelEncoder() 
Y_label = labelencoder_Y.fit_transform(Y_label)
Y_label = Y_label.reshape([208, 1])</pre><p>最后的<code>reshape</code>函数会将标签转换成矩阵格式，这是模型所期望的。</p></li>
				<li>Build the multilayer model with Keras:<pre>model = Sequential()
model.add(Dense(300,input_dim=60, activation = 'relu'))
model.add(Dense(200, activation = 'relu'))
model.add(Dense(100, activation = 'relu'))
model.add(Dense(1, activation = 'sigmoid'))</pre><p>您可以试验层和神经元的数量，但最后一层只能有一个具有sigmoid激活函数的神经元，因为这是一个二元分类器。</p></li>
				<li>设置训练参数:<pre>model.compile(optimizer='adam',loss='binary_crossentropy', \               metrics=['accuracy'])</pre></li>
				<li>Train the model:<pre>model.fit(X_input, Y_label, epochs=30)</pre><p>截断的输出将类似于以下内容:</p><pre>Train on 208 samples
Epoch 1/30
208/208 [==============================] - 0s 205us/sample - 
loss: 
  0.1849 - accuracy: 0.9038
Epoch 2/30
208/208 [==============================] - 0s 220us/sample – 
loss: 
  0.1299 - accuracy: 0.9615
Epoch 3/30
208/208 [==============================] - 0s 131us/sample – 
loss: 
  0.0947 - accuracy: 0.9856
Epoch 4/30
208/208 [==============================] - 0s 151us/sample – 
loss: 
  0.1046 - accuracy: 0.9712
Epoch 5/30
208/208 [==============================] - 0s 171us/sample – 
loss: 
  0.0952 - accuracy: 0.9663
Epoch 6/30
208/208 [==============================] - 0s 134us/sample – 
loss: 
  0.0777 - accuracy: 0.9856
Epoch 7/30
208/208 [==============================] - 0s 129us/sample – 
loss: 
  0.1043 - accuracy: 0.9663
Epoch 8/30
208/208 [==============================] - 0s 142us/sample – 
loss: 
  0.0842 - accuracy: 0.9712
Epoch 9/30
208/208 [==============================] - 0s 155us/sample – 
loss: 
  0.1209 - accuracy: 0.9423
Epoch 10/30
208/208 [==============================] - ETA: 0s - loss: 
  0.0540 - accuracy: 0.98 - 0s 334us/sample - los</pre></li>
				<li>Let's evaluate the trained model and examine its accuracy:<pre>model.evaluate(X_input, Y_label)</pre><p>输出如下所示:</p><pre>208/208 [==============================] - 0s 128us/sample – 
loss: 
  0.0038 - accuracy: 1.0000
 [0.003758653004367191, 1.0]</pre><p>正如你所看到的，我们已经能够成功地训练一个多层二进制神经网络，并在30个时期内获得100%的准确性。</p><p class="callout-heading">注意</p><p class="callout">要访问该特定部分的源代码，请参考<a href="https://packt.live/38EMoDi">https://packt.live/38EMoDi</a>。</p><p class="callout">你也可以在<a href="https://packt.live/2W2sygb">https://packt.live/2W2sygb</a>在线运行这个例子。您必须执行整个笔记本才能获得想要的结果。</p></li>
			</ol>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor268"/> 3。基于卷积神经网络的图像分类</h1>
			<h2 id="_idParaDest-242">活动3.01:基于时尚MNIST数据集构建一个M <a id="_idTextAnchor269"/>多类分类器</h2>
			<h2 id="_idParaDest-243">解决方案<a id="_idTextAnchor270"/></h2>
			<ol>
				<li value="1">打开新的Jupyter笔记本。</li>
				<li>导入<code>tensorflow.keras.datasets.fashion_mnist</code> : <pre>from tensorflow.keras.datasets import fashion_mnist</pre></li>
				<li>使用<code>fashion_mnist.load_data()</code>加载时尚MNIST数据集，并将结果保存到<code>(features_train, label_train), (features_test, label_test)</code> : <pre>(features_train, label_train), (features_test, label_test) = \ fashion_mnist.load_data()</pre></li>
				<li>Print the shape of the training set:<pre>features_train.shape</pre><p>输出如下所示:</p><pre>(60000, 28, 28)</pre><p>训练集由尺寸为<code>28</code>乘<code>28</code>的<code>60000</code>幅图像组成。我们需要重塑它，增加渠道维度。</p></li>
				<li>Print the shape of the testing set:<pre>features_test.shape</pre><p>输出如下所示:</p><pre>(10000, 28, 28)</pre><p>测试集由尺寸为<code>28</code>乘<code>28</code>的<code>10000</code>幅图像组成。我们需要重塑它，并增加渠道维度</p></li>
				<li>用尺寸<code>(number_rows, 28, 28, 1)</code> : <pre>features_train = features_train.reshape(60000, 28, 28, 1) features_test = features_test.reshape(10000, 28, 28, 1)</pre>重塑训练集和测试集</li>
				<li>创建三个名为<code>batch_size</code>、<code>img_height</code>和<code>img_width</code>的变量，分别取值为<code>16</code>、<code>28</code>和<code>28</code>:<pre>batch_size = 16 img_height = 28 img_width = 28</pre></li>
				<li>从<code>tensorflow.keras.preprocessing</code>导入<code>ImageDataGenerator</code>:<pre>from tensorflow.keras.preprocessing.image \ import ImageDataGenerator</pre></li>
				<li>创建一个名为<code>train_img_gen</code>的<code>ImageDataGenerator</code>，并增加数据:<code>rescale=1./255, rotation_range=40, width_shift_range=0.1, height_shift_range=0.1, shear_range=0.2, zoom_range=0.2, horizontal_flip=True, fill_mode='nearest'</code> : <pre>train_img_gen = ImageDataGenerator(rescale=1./255, \                                    rotation_range=40, \                                    width_shift_range=0.1, \                                    height_shift_range=0.1, \                                    shear_range=0.2, \                                    zoom_range=0.2, \                                    horizontal_flip=True, \                                    fill_mode='nearest')</pre></li>
				<li>创建一个名为<code>val_img_gen</code>的<code>ImageDataGenerator</code>，并重新缩放(除以255): <pre>val_img_gen = ImageDataGenerator(rescale=1./255)</pre></li>
				<li>使用<code>.flow()</code>创建一个名为<code>train_data_gen</code>的数据生成器，并从训练集中指定批量大小、特性和标签:<pre>train_data_gen = train_img_gen.flow(features_train, \                                     label_train, \                                     batch_size=batch_size)</pre></li>
				<li>使用<code>.flow()</code>创建一个名为<code>val_data_gen</code>的数据生成器，并从测试集中指定批量大小、特性和标签:<pre>val_data_gen = train_img_gen.flow(features_test, \                                   label_test, \                                   batch_size=batch_size)</pre></li>
				<li>将<code>numpy</code>导入为<code>np</code>，将<code>tensorflow</code>导入为<code>tf</code>，将<code>layers</code>从<code>tensorflow.keras</code> : <pre>import numpy as np import tensorflow as tf from tensorflow.keras import layers</pre>导入</li>
				<li>使用<code>np.random_seed()</code>和<code>tf.random.set_seed()</code> : <pre>np.random.seed(8) tf.random.set_seed(8)</pre>将<code>8</code>设置为<code>numpy</code>和<code>tensorflow</code>的种子</li>
				<li>Instantiate a <code>tf.keras.Sequential()</code> class into a variable called <code>model</code> with the following layers: A convolution layer with <code>64</code> kernels of shape <code>3</code>, <code>ReLU</code> as the activation function, and the necessary input dimensions; a max pooling layer; a convolution layer with <code>128</code> kernels of shape <code>3</code> and <code>ReLU</code> as the activation function; a max pooling layer; a flatten layer; a fully connected layer with <code>128</code> units and <code>ReLU</code> as the activation function; a fully connected layer with <code>10</code> units and <code>softmax</code> as the activation function.<p>代码应该如下所示:</p><pre>model = tf.keras.Sequential\
        ([layers.Conv2D(64, 3, activation='relu', \
                        input_shape=(img_height, \
                                     img_width ,1)), \
                        layers.MaxPooling2D(), \
                        layers.Conv2D(128, 3, \
                                      activation='relu'), \
                        layers.MaxPooling2D(),\
                        layers.Flatten(), \
                        layers.Dense(128, \
                                     activation='relu'), \
                        layers.Dense(10, \
                                     activation='softmax')])</pre></li>
				<li>用<code>0.001</code>作为学习率实例化一个<code>tf.keras.optimizers.Adam()</code>类，并将其保存到一个名为<pre>optimizer = tf.keras.optimizers.Adam(0.001)</pre>的变量中</li>
				<li>使用<code>.compile()</code>和<code>loss='sparse_categorical_crossentropy', optimizer=optimizer, metrics=['accuracy']</code> : <pre>model.compile(loss='sparse_categorical_crossentropy', \               optimizer=optimizer, metrics=['accuracy'])</pre>编译神经网络</li>
				<li>Fit the neural networks with <code>fit_generator()</code> and provide the train and validation data generators, <code>epochs=5</code>, the steps per epoch, and the validation steps:<pre>model.fit_generator(train_data_gen, \
                    steps_per_epoch=len(features_train) \
                                    // batch_size, \
                    epochs=5, \
                    validation_data=val_data_gen, \
                    validation_steps=len(features_test) \
                                     // batch_size)</pre><p>预期产出如下:</p><div><img src="img/B15385_03_30.jpg" alt="Figure 3.30: Model training log&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图3.30:模型训练日志</p>
			<p>我们在五个时期上训练我们的CNN，并且我们分别在训练集和验证集上获得了<code>0.8271</code>和<code>0.8334</code>的准确度分数。我们的模型没有过度拟合，并取得了相当高的分数。五个历元之后，准确度仍在增加，所以如果我们继续训练它，我们可能会得到更好的结果。这是你可以自己尝试的。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考<a href="https://packt.live/2ObmA8t">https://packt.live/2ObmA8t</a>。</p>
			<p class="callout">你也可以在<a href="https://packt.live/3fiyyJi">https://packt.live/3fiyyJi</a>在线运行这个例子。您必须执行整个笔记本才能获得想要的结果。</p>
			<h2 id="_idParaDest-244">活动3.02:利用迁移学习进行水果分类</h2>
			<h2 id="_idParaDest-245">解决方案<a id="_idTextAnchor272"/></h2>
			<ol>
				<li value="1">打开新的Jupyter笔记本。</li>
				<li>将<code>tensorflow</code>导入为<code>tf</code> : <pre>import tensorflow as tf</pre></li>
				<li>Create a variable called <code>file_url</code> containing the link to the dataset:<pre>file_url = 'https://github.com/PacktWorkshops'\
           '/The-Deep-Learning-Workshop'\
           '/raw/master/Chapter03/Datasets/Activity3.02'\
           '/fruits360.zip'</pre><p class="callout-heading">注意</p><p class="callout">在上述步骤中，我们使用存储在<a href="https://packt.live/3eePQ8G">https://packt.live/3eePQ8G</a>的数据集。如果您已经在任何其他URL存储了数据集，请相应地更改突出显示的路径。</p></li>
				<li>使用带有<code>'fruits360.zip', origin=file_url, extract=True</code>的<code>tf.keras.get_file</code>下载数据集，并将结果保存到名为<code>zip_dir</code> : <pre>zip_dir = tf.keras.utils.get_file('fruits360.zip', \                                   origin=file_url, \                                   extract=True)</pre>的变量中</li>
				<li>导入<code>pathlib</code>库:<pre>import pathlib</pre></li>
				<li>使用<code>pathlib.Path(zip_dir).parent</code> : <pre>path = pathlib.Path(zip_dir).parent / 'fruits360_filtered'</pre>创建一个名为<code>path</code>的变量，包含到<code>fruits360_filtered</code>目录的完整路径</li>
				<li>创建两个名为<code>train_dir</code>和<code>validation_dir</code>的变量，它们分别获取火车(<code>Training</code>)和验证(<code>Test</code>)文件夹的完整路径:<pre>train_dir = path / 'Training' validation_dir = path / 'Test'</pre></li>
				<li>创建两个名为<code>total_train</code>和<code>total_val</code>的变量，它们将获得训练集和验证集的图像数量，即<code>11398</code>和<code>4752</code> : <pre>total_train = 11398 total_val = 4752</pre></li>
				<li>从<code>tensorflow.keras.preprocessing</code>导入<code>ImageDataGenerator</code>:<pre>from tensorflow.keras.preprocessing.image \ import ImageDataGenerator</pre></li>
				<li>创建一个名为<code>train_img_gen</code>的<code>ImageDataGenerator</code>并增加数据:<code>rescale=1./255, rotation_range=40, width_shift_range=0.1, height_shift_range=0.1, shear_range=0.2, zoom_range=0.2, horizontal_flip=True, fill_mode='nearest'</code> : <pre>train_img_gen = ImageDataGenerator(rescale=1./255, \                                    rotation_range=40, \                                    width_shift_range=0.1, \                                    height_shift_range=0.1, \                                    shear_range=0.2, \                                    zoom_range=0.2, \                                    horizontal_flip=True, \                                    fill_mode='nearest')</pre></li>
				<li>创建一个名为<code>val_img_gen</code>的<code>ImageDataGenerator</code>，并进行重新调整(除以255): <pre>val_img_gen = ImageDataGenerator(rescale=1./255)</pre></li>
				<li>创建四个名为<code>batch_size</code>、<code>img_height</code>、<code>img_width</code>和<code>channel</code>的变量，分别取值为<code>16</code>、<code>100</code>、<code>100</code>和<code>3</code>:<pre>batch_size=16 img_height = 100 img_width = 100 channel = 3</pre></li>
				<li>使用<code>.flow_from_directory()</code>创建一个名为<code>train_data_gen</code>的数据生成器，并指定批量大小、培训文件夹和目标大小:<pre>train_data_gen = train_image_generator.flow_from_directory\                  (batch_size=batch_size, \                  directory=train_dir, \                  target_size=(img_height, img_width))</pre></li>
				<li>使用<code>.flow_from_directory()</code>创建一个名为<code>val_data_gen</code>的数据生成器，并指定批量大小、验证文件夹和目标大小:<pre>val_data_gen = validation_image_generator.flow_from_directory\                (batch_size=batch_size, \                directory=validation_dir, \                target_size=(img_height, img_width))</pre></li>
				<li>导入<code>numpy</code>为<code>np</code>，<code>tensorflow</code>为<code>tf</code>，从<code>tensorflow.keras</code> : <pre>import numpy as np import tensorflow as tf from tensorflow.keras import layers</pre>导入<code>layers</code></li>
				<li>使用<code>np.random_seed()</code>和<code>tf.random.set_seed()</code> : <pre>np.random.seed(8) tf.random.set_seed(8)</pre>将<code>8</code>设置为<code>numpy</code>和<code>tensorflow</code>的种子</li>
				<li>从<code>tensorflow.keras.applications</code>导入<code>VGG16</code>:<pre>from tensorflow.keras.applications import VGG16</pre></li>
				<li>用以下参数将一个<code>VGG16</code>模型实例化为一个名为<code>base_model</code>的变量:<pre>base_model = VGG16(input_shape=(img_height, \                                 img_width, channel), \                                 weights='imagenet', \                                 include_top=False)</pre></li>
				<li>使用<code>.trainable</code>属性:<pre>base_model.trainable = False</pre>将该模型设置为不可训练</li>
				<li>Print the summary of this <code>VGG16</code> model:<pre>base_model.summary()</pre><p>预期产出如下:</p><div><img src="img/B15385_03_31.jpg" alt="Figure 3.31: Model summary&#13;&#10;"/></div><p class="figure-caption">图3.31:模型摘要</p><p>这个输出向我们展示了<code>VGG16</code>的架构。我们可以看到总共有<code>14,714,688</code>个参数，但是没有可训练的参数。这是意料之中的，因为我们已经冻结了这个模型的所有层。</p></li>
				<li>使用<code>tf.keras.Sequential()</code>创建一个新模型，将基础模型添加到以下层:<code>Flatten()</code>、<code>Dense(1000, activation='relu')</code>和<code>Dense(120, activation='softmax')</code>。将这个模型保存到一个名为<code>model</code> : <pre>model = tf.keras.Sequential([base_model, \                              layers.Flatten(), \                              layers.Dense(1000, \                                           activation='relu'), \                              layers.Dense(120, \                                           activation='softmax')])</pre>的变量中</li>
				<li>用<code>0.001</code>作为学习率实例化一个<code>tf.keras.optimizers.Adam()</code>类，并保存到一个名为<code>optimizer</code> : <pre>optimizer = tf.keras.optimizers.Adam(0.001)</pre>的变量中</li>
				<li>使用<code>.compile()</code>和<code>loss='categorical_crossentropy', optimizer=optimizer, metrics=['accuracy']</code> : <pre>model.compile(loss='categorical_crossentropy', \               optimizer=optimizer, metrics=['accuracy'])</pre>编译神经网络</li>
				<li>Fit the neural networks with <code>fit_generator()</code> and provide the train and validation data generators, <code>epochs=5</code>, the steps per epoch, and the validation steps. This model may take a few minutes to train:<pre>model.fit_generator(train_data_gen, \
                    steps_per_epoch=len(features_train) \
                                    // batch_size, \
                    epochs=5, \
                    validation_data=val_data_gen, \
                    validation_steps=len(features_test) \
                                     // batch_size)</pre><p>预期产出如下:</p><div><img src="img/B15385_03_32.jpg" alt="Figure 3.32: Expected output&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图3.32:预期产出</p>
			<p>在这里，我们使用迁移学习在ImageNet上定制一个预训练的<code>VGG16</code>模型，以便它适合我们的水果分类数据集。我们用我们自己的完全连接的层替换了模型的头部，并在五个时期训练这些层。我们在训练集和测试集上分别获得了<code>0.9106</code>和<code>0.8920</code>的准确率。考虑到训练这个模型所用的时间和硬件，这些是非常显著的结果。你可以尝试微调这个模型，看看你是否能取得更好的成绩。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考<a href="https://packt.live/2DsVRCl">https://packt.live/2DsVRCl</a>。</p>
			<p class="callout">本节目前没有在线交互示例，需要在本地运行。</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor273"/> 4。文本嵌入的深度学习</h1>
			<h2 id="_idParaDest-247">活动4.01:文本<a id="_idTextAnchor274"/>预处理“爱丽丝梦游仙境”文本</h2>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor275"/>解决方案</h2>
			<p>您需要执行以下步骤:</p>
			<p class="callout-heading">注意</p>
			<p class="callout">在开始本活动之前，确保您已经定义了<code>alice_raw</code>变量，如标题为<em class="italic">使用NLTK </em>下载文本语料库一节中所示。</p>
			<ol>
				<li value="1">把数据改成小写，分成句子:<pre>txt_sents = tokenize.sent_tokenize(alice_raw.lower())</pre></li>
				<li>给句子做记号:<pre>txt_words = [tokenize.word_tokenize(sent) for sent in txt_sents]</pre></li>
				<li>从<code>string</code>模块导入<code>punctuation</code>，从NLTK: <pre>from string import punctuation stop_punct = list(punctuation) from nltk.corpus import stopwords stop_nltk = stopwords.words("english")</pre>导入<code>stopwords</code></li>
				<li>创建一个保存上下文停用词<code>--</code>和<code>said</code> : <pre>stop_context = ["--", "said"]</pre>的变量</li>
				<li>为停用字词创建一个主列表，以删除包含标点符号、NLTK停用字词和上下文停用字词的字词:<pre>stop_final = stop_punct + stop_nltk + stop_context</pre></li>
				<li>定义一个函数，从任何输入句子中删除这些标记(标记化的):<pre>def drop_stop(input_tokens):     return [token for token in input_tokens \             if token not in stop_final]</pre></li>
				<li>Remove the terms in <code>stop_final</code> from the tokenized text:<pre>alice_words_nostop = [drop_stop(sent) for sent in txt_words]
print(alice_words_nostop[:2])</pre><p>前两句话是这样的:</p><pre>[['alice', "'s", 'adventures', 'wonderland', 'lewis', 'carroll', '1865', 'chapter', 'i.', 'rabbit-hole', 'alice', 'beginning', 'get', 'tired', 'sitting', 'sister', 'bank', 'nothing', 'twice', 'peeped', 'book', 'sister', 'reading', 'pictures', 'conversations', "'and", 'use', 'book', 'thought', 'alice', "'without", 'pictures', 'conversation'], ['considering', 'mind', 'well', 'could', 'hot', 'day', 'made', 'feel', 'sleepy', 'stupid', 'whether', 'pleasure', 'making', 'daisy-chain', 'would', 'worth', 'trouble', 'getting', 'picking', 'daisies', 'suddenly', 'white', 'rabbit', 'pink', 'eyes', 'ran', 'close']]</pre></li>
				<li>Using the <code>PorterStemmer</code> algorithm from NLTK, perform stemming on the result. Print out the first five sentences of the result:<pre>from nltk.stem import PorterStemmer
stemmer_p = PorterStemmer()
alice_words_stem = [[stemmer_p.stem(token) for token in sent] \
                     for sent in alice_words_nostop]
print(alice_words_stem[:5])</pre><p>输出如下所示:</p><pre>[['alic', "'s", 'adventur', 'wonderland', 'lewi', 'carrol', '1865', 'chapter', 'i.', 'rabbit-hol', 'alic', 'begin', 'get', 'tire', 'sit', 'sister', 'bank', 'noth', 'twice', 'peep', 'book', 'sister', 'read', 'pictur', 'convers', "'and", 'use', 'book', 'thought', 'alic', "'without", 'pictur', 'convers'], ['consid', 'mind', 'well', 'could', 'hot', 'day', 'made', 'feel', 'sleepi', 'stupid', 'whether', 'pleasur', 'make', 'daisy-chain', 'would', 'worth', 'troubl', 'get', 'pick', 'daisi', 'suddenli', 'white', 'rabbit', 'pink', 'eye', 'ran', 'close'], ['noth', 'remark', 'alic', 'think', 'much', 'way', 'hear', 'rabbit', 'say', "'oh", 'dear'], ['oh', 'dear'], ['shall', 'late']]</pre><p class="callout-heading">注意</p><p class="callout">要访问该特定部分的源代码，请参考https://packt.live/2VVNEgf的<a href="https://packt.live/2VVNEgf"/>。</p><p class="callout">你也可以在https://packt.live/38Gr54r在线运行这个例子。您必须执行整个笔记本才能获得想要的结果。</p></li>
			</ol>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor276"/>活动4.02:爱丽丝梦游仙境的文本展示</h2>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor277"/>解决方案</h2>
			<p>您需要执行以下步骤:</p>
			<ol>
				<li value="1">From <em class="italic">Activity 4.01</em>, <em class="italic">Text Preprocessing Alice in Wonderland</em>, print the first three sentences from the result after stop word removal. This is the data you will work with:<pre>print(alice_words_nostop[:3])</pre><p>输出如下所示:</p><pre>[['alice', "'s", 'adventures', 'wonderland', 'lewis', 'carroll', '1865', 'chapter', 'i.', 'rabbit-hole', 'alice', 'beginning', 'get', 'tired', 'sitting', 'sister', 'bank', 'nothing', 'twice', 'peeped', 'book', 'sister', 'reading', 'pictures', 'conversations', "'and", 'use', 'book', 'thought', 'alice', "'without", 'pictures', 'conversation'], ['considering', 'mind', 'well', 'could', 'hot', 'day', 'made', 'feel', 'sleepy', 'stupid', 'whether', 'pleasure', 'making', 'daisy-chain', 'would', 'worth', 'trouble', 'getting', 'picking', 'daisies', 'suddenly', 'white', 'rabbit', 'pink', 'eyes', 'ran', 'close'], ['nothing', 'remarkable', 'alice', 'think', 'much', 'way', 'hear', 'rabbit', 'say', "'oh", 'dear']]</pre></li>
				<li>从Gensim导入<code>word2vec</code>并用默认参数训练你的单词嵌入:<pre>from gensim.models import word2vec model = word2vec.Word2Vec(alice_words_nostop)</pre></li>
				<li>Find the <code>5</code> terms most similar to <code>rabbit</code>:<pre>model.wv.most_similar("rabbit", topn=5)</pre><p>输出如下所示:</p><pre>[('alice', 0.9963310360908508),
 ('little', 0.9956872463226318),
 ('went', 0.9955698251724243),
 ("'s", 0.9955658912658691),
 ('would', 0.9954401254653931)]</pre></li>
				<li>使用<code>window</code>大小的<code>2</code>，重新训练单词向量:<pre>model = word2vec.Word2Vec(alice_words_nostop, window=2)</pre></li>
				<li>Find the terms most similar to <code>rabbit</code>:<pre>model.wv.most_similar("rabbit", topn=5)</pre><p>输出如下所示:</p><pre>[('alice', 0.9491485357284546),
 ("'s", 0.9364748001098633),
 ('little', 0.9345826506614685),
 ('large', 0.9341927170753479),
 ('duchess', 0.9341296553611755)]</pre></li>
				<li>使用Skip-gram方法重新训练单词向量，窗口大小为<code>5</code> : <pre>model = word2vec.Word2Vec(alice_words_nostop, window=5, sg=1)</pre></li>
				<li>Find the terms most similar to <code>rabbit</code>:<pre>model.wv.most_similar("rabbit", topn=5)</pre><p>输出如下所示:</p><pre>[('gardeners', 0.9995723366737366),
 ('end', 0.9995588064193726),
 ('came', 0.9995309114456177),
 ('sort', 0.9995298385620117),
 ('upon', 0.9995272159576416)]</pre></li>
				<li>通过对<code>white</code>和<code>rabbit</code> : <pre>v1 = model.wv['white'] v2 = model.wv['rabbit'] res1 = (v1+v2)/2</pre>的向量求平均值，找到短语<code>white rabbit</code>的表示</li>
				<li>通过对<code>mad</code>和<code>hatter</code> : <pre>v1 = model.wv['mad'] v2 = model.wv['hatter'] res2 = (v1+v2)/2</pre>的向量求平均值，找到<code>mad hatter</code>的表示</li>
				<li>Find the cosine similarity between these two phrases:<pre>model.wv.cosine_similarities(res1, [res2])</pre><p>这为我们提供了以下值:</p><pre>array([0.9996213], dtype=float32)</pre></li>
				<li>使用格式化的键控向量加载尺寸为100D的预训练手套嵌入:<pre>from gensim.models.keyedvectors import KeyedVectors glove_model = KeyedVectors.load_word2vec_format\ ("glove.6B.100d.w2vformat.txt", binary=False)</pre></li>
				<li>查找<code>white rabbit</code>和<code>mad hatter</code>的表示:<pre>v1 = glove_model['white'] v2 = glove_model['rabbit'] res1 = (v1+v2)/2 v1 = glove_model['mad'] v2 = glove_model['hatter'] res2 = (v1+v2)/2</pre></li>
				<li>Find the <code>cosine</code> similarity between the two phrases. Has the cosine similarity changed?<pre>glove_model.cosine_similarities(res1, [res2])</pre><p>以下是上述代码的输出:</p><pre>array([0.4514577], dtype=float32)</pre></li>
			</ol>
			<p>在这里，我们可以看到两个短语“<code>mad hatter</code>”和“<code>white rabbit</code>”之间的余弦相似度远远低于手套模型。这是因为手套模型在其训练数据中没有像在书中那样多地看到这些术语。在这本书里，<code>mad</code>和<code>hatter</code>这两个词出现了很多次，因为它们构成了一个重要角色的名字。当然，在其他情况下，我们不会经常看到<code>mad</code>和<code>hatter</code>在一起。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考<a href="https://packt.live/2VVNEgf">https://packt.live/2VVNEgf</a>。</p>
			<p class="callout">本节目前没有在线交互示例，需要在本地运行。</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor278"/> 5。序列的深度学习</h1>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor279"/>活动5.01:使用简单的RNN模型预测IBM的股票价格</h2>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor280"/>解</h2>
			<ol>
				<li value="1">Import the necessary libraries, load the <code>.csv </code>file, reverse the index, and plot the time series (the <code>Close</code> column) for visual inspection:<pre>import pandas as pd, numpy as np
import matplotlib.pyplot as plt
inp0 = pd.read_csv("IBM.csv")
inp0 = inp0.sort_index(ascending=False)
inp0.plot("Date", "Close")
plt.show()</pre><p>输出如下，收盘价绘制在<em class="italic"> Y轴</em>上:</p><p> </p><div><img src="img/B15385_05_40.jpg" alt="Figure 5.40: The trend for IBM stock prices&#13;&#10;"/></div><p class="figure-caption">图5.40:IBM股票价格的趋势</p></li>
				<li>Extract the values for <code>Close</code> from the DataFrame as a <code>numpy</code> array and plot them using <code>matplotlib</code>:<pre>ts_data = inp0.Close.values.reshape(-1,1)
plt.figure(figsize=[14,5])
plt.plot(ts_data)
plt.show()</pre><p>结果趋势如下，指数绘制在<em class="italic"> X轴</em>上:</p><div><img src="img/B15385_05_41.jpg" alt="Figure 5.41: The stock price data visualized&#13;&#10;"/></div><p class="figure-caption">图5.41:可视化的股票价格数据</p></li>
				<li>Assign the final 25% data as test data and the first 75% as train data:<pre>train_recs = int(len(ts_data) * 0.75)
train_data = ts_data[:train_recs]
test_data = ts_data[train_recs:]
len(train_data), len(test_data)</pre><p>输出如下所示:</p><pre>(1888, 630)</pre></li>
				<li>使用<code>sklearn</code>中的<code>MinMaxScaler</code>，缩放训练和测试数据:<pre>from sklearn.preprocessing import MinMaxScaler scaler = MinMaxScaler() train_scaled = scaler.fit_transform(train_data) test_scaled = scaler.transform(test_data)</pre></li>
				<li>Using the <code>get_lookback</code> function we defined earlier in this chapter (refer to the <em class="italic">Preparing the Data for Stock Price Prediction</em> section), get the lookback data for the train and test sets using a lookback period of 10:<pre>look_back = 10
trainX, trainY = get_lookback(train_scaled, look_back=look_back)
testX, testY = get_lookback(test_scaled, look_back= look_back)
trainX.shape, testX.shape</pre><p>输出如下所示:</p><pre>((1888, 10), (630, 10))</pre></li>
				<li>从Keras中，导入使用普通rnn(<code>SimpleRNN</code>、<code>Activation</code>、<code>Dropout</code>、<code>Dense</code>和<code>Reshape</code>)和1D卷积(Conv1D)所需的所有层。另外，从<code>sklearn</code> : <pre>from tensorflow.keras.models import Sequential from tensorflow.keras.layers import SimpleRNN, Activation, Dropout, Dense, Reshape, Conv1D from sklearn.metrics import mean_squared_error</pre>导入<code>mean_squared_error</code>指标</li>
				<li>Build a model with a 1D convolution layer (5 filters of size 3) and an RNN layer with 32 neurons. Add 25% dropout after the RNN layer. Print the model's summary:<pre>model_comb = Sequential()
model_comb.add(Reshape((look_back,1), \
                        input_shape = (look_back,)))
model_comb.add(Conv1D(5, 3, activation='relu'))
model_comb.add(SimpleRNN(32))
model_comb.add(Dropout(0.25))
model_comb.add(Dense(1))
model_comb.add(Activation('linear'))
model.summary()</pre><p>输出如下所示:</p><div><img src="img/B15385_05_42.jpg" alt="Figure 5.42: Summary of the model&#13;&#10;"/></div><p class="figure-caption">图5.42:模型总结</p></li>
				<li>Compile the model with the <code>mean_squared_error</code> loss and the <code>adam</code> optimizer. Fit this on the train data in five epochs, with a validation split of 10% and a batch size of 1:<pre>model_comb.compile(loss='mean_squared_error', \
                   optimizer='adam')
model_comb.fit(trainX, trainY, epochs=5, \
               batch_size=1, verbose=2, \
               validation_split=0.1)</pre><p>输出如下所示:</p><div><img src="img/B15385_05_43.jpg" alt="Figure 5.43: Training and validation loss&#13;&#10;"/></div><p class="figure-caption">图5.43:培训和验证损失</p></li>
				<li>Using the <code>get_model_perf</code> method, print the RMSE of the model:<pre>get_model_perf(model_comb)</pre><p>输出如下所示:</p><pre>Train RMSE: 0.03 RMSE
Test RMSE: 0.03 RMSE</pre></li>
				<li>Plot the predictions – the entire view, as well as the zoomed-in view:<pre>%matplotlib notebook
plt.figure(figsize=[10,5])
plot_pred(model_comb)</pre><p>我们应该会看到下面的预测图(虚线)和实际图(实线):</p><p> </p><div><img src="img/B15385_05_44.jpg" alt="Figure 5.44: Predictions versus actuals&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图5.44:预测与实际</p>
			<p>放大后的视图如下:</p>
			<div><div><img src="img/B15385_05_45.jpg" alt="Figure 5.45: Predictions (dotted lines) versus actuals (solid lines) – detailed view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图5.45:预测值(虚线)与实际值(实线)-详细视图</p>
			<p>我们可以看到，该模型在捕捉更精细的模式方面做得很好，并且在预测每日股票价格方面做得非常好。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考<a href="https://packt.live/2ZctArW">https://packt.live/2ZctArW</a>。</p>
			<p class="callout">你也可以在https://packt.live/38EDOEA在线运行这个例子。您必须执行整个笔记本才能获得想要的结果。</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor281"/> 6。LSTMs、gru和高级rnn</h1>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor282"/>活动6.01:亚马逊产品评论的情感分析</h2>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor283"/>解决方案</h2>
			<ol>
				<li value="1">Read in the data files for the <code>train</code> and <code>test</code> sets. Examine the shapes of the datasets and print out the top <code>5</code> records from the <code>train</code> data:<pre>import pandas as pd, numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
train_df = pd.read_csv("Amazon_reviews_train.csv")
test_df = pd.read_csv("Amazon_reviews_test.csv")
print(train_df.shape, train_df.shape)
train_df.head(5)</pre><p>数据集的形状和标题如下:</p><div><img src="img/B15385_06_26.jpg" alt="Figure 6.26: First five records from the train dataset&#13;&#10;"/></div><p class="figure-caption">图6.26:训练数据集中的前五条记录</p></li>
				<li>For convenience, when it comes to processing, separate the raw text and the labels for the <code>train</code> and <code>test</code> sets. You should have <code>4</code> variables, as follows: <code>train_raw</code> comprising raw text for the train data, <code>train_labels</code> with labels for the train data, <code>test_raw</code> containing raw text for the test data, and <code>test_labels</code> comprising Labels for the test data. Print the first two reviews from the <code>train</code> text.<pre>train_raw = train_df.review_text.values
train_labels = train_df.label.values
test_raw = test_df.review_text.values
test_labels = test_df.label.values
train_raw[:2]</pre><p>上述代码会产生以下输出:</p><div><img src="img/B15385_06_27.jpg" alt="Figure 6.27: Raw text from the train dataset&#13;&#10;"/></div><p class="figure-caption">图6.27:来自训练数据集的原始文本</p></li>
				<li>Normalize the case and tokenize the test and train texts using NLTK's <code>word_tokenize</code> (after importing it, of course – hint: use a list comprehension for cleaner code). Download <code>punkt</code> from <code>nltk</code> if you haven't used the tokenizer before. Print the first review from the train data to check if the tokenization worked.<pre>import nltk
nltk.download('punkt')
from nltk.tokenize import word_tokenize
train_tokens = [word_tokenize(review.lower()) \
                for review in train_raw]
test_tokens = [word_tokenize(review.lower()) \
               for review in test_raw]
print(train_tokens[0])</pre><p>标记化的数据打印如下:</p><div><img src="img/B15385_06_28.jpg" alt="Figure 6.28: Tokenized review from the train dataset&#13;&#10;"/></div><p class="figure-caption">图6.28:来自<code>train</code>数据集的标记化检查</p></li>
				<li>从字符串模块导入任何停用词(内置于NLTK)和标点符号。定义一个函数(<code>drop_stop</code>)从任何输入的标记化句子中删除这些标记。从NLTK下载<code>stopwords</code>如果你以前没用过:<pre>from string import punctuation stop_punct = list(punctuation) nltk.download("stopwords") from nltk.corpus import stopwords stop_nltk = stopwords.words("english") stop_final = stop_punct + stop_nltk def drop_stop(input_tokens):     return [token for token in input_tokens \             if token not in stop_final]</pre></li>
				<li>Using the defined function (<code>drop_stop</code>), remove the redundant stop words from the <code>train</code> and the <code>test</code> texts. Print the first review of the processed <code>train</code> texts to check whether the function worked:<pre>train_tokens_no_stop = [drop_stop(sent) \
                        for sent in train_tokens]
test_tokens_no_stop = [drop_stop(sent) \
                       for sent in test_tokens]
print(train_tokens_no_stop[0])</pre><p>我们将得到以下输出:</p><pre>['stuning', 'even', 'non-gamer', 'sound', 'track', 'beautiful', 
 'paints', 'senery', 'mind', 'well', 'would', 'recomend', 'even', 
 'people', 'hate', 'vid', 'game', 'music', 'played', 'game', 
 'chrono', 'cross', 'games', 'ever', 'played', 'best', 'music', 
 'backs', 'away', 'crude', 'keyboarding', 'takes', 'fresher', 
 'step', 'grate', 'guitars', 'soulful', 'orchestras', 'would', 
 'impress', 'anyone', 'cares', 'listen', '^_^']</pre></li>
				<li>Using <code>PorterStemmer</code> from NLTK, stem the tokens for both the <code>train</code> and <code>test</code> data:<pre>from nltk.stem import PorterStemmer
stemmer_p = PorterStemmer()
train_tokens_stem = [[stemmer_p.stem(token) for token in sent] \
                     for sent in train_tokens_no_stop]
test_tokens_stem = [[stemmer_p.stem(token) for token in sent] \
                     for sent in test_tokens_no_stop]
print(train_tokens_stem[0])</pre><p>结果应该打印如下:</p><pre>['stune', 'even', 'non-gam', 'sound', 'track', 'beauti', 'paint', 
 'seneri', 'mind', 'well', 'would', 'recomend', 'even', 'peopl', 
 'hate', 'vid', 'game', 'music', 'play', 'game', 'chrono', 'cross', 
 'game', 'ever', 'play', 'best', 'music', 'back', 'away', 'crude', 
 'keyboard', 'take', 'fresher', 'step', 'grate', 'guitar', 'soul', 
 'orchestra', 'would', 'impress', 'anyon', 'care', 'listen', '^_^']</pre></li>
				<li>Create the strings for each of the <code>train</code> and <code>text</code> reviews. This will help us work with the utilities in Keras to create and pad the sequences. Create the <code>train_texts</code> and <code>test_texts</code> variables. Print the first review from the processed <code>train</code> data to confirm this:<pre>train_texts = [" ".join(txt) for txt in train_tokens_stem]
test_texts = [" ".join(txt) for txt in test_tokens_stem]
print(train_texts[0])</pre><p>上述代码的结果如下:</p><pre>stune even non-gam sound track beauti paint seneri mind well would recommend even peopl hate vid game music play game chrono cross game ever play best music back away crude keyboard take fresher step grate guitar soul orchestra would impress anyon care listen ^_^</pre></li>
				<li>从Keras的文本预处理工具(<code>keras.preprocessing.text</code>，导入<code>Tokenizer</code>模块。定义一个词汇大小<code>10000</code>，并用这个词汇实例化标记器:<pre>from tensorflow.keras.preprocessing.text import Tokenizer vocab_size = 10000 tok = Tokenizer(num_words=vocab_size)</pre></li>
				<li>Fit the tokenizer on the <code>train</code> texts. This works just like <code>CountVectorizer</code> did in <em class="italic">Chapter 4, Deep Learning for Text – Embeddings</em>, and trains the vocabulary. After fitting, use the <code>texts_to_sequences</code> method of the tokenizer on the <code>train</code> and <code>test</code> sets to create the sequences for them. Print the sequence for the first review in the train data:<pre>tok.fit_on_texts(train_texts)
train_sequences = tok.texts_to_sequences(train_texts)
test_sequences = tok.texts_to_sequences(test_texts)
print(train_sequences[0])</pre><p>编码序列如下:</p><pre> [22, 514, 7161, 85, 190, 184, 1098, 283, 20, 11, 1267, 22, 
  56, 370, 9682, 114, 41, 71, 114, 8166, 1455, 114, 51, 71, 
  29, 41, 58, 182, 2931, 2153, 75, 8167, 816, 2666, 829, 719, 
  3871, 11, 483, 120, 268, 110]</pre></li>
				<li>We need to find the optimal length of the sequences to process the model. Get the length of the reviews from the <code>train</code> set into a list and plot a histogram of the lengths:<pre>seq_lens = [len(seq) for seq in train_sequences]
plt.hist(seq_lens)
plt.show()</pre><p>长度分布如下:</p><div><img src="img/B15385_06_29.jpg" alt="Figure 6.29: Histogram of text lengths&#13;&#10;"/></div><p class="figure-caption">图6.29:文本长度直方图</p></li>
				<li> The data is now in the same format as the IMDb data we used in this chapter. Using a sequence length of <code>100</code> (define the <code>maxlen = 100</code> variable), use the <code>pad_sequences</code> method from the <code>sequence</code> module in Keras' preprocessing utilities (<code>keras.preprocessing.sequence</code>) to limit the sequences to <code>100</code> for both the <code>train</code> and <code>test</code> data. Check the shape of the result for the train data:<pre>maxlen = 100
from tensorflow.keras.preprocessing.sequence import pad_sequences
X_train = pad_sequences(train_sequences, maxlen=maxlen)
X_test = pad_sequences(test_sequences, maxlen=maxlen)
X_train.shape</pre><p>形状如下:</p><pre>(25000, 100)</pre></li>
				<li>要构建模型，从Keras ( <code>embedding</code>、<code>spatial dropout</code>、<code>LSTM</code>、<code>dropout</code>和<code>dense</code>)导入所有必要的层，并导入<code>Sequential</code>模型。初始化<code>Sequential</code>模型:<pre>from tensorflow.keras.models import Sequential from tensorflow.keras.layers import Dense, Embedding, SpatialDropout1D, Dropout, GRU, LSTM model_lstm = Sequential()</pre></li>
				<li>添加一个<code>32</code>为矢量大小的嵌入图层(<code>output_dim</code>)。添加一个<code>40%</code> : <pre>model_lstm.add(Embedding(vocab_size, output_dim=32)) model_lstm.add(SpatialDropout1D(0.4))</pre>的空间缺失</li>
				<li>建立一个堆叠的LSTM模型，每层有<code>2</code>个T21单元。用<code>40%</code> dropout: <pre>model_lstm.add(LSTM(64, return_sequences=True)) model_lstm.add(LSTM(64, return_sequences=False)) model_lstm.add(Dropout(0.4))</pre>添加一个dropout层</li>
				<li>添加一个带有激活<code>relu</code>的<code>32</code>神经元的密集层，然后是一个<code>50%</code>脱落层，接着是另一个带有激活<code>relu</code>的<code>32</code>神经元的密集层，接着是另一个带有<code>50%</code>脱落的脱落层:<pre>model_lstm.add(Dense(32, activation='relu')) model_lstm.add(Dropout(0.5)) model_lstm.add(Dense(32, activation='relu')) model_lstm.add(Dropout(0.5))</pre></li>
				<li>Add a final dense layer with a single neuron with <code>sigmoid</code> <code>activation</code> and compile the model. Print the model summary:<pre>model_lstm.add(Dense(1, activation='sigmoid'))
model_lstm.compile(loss='binary_crossentropy', \
                   optimizer='rmsprop', \
                   metrics=['accuracy'])
model_lstm.summary()</pre><p>该模型的概要如下:</p><div><img src="img/B15385_06_30.jpg" alt="Figure 6.30: Stacked LSTM model summary&#13;&#10;"/></div><p class="figure-caption">图6.30:堆叠LSTM模型摘要</p></li>
				<li>Fit the model on the training data with a <code>20%</code> validation split and a batch size of <code>128</code>. Train for <code>5</code> <code>epochs</code>:<pre>history_lstm = model_lstm.fit(X_train, train_labels, \
                              batch_size=128, \
                              validation_split=0.2, \
                              epochs = 5)</pre><p>我们将获得以下培训输出:</p><div><img src="img/B15385_06_31.jpg" alt="Figure 6.31: Stacked LSTM model training output&#13;&#10;"/></div><p class="figure-caption">图6.31:堆叠LSTM模型训练输出</p></li>
				<li>Make a prediction on the test set using the <code>predict_classes</code> method of the model. Then, print out the confusion matrix:<pre>from sklearn.metrics import accuracy_score, confusion_matrix
test_pred = model_lstm.predict_classes(X_test)
print(confusion_matrix(test_labels, test_pred))</pre><p>我们将得到以下结果:</p><pre>[[10226,  1931],
 [ 1603, 11240]]</pre></li>
				<li>Using the <code>accuracy_score</code> method from <code>scikit-learn</code>, calculate the accuracy of the test set.<pre>print(accuracy_score(test_labels, test_pred))</pre><p>我们得到的精度是:</p><pre>0.85864</pre></li>
			</ol>
			<p>正如我们所看到的，准确度分数在<code>86%</code>左右，并且查看混淆矩阵(<em class="italic">步骤18 </em>的输出),该模型很好地预测了两个类别。我们没有做任何超参数调整就获得了这种精度。您可以调整超参数以获得更高的精度。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考<a href="https://packt.live/3fpo0YI">https://packt.live/3fpo0YI</a>。</p>
			<p class="callout">你也可以在https://packt.live/2Wi75QH在线运行这个例子。您必须执行整个笔记本才能获得想要的结果。</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor284"/> 7。生成对抗网络</h1>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor285"/>活动7.01:为MNIST时装数据集实施DCGAN</h2>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor286"/>解决方案</h2>
			<ol>
				<li value="1">打开一个新的Jupyter笔记本，命名为<code>Activity 7.01</code>。导入以下库包:<pre># Import the required library functions import numpy as np import matplotlib.pyplot as plt from matplotlib import pyplot import tensorflow as tf from tensorflow.keras.layers import Input from tensorflow.keras.initializers import RandomNormal from tensorflow.keras.models import Model, Sequential from tensorflow.keras.layers \ import Reshape, Dense, Dropout, Flatten,Activation from tensorflow.keras.layers import LeakyReLU,BatchNormalization from tensorflow.keras.layers import Conv2D, UpSampling2D,Conv2DTranspose from tensorflow.keras.datasets import fashion_mnist from tensorflow.keras.optimizers import Adam</pre></li>
				<li>Create a function that will generate real data samples from the fashion MNIST data:<pre># Function to generate real data samples
def realData(batch):
    # Get the MNIST data 
    (X_train, _), (_, _) = fashion_mnist.load_data()
    # Reshaping the input data to include channel
    X = X_train[:,:,:,np.newaxis]
    # normalising the data to be between 0 and 1
    X = (X.astype('float32') - 127.5)/127.5
    # Generating a batch of data
    imageBatch = X[np.random.randint(0, X.shape[0], \
                                     size=batch)]
    return imageBatch</pre><p>该函数的输出是批量MNIST数据。请注意，我们通过减去<code>127.5</code>(最大像素值的一半)并除以相同的值来归一化输入数据。这将有助于更快地收敛解决方案。</p></li>
				<li>Now, let's generate a set of images from the MNIST dataset:<pre># Generating a set of  sample images 
fashionData = realData(25)</pre><p>您应该得到以下输出:</p><div><img src="img/B15385_07_36.jpg" alt="Figure 7.36: Generating images from MNIST&#13;&#10;"/></div><p class="figure-caption">图7.36:从MNIST生成图像</p></li>
				<li>Now, let's visualize the images with <code>matplotlib</code>:<pre> # for j in range(5*5):
    pyplot.subplot(5,5,j+1)
    # turn off axis 
    pyplot.axis('off') 
    pyplot.imshow(fashionData[j,:,:,0],cmap='gray_r')</pre><p>您应该会得到类似如下所示的输出:</p><div><img src="img/B15385_07_37.jpg" alt="Figure 7.37: Plotted images&#13;&#10;"/></div><p class="figure-caption">图7.37:绘制的图像</p><p>从输出中，我们可以看到几个时尚文章的可视化。我们可以看到图像位于白色背景的中央。这是我们试图重现的画面。</p></li>
				<li>Now, let's define the function to generate inputs for the generator network. The inputs are random data points that are generated from a random uniform distribution:<pre># Function to generate inputs for generator function
def fakeInputs(batch,infeats):
    # Generate random noise data with shape (batch,input features)
    x_fake = np.random.uniform(-1,1,size=[batch,infeats])
    return x_fake</pre><p>该函数生成从随机分布中采样的假数据作为输出。</p></li>
				<li>Let's define the function for building the generator network:<pre>Activity7.01.ipynb
# <a id="_idTextAnchor287"/>Function for the generator model
def genModel(infeats):
    # Defining the Generator model
    Genmodel = Sequential()
    Genmodel.add(Dense(512,input_dim=infeats))
    Genmodel.add(Activation('relu'))
    Genmodel.add(BatchNormalization())
    # second layer of FC =&gt; RElu =&gt; BN layers
    Genmodel.add(Dense(7*7*64))
    Genmodel.add(Activation('relu'))
    Genmodel.add(BatchNormalization())
The complete code for this step can be found at <a href="https://packt.live/3fpobDm">https://packt.live/3fpobDm</a></pre><p>构建发电机网络类似于构建任何CNN网络。在这个生成器网络中，我们将使用转置卷积方法对图像进行上采样。在这个模型中，我们可以看到转置卷积的逐步使用。初始输入从维度100开始，这是我们的输入特性。MNIST数据集的维度是批量大小x 28 x 28。因此，我们对数据进行了两次上采样，以获得批量大小为x 28 x 28的输出。</p></li>
				<li>Next, we define the function that will be used to create fake samples: <pre># Function to create fake samples using the generator model
def fakedataGenerator(Genmodel,batch,infeats):
    # first generate the inputs to the model
    genInputs = fakeInputs(batch,infeats)
    """
    use these inputs inside the generator model \
    to generate fake distribution
    """
    X_fake = Genmodel.predict(genInputs)
    return X_fake</pre><p>在这个函数中，我们只返回<code>X</code>变量。这个函数的输出是假数据集。</p></li>
				<li>Define the parameters that we will use in many of the functions, along with the summary of the generator network:<pre># Define the arguments like batch size and input feature
batch = 128
infeats = 100
Genmodel = genModel(infeats,)
Genmodel.summary()</pre><p>您应该得到以下输出:</p><p> </p><div><img src="img/B15385_07_38.jpg" alt="Figure 7.38: Summary of the generative model&#13;&#10;"/></div><p class="figure-caption">图7.38:创成式模型概述</p><p>根据总结，请注意输入噪声的维度如何随着每个转置卷积运算而变化。最后，我们得到一个在维数上与真实数据集相等的输出，<code>( None,28 ,28,1)</code>。</p></li>
				<li>Let's use the generator function to generate a fake sample before training:<pre># Generating a fake sample and printing the shape
fake = fakedataGenerator(Genmodel,batch,infeats)
fake.shape</pre><p>您应该得到以下输出:</p><pre>(128, 28, 28, 1)</pre></li>
				<li>Now, let's plot the generated fake sample:<pre># Plotting the fake sample
plt.imshow(fake[1, :, :, 0], cmap='gray_r')</pre><p>您应该会得到类似如下的输出:</p><div><img src="img/B15385_07_39.jpg" alt="Figure 7.39: Output of the fake sample&#13;&#10;"/></div><p class="figure-caption">图7.39:假样本的输出</p><p>这是训练前假样本的情节。训练后，我们希望像这样的样本看起来像我们在本活动中早些时候可视化的MNIST时装样本。</p></li>
				<li>Build the discriminator model as a function. The network architecture will be similar to a CNN architecture:<pre>Activity7.01.ipynb
# Descriminator model as a function
def discModel():
    Discmodel = Sequential()
    Discmodel.add(Conv2D(32,kernel_size=(5,5),strides=(2,2),\
                  padding='same',input_shape=(28,28,1)))
    Discmodel.add(LeakyReLU(0.2))
    # second layer of convolutions
    Discmodel.add(Conv2D(64, kernel_size=(5,5), strides=(2, 2), \
                  padding='same'))
    Discmodel.add(LeakyReLU(0.2))
The full code for this step can be found at <a href="https://packt.live/3fpobDm">https://packt.live/3fpobDm</a></pre><p>在鉴别器网络中，我们已经包括了所有必要的层，例如卷积运算和<code>LeakyReLU</code>。请注意，最后一层是sigmoid层，因为我们希望输出样本是真实(1)还是虚假(0)的概率。</p></li>
				<li>Print the summary of the discriminator network:<pre># Print the summary of the discriminator model
Discmodel = discModel()
Discmodel.summary()</pre><p>您应该得到以下输出:</p><div><img src="img/B15385_07_40.jpg" alt="Figure 7.40: Discriminator model summary&#13;&#10;"/></div><p class="figure-caption">图7.40:鉴别器模型总结</p></li>
				<li>Define the GAN model as a function:<pre># Define the combined generator and discriminator model, for updating the generator
def ganModel(Genmodel,Discmodel):
    # First define that discriminator model cannot be trained
    Discmodel.trainable = False
    Ganmodel = Sequential()
    # First adding the generator model
    Ganmodel.add(Genmodel)
    """
    Next adding the discriminator model 
    without training the parameters
    """
    Ganmodel.add(Discmodel)
    """
    Compile the model for loss to optimise the Generator model
    """
    Ganmodel.compile(loss='binary_crossentropy',\
                     optimizer = 'adam')
    return Ganmodel</pre><p>GAN模型的结构类似于我们在<em class="italic">练习7.05 </em>、<em class="italic">中开发的实现DCGAN </em>的模型。</p></li>
				<li>Now, it's time to invoke the GAN function:<pre># Initialise the GAN model
gan_model = ganModel(Genmodel,Discmodel)
# Print summary of the GAN model
gan_model.summary()</pre><p>请注意，GAN模型的输入是之前定义的发电机模型和鉴别器模型。您应该得到以下输出:</p><div><img src="img/B15385_07_41.jpg" alt="Figure 7.41: GAN model summary&#13;&#10;"/></div><p class="figure-caption">图7.41: GAN模型总结</p><p>请注意，GAN模型各层的参数与发生器和鉴别器模型的参数是等效的。GAN模型只是我们之前定义的两个模型的包装。</p></li>
				<li>使用以下代码定义训练网络的时期数:<pre># Defining the number of epochs nEpochs = 5000</pre></li>
				<li>Now, we can start the process of training the network:<pre>Activity7.01.ipynb
# Train the GAN network
for i in range(nEpochs):
    """
    Generate samples equal to the batch size 
    from the real distribution
    """
    x_real = realData(batch)
    #Generate fake samples using the fake data generator function
    x_fake = fakedataGenerator(Genmodel,batch,infeats)
    # Concatenating the real and fake data 
    X = np.concatenate([x_real,x_fake])
    #Creating the dependent variable and initializing them as '0'
    Y = np.zeros(batch * 2)
The complete code for this step can be found on <a href="https://packt.live/3fpobDm">https://packt.live/3fpobDm</a></pre><p>这里需要注意的是，用假样本和真样本训练鉴别器模型以及训练GAN模型是同时发生的。唯一的区别是GAN模型的训练在没有更新鉴别器模型的参数的情况下进行。另一点需要注意的是，在GAN内部，伪样本的标签将为1，从而产生大量损耗项，这些损耗项将通过鉴频器网络反向传播，以更新发生器参数。我们还显示了每50个时期GAN的预测概率。在计算概率时，我们将真实数据样本和虚假数据样本结合起来，然后取预测概率的平均值。我们还保存了生成图像的副本。</p><p>您应该会得到类似如下的输出:</p><pre>Discriminator probability:0.5276428461074829
Discriminator probability:0.5038391351699829
Discriminator probability:0.47621315717697144
Discriminator probability:0.48467564582824707
Discriminator probability:0.5270703434944153
Discriminator probability:0.5247280597686768
Discriminator probability:0.5282968282699585</pre><p>让我们看看在不同时期从训练过程中产生的一些图:</p><div><img src="img/B15385_07_42.jpg" alt="Figure 7.42: Images generated during the training process&#13;&#10;"/></div><p class="figure-caption">图7.42:训练过程中生成的图像</p><p>从前面的图中，我们可以看到训练过程的进展。我们可以看到，到了公元100年，这些图大部分都是噪声。到了公元600年，时尚物品的形式开始变得更加明显。在1，500年，我们可以看到假图像看起来非常类似于时尚数据集。</p><p class="callout-heading">注意:</p><p class="callout">你可以去https://packt.live/2W1FjaI仔细看看这些图片。</p></li>
				<li>Now, let's look at the images that were generated after training:<pre> # Images generated after training
x_fake = fakedataGenerator(Genmodel,25,infeats)
# Displaying the plots
for j in range(5*5):
pyplot.subplot(5,5,j+1)
    # turn off axis 
    pyplot.axis('off')
    pyplot.imshow(x_fake[j,:,:,0],cmap='gray_r')</pre><p>您应该会得到类似如下的输出:</p><p> </p><div><img src="img/B15385_07_43.jpg" alt="Figure 7.43: Images generated after the training process&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">图7.43:训练过程后生成的图像</p>
			<p>从训练精度级别中，您可以看到鉴别器模型的精度徘徊在. 50范围附近，这是所需的范围。发生器的目的是创建看起来像真图像的假图像。当生成器生成看起来与真实图像非常相似的图像时，鉴别器会弄不清该图像是从真实分布还是伪分布生成的。这种现象表现在鉴频器的精度水平约为50%,这是所希望的水平。</p>
			<p class="callout-heading">注意</p>
			<p class="callout">要访问该特定部分的源代码，请参考https://packt.live/3fpobDm的<a href="https://packt.live/3fpobDm"/>。</p>
			<p class="callout">本节目前没有在线交互示例，需要在本地运行。</p>
		</div>
	

</body></html>