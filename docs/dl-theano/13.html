<html><head/><body>
<html>
  <head>
    <title>Chapter 13. Extending Deep Learning with Theano</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">第十三章。用Theano扩展深度学习</h1></div></div></div><p class="calibre8">这一章给出了进一步研究ano和深度学习的线索。首先，它展示了如何用Python或C为Theano计算图创建新的操作符，无论是为CPU还是GPU。然后，在代码库和库的支持下研究与其他深度学习框架的交互，这些代码库和库支持与其他技术的来回转换。</p><p class="calibre8">最后，为了完成深度学习领域提供的可能性，我们开发了一个新的通用人工智能领域的概念。</p><p class="calibre8">本章涵盖的主题如下:</p><div><ul class="itemizedlist"><li class="listitem">为无计算图编写新的运算符</li><li class="listitem">用于CPU和GPU的Python代码</li><li class="listitem">CPU和GPU的C API</li><li class="listitem">与其他深度学习框架共享模型</li><li class="listitem">云GPU</li><li class="listitem">元学习、渐进学习和引导学习</li><li class="listitem">通用人工智能</li></ul></div><p class="calibre8">这一章给出了深度学习的完整概述。</p></div></body></html>


<html>
  <head>
    <title>Chapter 13. Extending Deep Learning with Theano</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch13lvl1sec108" class="calibre1"/>Python中的CPU运算</h1></div></div></div><p class="calibre8">作为一个<a id="id483" class="calibre1"/>数学编译引擎，Theano的目的是为目标平台以最佳方式编译计算图。</p><p class="calibre8">可以用Python或C开发新的运算符，以便在CPU或GPU上编译。</p><p class="calibre8">首先，我们处理最简单的情况，在Python for CPU中，这将使您能够非常容易和快速地添加新的操作。</p><p class="calibre8">为了修正<a id="id484" class="calibre1"/>的想法，让我们实现一个简单的仿射操作符，它执行仿射变换<em class="calibre12"> a * x + b </em>，给定x作为输入。</p><p class="calibre8">运算符由从通用<code class="email">theano.Op</code>类派生的类定义:</p><div><pre class="programlisting">
<strong class="calibre2">import</strong> theano, numpy

<strong class="calibre2">class</strong> AXPBOp(theano.Op):
    """
    This creates an Op that takes x to a*x+b.
    """
    __props__ = ("a", "b")

    <strong class="calibre2">def</strong> __init__(self, a, b):
        self.a = a
        self.b = b
        <strong class="calibre2">super</strong>(AXPBOp, self).__init__()

    <strong class="calibre2">def</strong> make_node(self, x):
        x = theano.tensor.as_tensor_variable(x)
        <strong class="calibre2">return</strong> theano.Apply(self, [x], [x.type()])

    <strong class="calibre2">def</strong> perform(self, node, inputs, output_storage):
        x = inputs[0]
        z = output_storage[0]
        z[0] = self.a * x + self.b

    <strong class="calibre2">def</strong> infer_shape(self, node, i0_shapes):
        <strong class="calibre2">return</strong> i0_shapes
    <strong class="calibre2">def</strong> grad(self, inputs, output_grads):
        <strong class="calibre2">return</strong> [self.a * output_grads[0]]

mult4plus5op = AXPBOp(4,5)

x = theano.tensor.matrix()
y = mult4plus5op(x)
f = theano.function([x], y)

res = f(numpy.random.rand(3,2))</pre></div><p class="calibre8">让我们来理解这个例子。</p><p class="calibre8"><code class="email">__props__</code>属性被设置为运算符依赖的两个参数名<code class="email">a</code>和<code class="email">b</code>。它会自动为我们生成<code class="email">__eq__()</code>、<code class="email">__hash__()</code>和<code class="email">__str_()</code>方法，这样如果我们用相同的参数<code class="email">a</code>和<code class="email">b</code>值创建两个不同的对象，那么ano会将它们视为相同的操作符:</p><div><pre class="programlisting">&gt;&gt;&gt; mult4plus5op2 = AXPBOp(4,5)

&gt;&gt;&gt; mult4plus5op == mult4plus5op2
True

&gt;&gt;&gt; hash(mult4plus5op)
-292944955210390262

&gt;&gt;&gt; hash(mult4plus5op2)
-292944955210390262</pre></div><p class="calibre8">另外，打印op时会出现<a id="id485" class="calibre1"/>参数<code class="email">a</code>和<code class="email">b</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; theano.printing.pprint(y)
AXPBOp{a=4, b=5}.0

&gt;&gt;&gt; theano.printing.pydotprint(y)</pre></div><div><img src="img/00267.jpeg" alt="Theano Op in Python for CPU" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">如果没有指定<code class="email">__props__</code>，则需要手动定义<code class="email">__eq__()</code>、<code class="email">__hash__()</code>和<code class="email">__str_()</code>方法。</p><p class="calibre8"><code class="email">make_node()</code>方法创建包含在图形中的节点，并在将<code class="email">mult4plus5op</code>对象应用于输入<code class="email">x</code>时运行。使用<code class="email">theano.Apply()</code>方法创建节点，该方法将输入变量和输出类型作为参数。为了确保输入是变量，对输入调用<code class="email">as_tensor_variable()</code>方法，将任何NumPy数组转换为变量。这是我们在给定输入的情况下定义输出类型的地方，也是检查输入是否与操作符兼容并在不兼容的情况下抛出TypeError的地方。</p><p class="calibre8">注意，可以自动生成<code class="email">make_node()</code>方法，就像我们之前对<code class="email">__eq__()</code>方法的<code class="email">__props__</code>属性所做的那样，但是在这种情况下，用<code class="email">itypes</code>和<code class="email">otypes</code>属性定义输入和输出的类型:</p><div><pre class="programlisting">itypes = [theano.tensor.dmatrix]
otypes = [theano.tensor.dmatrix]</pre></div><p class="calibre8"><code class="email">perform()</code>方法定义了Python中为这个操作符执行的计算。因为可以在返回多个输出的多个输入上实现运算符，所以输入和输出以列表的形式给出。第二个输出将存储在<code class="email">output_storage[1][0]</code>中。输出可能已经由先前的值<a id="id486" class="calibre1"/>分配，以便重新使用存储器。他们永远是好的目标，但不需要正确的形状和步幅。当它们的形状不好时，最好重新分配它们。</p><p class="calibre8">最后两种方法<code class="email">infer_shape()</code>和<code class="email">grad()</code>是可选的。当不需要计算输出，但只需要一个形状信息来执行计算时，使用第一种方法，这种情况发生在非优化过程中。第二种用于在<code class="email">grad()</code>方法下需要对输出进行微分时:</p><div><pre class="programlisting">&gt;&gt;&gt; dy=theano.tensor.grad(y.sum(), x)

&gt;&gt;&gt; theano.printing.pprint(dy)
'(TensorConstant{4} * fill(AXPBOp{a=4, b=5}(&lt;TensorType(float32, matrix)&gt;), fill(Sum{acc_dtype=float64}(AXPBOp{a=4, b=5}(&lt;TensorType(float32, matrix)&gt;)), TensorConstant{1.0})))'

&gt;&gt;&gt; df = theano.function([x], dy)

&gt;&gt;&gt; theano.printing.debugprint(df)
Alloc [id A] ''   2
 |TensorConstant{(1, 1) of 4.0} [id B]
 |Shape_i{0} [id C] ''   1
 | |&lt;TensorType(float32, matrix)&gt; [id D]
 |Shape_i{1} [id E] ''   0
   |&lt;TensorType(float32, matrix)&gt; [id D]</pre></div><p class="calibre8">同样的，也可以定义算子的R-算子函数。</p></div></div></body></html>


<html>
  <head>
    <title>Theano Op in Python for the GPU</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre"><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec109" class="calibre1"/>用于GPU的Python中的no操作</h1></div></div></div><p class="calibre8">让我们来看看在图形处理器<code class="email">config</code>模式下运行这个操作符会发生什么:</p><div><pre class="programlisting">&gt;&gt;&gt; y = mult4plus5op(2 * x) + 4 * x

&gt;&gt;&gt; f = theano.function([x], y)

&gt;&gt;&gt; theano.printing.debugprint(f)
HostFromGpu(gpuarray) [id A] ''   6
 |GpuElemwise{Composite{(i0 + (i1 * i2))}}[(0, 0)]&lt;gpuarray&gt; [id B] ''   5
   |GpuFromHost&lt;None&gt; [id C] ''   4
   | |AXPBOp{a=4, b=5} [id D] ''   3
   |   |HostFromGpu(gpuarray) [id E] ''   2
   |     |GpuElemwise{mul,no_inplace} [id F] ''   1
   |       |GpuArrayConstant{[[ 2.]]} [id G]
   |       |GpuFromHost&lt;None&gt; [id H] ''   0
   |         |&lt;TensorType(float32, matrix)&gt; [id I]
   |GpuArrayConstant{[[ 4.]]} [id J]
   |GpuFromHost&lt;None&gt; [id H] ''   0</pre></div><p class="calibre8">由于我们仅在Python中定义了new运算符的CPU实现，并且整个图形在GPU上运行，因此数据在图形中间来回传输到CPU，以应用我们的新CPU运算符:</p><div><img src="img/00268.jpeg" alt="Theano Op in Python for the GPU" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">为了避免图内传输的低效率，让我们用Python为GPU创建相同的操作符。</p><p class="calibre8">为此，您必须简单地修改<a id="id488" class="calibre1"/>操作符的<code class="email">make_node()</code>和<code class="email">perform()</code>方法，如下所示:</p><div><pre class="programlisting">
<strong class="calibre2">from</strong> theano.gpuarray.type <strong class="calibre2">import</strong> get_context

<strong class="calibre2">def</strong> make_node(self, x):
    x = as_gpuarray_variable(x, self.context_name)

    x_arg = pygpu.elemwise.arg('x', 'float32', <strong class="calibre2">read</strong>=True)
    c_arg = pygpu.elemwise.arg('c', 'float32', <strong class="calibre2">read</strong>=True, <strong class="calibre2">write</strong>=True)
    self.my_op = pygpu.elemwise.GpuElemwise(get_context(self.context_name), "c = " + str(self.a) + " * x + " + str(self.b), [x_arg, c_arg], <strong class="calibre2">convert_f16</strong>=True)

    <strong class="calibre2">return</strong> Apply(self, [x], [x.type()])


<strong class="calibre2">def</strong> perform(self, node, inputs, output_storage):
    x = inputs[0]
    z = output_storage[0]
    z[0] = pygpu.empty(x.shape, <strong class="calibre2">dtype</strong>=x.dtype, <strong class="calibre2">context</strong>=get_context(self.context_name))
    self.my_op( x, z[0])</pre></div><p class="calibre8">变化不大。</p><p class="calibre8">在<code class="email">make_node()</code>方法中，<code class="email">as_tensor_variable()</code>被替换为<code class="email">as_gpuarray_variable()</code>，这需要作为GPU变量类型定义一部分的上下文。<code class="email">get_context()</code>方法将我们为设备选择的上下文名称转换成<code class="email">pygpu</code>库的<code class="email">GPUContext</code>。</p><p class="calibre8">在<code class="email">perform()</code>方法中，由于<code class="email">pygpu</code>库<a id="id489" class="calibre1"/>包含GPU上的元素式<a id="id490" class="calibre1"/>运算符以及<strong class="calibre2">基本线性代数子程序</strong> ( <strong class="calibre2"> BLAS </strong>)方法，例如<strong class="calibre2">通用矩阵到矩阵乘法</strong> ( <strong class="calibre2"> GEMM </strong>)和<strong class="calibre2">通用矩阵到向量乘法</strong> ( <strong class="calibre2"> GEMV </strong>)运算，计算在GPU上执行。</p><p class="calibre8">现在让我们<a id="id491" class="calibre1"/>看看这个新运算符在GPU上的一个更大的图形中时编译的图形:</p><div><pre class="programlisting">HostFromGpu(gpuarray) [id A] ''   4
 |GpuElemwise{Add}[(0, 1)]&lt;gpuarray&gt; [id B] ''   3
   |GpuArrayConstant{[[ 4.]]} [id C]
   |GpuAXPBOp{a=4, b=5, context_name='dev0'} [id D] ''   2
     |GpuElemwise{Mul}[(0, 1)]&lt;gpuarray&gt; [id E] ''   1
       |GpuArrayConstant{[[ 2.]]} [id F]
       |GpuFromHost&lt;dev0&gt; [id G] ''   0
         |&lt;TensorType(float32, matrix)&gt; [id H]</pre></div><div><img src="img/00269.jpeg" alt="Theano Op in Python for the GPU" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">为了<a id="id492" class="calibre1"/>的可读性，我们在GPU的操作符的类名前加了GPU；比如GpuAXPBOp。</p></div></body></html>


<html>
  <head>
    <title>Theano Op in C for CPU</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre"><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec110" class="calibre1"/>CPU在C语言中的运算</h1></div></div></div><p class="calibre8">另一个效率低下的原因是，每次执行计算时，也就是说，对于图中操作符的每个实例，操作符的Python实现都会增加很大的开销。Python代码没有被C中的ano编译为图的其余部分，并且当C实现被包装到Python中并交换数据时，会产生开销。</p><p class="calibre8">为了补救这一点，可以直接编写一些C代码，将它们合并到图的其余部分的代码中，并一起编译。</p><p class="calibre8">在C中直接实现操作符时，NumPy是管理数组的底层库，NumPy-API扩展了Python C-API。定义新C操作符的Python类不必实现<code class="email">perform()</code>方法；相反，它返回<a id="id494" class="calibre1"/>C代码以合并到<code class="email">c_code()</code>、<code class="email">c_support_code()</code>和<code class="email">c_support_code_apply()</code>方法中:</p><div><pre class="programlisting">
<strong class="calibre2">def</strong> c_code_cache_version(self):
    <strong class="calibre2">return</strong> (6, 0)

<strong class="calibre2">def</strong> c_support_code(self):
    c_support_code = """
    <strong class="calibre2">bool</strong> same_shape(PyArrayObject* arr1, PyArrayObject* arr2)
    {
        if( PyArray_NDIM(arr1) != PyArray_NDIM(arr2)) {
            <strong class="calibre2">return</strong> false;
        }
        <strong class="calibre2">for</strong>(<strong class="calibre2">int</strong> i = 0; i &lt; PyArray_NDIM(arr2) ; i++) {
            <strong class="calibre2">if</strong> (PyArray_DIMS(arr1)[0] == PyArray_DIMS(arr2)[0]) {
                <strong class="calibre2">return</strong> false;
            }
        }
        <strong class="calibre2">return</strong> true;
    }
    """

    <strong class="calibre2">return</strong> c_support_code

<strong class="calibre2">def</strong> c_support_code_apply(self, node, name):
    dtype_x = node.inputs[0].dtype
    dtype_z = node.outputs[0].dtype

    a = self.a
    b = self.b

    c_support_code = """
    <strong class="calibre2">void</strong> elemwise_op_%(name)s(npy_%(dtype_x)s* x_ptr, npy_intp* x_str, int itemsize_x,
        npy_%(dtype_z)s* z_ptr, npy_intp* z_str, int itemsize_z,
        int nbDims, npy_intp* dims)
    {
        npy_intp stride_x = (npy_intp)(1);
        npy_intp stride_z = (npy_intp)(1);
        <strong class="calibre2">for</strong> (<strong class="calibre2">int</strong> i = 0; i &lt; nbDims; i ++) {
            stride_x = stride_x * x_str[i] / itemsize_x;
            stride_z = stride_z * z_str[i] / itemsize_z;
        }
        <strong class="calibre2">for</strong> (int i=0; i &lt; dims[0]; i++)
            <strong class="calibre2">if</strong> (nbDims==1) {
                z_ptr[i * z_str[0]/itemsize_z] = x_ptr[i * x_str[0] / itemsize_x] * ((npy_%(dtype_z)s) %(a)s) + ((npy_%(dtype_z)s)%(b)s);
            } <strong class="calibre2">else</strong> {
                elemwise_op_%(name)s( x_ptr + i * stride_x , x_str + 1, itemsize_x,
                    z_ptr + i * stride_z , z_str + 1, itemsize_z,
                    nbDims - 1, dims + 1 );
            }
    }
    """

    <strong class="calibre2">return</strong> c_support_code % locals()

<strong class="calibre2">def</strong> c_code(self, node, name, inp, out, sub):
    x = inp[0]
    z = out[0]

    dtype_x = node.inputs[0].dtype
    dtype_z = node.outputs[0].dtype

    itemsize_x = numpy.dtype(dtype_x).itemsize
    itemsize_z = numpy.dtype(dtype_z).itemsize

    typenum_z = numpy.dtype(dtype_z).num

    fail = sub['fail']

    c_code = """
    // Validate that the output storage exists and has the same
    // dimension as x.
    <strong class="calibre2">if</strong> (NULL <strong class="calibre2">==</strong> %(z)s <strong class="calibre2">||</strong> !(same_shape(%(x)s, %(z)s)))
    {
        /* Reference received to invalid output variable.
        Decrease received reference's ref count and allocate new
        output variable */
        Py_XDECREF(%(z)s);
        %(z)s = (PyArrayObject*)PyArray_EMPTY(PyArray_NDIM(%(x)s),
                                            PyArray_DIMS(%(x)s),
                                            %(typenum_z)s,
                                            0);

        <strong class="calibre2">if</strong> (!%(z)s) {
            %(fail)s;
        }
    }

    // Perform the elemwise operation
    ((npy_%(dtype_z)s *)PyArray_DATA(%(z)s))[0] = 0;
    elemwise_op_%(name)s((npy_%(dtype_x)s*)PyArray_DATA(%(x)s), PyArray_STRIDES(%(x)s), %(itemsize_x)s,
                            (npy_%(dtype_z)s*)PyArray_DATA(%(z)s), PyArray_STRIDES(%(z)s), %(itemsize_z)s,
                            PyArray_NDIM(%(x)s), PyArray_DIMS(%(x)s) );

    """

    <strong class="calibre2">return</strong> c_code % locals()</pre></div><p class="calibre8">现在让我们讨论不同的部分:</p><p class="calibre8">当<code class="email">c_code_cache_version()</code>被实现时，Theano将缓存编译后的代码，以便在下一次将操作符合并到图中时节省一些编译时间，但是每当我们修改C op的代码时，版本号都必须递增。</p><p class="calibre8">放置在<code class="email">c_support_code()</code>和<code class="email">c_support_code_apply()</code>方法中的<a id="id495" class="calibre1"/>代码包含在C程序的全局范围内。放置在<code class="email">c_support_code_apply()</code>和<code class="email">c_code()</code>方法中的代码必须特定于图中op的每次应用；特别是，在这种情况下，它们取决于输入的类型。由于<code class="email">c_support_code_apply()</code>代码包含在全局范围内，所以这些方法以op名命名。</p><p class="calibre8"><code class="email">PyArray_NDIM</code>、<code class="email">PyArray_DIMS</code>、<code class="email">PyArray_STRIDES</code>、<code class="email">PyArray_DATA</code>分别是访问C中每个NumPy数组的维数、维数、数组的步距、数组中的数据的宏，<code class="email">PyArrayObject</code>。<code class="email">PyArray_EMPTY</code>相当于c语言中的Python <code class="email">numpy.empty()</code>方法。</p><p class="calibre8">NumPy <code class="email">PyArrayObject</code>类从Python C-API的<code class="email">PyObject</code>类继承而来。在为新的输出数组分配内存之前，<code class="email">Py_XDECREF</code>宏使我们能够减少输出的参考计数。与Python C-API一样，NumPy C-API要求正确计算对对象的引用。该方法不保证输出数组已被分配，也不保证它是否以正确的形状被分配。这就是为什么在<code class="email">c_code()</code>开始时执行测试。</p><p class="calibre8">请注意，数组可以被划分，因为它们可以是数组(张量)的视图(或子张量)。也可以实现创建视图或修改输入的操作。</p><p class="calibre8">在C实现中还有一些其他可能的方法:<code class="email">c_libraries()</code>和<code class="email">c_lib_dirs()</code>使用外部库，<code class="email">c_code_cleanup()</code>销毁内存分配，<code class="email">c_init_code()</code>在初始化时执行一些代码。</p><p class="calibre8">最后，还可以在代码中引用一些C文件来减轻<a id="id496" class="calibre1"/> Python类的负担。我们不详述这最后三个特性。</p></div></body></html>


<html>
  <head>
    <title>Theano Op in C for GPU</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre"><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec111" class="calibre1"/>面向GPU的C语言中的操作码</h1></div></div></div><p class="calibre8">正如您所想象的，结合两种优化是可能的:</p><div><ul class="itemizedlist"><li class="listitem">通过直接用C编程来减少Python/C的开销</li><li class="listitem">为GPU写代码</li></ul></div><p class="calibre8">要为GPU编写CUDA代码，必须将在GPU的众多内核<a id="id498" class="calibre1"/>上并行运行的代码打包成一个名为<strong class="calibre2">内核</strong>的特殊函数类型。</p><p class="calibre8">出于这个目的，<code class="email">__init__()</code>、<code class="email">make_node()</code>和<code class="email">c_code_cache_version()</code>方法与我们的Python示例中的GPU保持一致，但是使用了一个新的<code class="email">gpu_kernels()</code>方法来定义新的GPU内核，使用了<code class="email">c_code()</code>方法(再次取代了<code class="email">perform()</code>方法)来实现C代码，也称为<strong class="calibre2">宿主代码</strong>，它协调了如何以及何时调用GPU上的不同内核:</p><div><pre class="programlisting">
<strong class="calibre2">def</strong> gpu_kernels(self, node, name):
    code = """
KERNEL <strong class="calibre2">void</strong> axpb(GLOBAL_MEM %(ctype)s *x, GLOBAL_MEM  %(ctype)s *z, ga_size n, ga_size m) {
<strong class="calibre2">for</strong> (ga_size i = LID_0; i &lt; n; i += LDIM_0) {
    <strong class="calibre2">for</strong> (ga_size j = LID_0; j &lt; m; j += LDIM_0) {
        z[i*m + j] = %(write_a)s( 2 * x[i*m + j] );
    }
}
}""" % <strong class="calibre2">dict</strong>(<strong class="calibre2">ctype</strong>=pygpu.gpuarray.dtype_to_ctype(self.dtype),
        <strong class="calibre2">name</strong>=name, <strong class="calibre2">write_a</strong>=write_w(self.dtype))
    <strong class="calibre2">return</strong> [Kernel(
            <strong class="calibre2">code</strong>=code, name="axpb",
            <strong class="calibre2">params</strong>=[gpuarray.GpuArray, gpuarray.GpuArray, gpuarray.SIZE, gpuarray.SIZE],
            <strong class="calibre2">flags</strong>=Kernel.get_flags(self.dtype),
            <strong class="calibre2">objvar</strong>='k_axpb_' + name)]

<strong class="calibre2">def</strong> c_code(self, node, name, inp, out, sub):
    n, = inp
    z, = out
    dtype_n = node.inputs[0].dtype
    fail = sub['fail']
    ctx = sub['params']
    typecode = pygpu.gpuarray.dtype_to_typecode(self.dtype)
    sync = bool(config.gpuarray.sync)
    kname = self.gpu_kernels(node, name)[0].objvar
    s = """
    size_t dims[2] = {0, 0};
    size_t ls, gs;
    int err;
    dims[0] = %(n)s-&gt;ga.dimensions[0];
    dims[1] = %(n)s-&gt;ga.dimensions[1];
    Py_CLEAR(%(z)s);
    %(z)s = pygpu_zeros(2, dims,
                        %(typecode)s,
                        GA_C_ORDER,
                        %(ctx)s, Py_None);
    <strong class="calibre2">if</strong> (%(z)s == NULL) {
        %(fail)s
    }
    ls = 1;
    gs = 256;
    err = axpb_call(1, &amp;gs, &amp;ls, 0, %(n)s-&gt;ga.data, %(z)s-&gt;ga.data, dims[0], dims[1]);
    <strong class="calibre2">if</strong> (err <strong class="calibre2">!=</strong> GA_NO_ERROR) {
        PyErr_Format(PyExc_RuntimeError,
                     "gpuarray error: kEye: %%s. n%%lu, m=%%lu.",
                     GpuKernel_error(&amp;%(kname)s, err),
                     (unsigned long)dims[0], (unsigned long)dims[1]);
        %(fail)s;
    }
    <strong class="calibre2">if</strong>(%(sync)d)
        GpuArray_sync(&amp;%(z)s-&gt;ga);
    """ % locals()

    <strong class="calibre2">return</strong> s</pre></div><pre>A new <a id="id500" class="calibre1"/>GPU computation kernel is defined under the name <code class="email">axpb</code>, and it is a simple C code with special GPU types and two macros: <code class="email">KERNEL</code> to designate the kernel function (hiding the CUDA <code class="email">__global__</code> declaration for kernels) and <code class="email">GLOBAL_MEM</code> for the variables defined globally, available both on the CPU and the GPU (in opposition to variables inside the kernel function that, by default, are local to the thread executed on a GPU core).</pre><p class="calibre8">请注意，我只为矩阵(即二维)输入实现了操作符，256个线程将并行执行相同的操作，而这些操作可以被分成不同的组并分配给不同的线程。</p><p class="calibre8">运行在CPU上的主机代码管理CPU和GPU上的内存，并且还启动内核，这些内核是在GPU设备上执行的功能。</p><p class="calibre8">使用<code class="email">pygpu_zeros()</code>方法执行新GPU数组的<a id="id501" class="calibre1"/>分配，当使用CUDA直接在GPU内存中分配数组时，该方法将从后面调用<code class="email">cudamalloc()</code>方法。运算符实例不需要管理分配给输出的内存的释放以及GPU和CPU之间的数据传输，因为这是ano optimization决定何时插入传输运算符<code class="email">HostFromGpu</code>和<code class="email">GpuFromHost</code>的任务。</p><p class="calibre8">C代码中对内核的调用是通过<code class="email">axpb_call()</code>来执行的，也就是内核的名字后跟<code class="email">_call()</code>。请注意，调用中的参数比内核方法定义中的多四个。这四个参数定义了<code class="email">libgpuarray</code>如何在内核上执行或部署内核。</p><p class="calibre8">为了理解并行编程的GPU执行配置，让我们先明确一些关于GPU的基本概念。CUDA GPU由<strong class="calibre2">流式多处理器</strong> ( <strong class="calibre2"> SM </strong>)组成，规格由warp大小、网格大小、块大小、每个SM和每个块的最大线程数量、共享和本地内存大小以及最大注册器数量的计算能力给出:</p><div><img src="img/00270.jpeg" alt="Theano Op in C for GPU" class="calibre9"/><div><p class="calibre29">(来源:<a class="calibre1" href="https://en.wikipedia.org/wiki/CUDA">https://en.wikipedia.org/wiki/CUDA</a>)</p></div></div><p class="calibre10">在执行过程中，多处理器以<strong class="calibre2">单指令多数据</strong> ( <strong class="calibre2"> SIMD </strong>)方式为一组32个线程(如上表<a id="id503" class="calibre1"/>所述)执行指令，称为warp。当对<a id="id504" class="calibre1"/>进行并行执行编程时，您需要将您的线程组织成尽可能接近底层架构的块。例如，对于矩阵上的元素操作，如我们的AXPBOp，你可以说每个线程将对矩阵的一个元素执行操作。因此，对224 x 224图像的计算将需要50，176个线程。假设GPU有8个多处理器，每个处理器有1024个内核。例如，在执行配置中，您可以定义256个线程的块大小，执行完整计算所需的块数将是196个块。为了简化并行程序的开发，可以将块组织成多维网格(对于2.0以上的CC，多达3个维度，如上表所示)，对于图像输入，使用14 x 14块的二维网格是很自然的。将线程组织成网格上的块取决于您，但是组织线程的最佳方式是遵循底层数据的维度，因为这样更容易将数据分割并影响到不同的线程。</p><p class="calibre8">每个线程执行都提供了一些值来访问它在网格中的位置，您可以在代码中使用这些值:</p><p class="calibre8"><code class="email">gridDim.x</code>、<code class="email">gridDim.y</code>、<code class="email">gridDim.z</code>线块网格的尺寸</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">blockIdx.x</code>、<code class="email">blockIdx.y</code>、<code class="email">blockIdx.z</code>网格上图块的坐标</li><li class="listitem"><code class="email">blockDim.x</code>、<code class="email">blockDim.y</code>、<code class="email">blockDim.z</code>垫块的尺寸</li><li class="listitem"><code class="email">threadIdx.x</code>、<code class="email">threadIdx.y</code>、<code class="email">threadIdx.z</code>块中螺纹的坐标</li><li class="listitem">在我们的基于元素的AXPBOp中，每个元素有一个线程，线程可以获取由以下行索引给出的数据元素:</li></ul></div><p class="calibre8">为了进行部署，内核调用中的前四个新参数对应于:</p><div><pre class="programlisting">int i = blockIdx.x*blockDim.x + threadIdx.x;</pre></div><p class="calibre8">网格/块的维数，在这种情况下，作为输入的图像/矩阵的维数为2</p><div><ul class="itemizedlist"><li class="listitem">在这种情况下，发射网格的大小是{14，14}。一旦定义了每个块的线程数(在我们的例子中是256)，每个网格的块数就由问题的大小(这里是矩阵的大小)决定了。</li><li class="listitem">启动块的大小，在本例中为{16，16}，每个块有256个线程，因为它通常被设置为128或256。最好选择扭曲大小的倍数，因为执行是按扭曲执行的；如果你将它设置为250，那么，我们的201个块将表现不佳:每个块的一个扭曲将不会被使用到它的全部并行潜力。可以尝试32的不同倍数，并选择最有效的运行。</li><li class="listitem">The sizes of launch blocks, in this case {16, 16} to go for 256 threads per block, as it is usually set to 128 or 256. It is better to choose a multiple of the warp size, since execution is performed per warp; if you set it to 250, then, 201 of our blocks will underperform: one warp of each block will not be used at its full parallel potential. It is possible to try different multiples of 32 and make the choice on the most efficient runs.</li><li class="listitem">The amount of dynamic shared memory to allocate, which is required when you define a shared memory (with the <code class="email">LOCAL_MEM</code> macro) that is dynamic (when the amount of shared memory is not known at compile time). Shared memory designates memory shared between <a id="id505" class="calibre1"/>threads belonging to the same block of threads. On devices of compute capability 2.x and 3.x, each multiprocessor has 64 KB of on-chip memory that can be partitioned between L1 cache and shared memory (16, 32, or 48K). The L1 cache coalesces global memory accesses by threads in a warp into as few cache lines as possible. The alignment differences between each thread have a negligible effect on performance thanks to the cache. Inefficiencies arise in the strided access for second and third dimensions; in this case, the use of shared memory enables you to extract a 2D tile of a multidimensional array from global memory in a coalesced fashion into shared memory and have contiguous threads stride through the shared memory tile:<div><img src="img/00271.jpeg" alt="Theano Op in C for GPU" class="calibre9"/></div><p class="calibre27"><a id="ch13lvl1sec112" class="calibre1"/>通过共享内存合并转置，所有NVIDIA并行</p></li></ul></div></div></body></html>


<html>
  <head>
    <title>Coalesced transpose via shared memory, NVIDIA parallel for all</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">当数据的<a id="id506" class="calibre1"/>维不可分为块大小乘以网格大小时，在边界处理数据的线程将比其他线程执行<a id="id507" class="calibre1"/>更快，内核代码必须以检查越界内存访问的方式编写。</h1></div></div></div><p class="calibre8">当并行编程时，竞争条件、共享内存中的内存块冲突以及无法在可用注册器中保持线程本地状态的数据是一些需要检查的新问题。合并全局内存访问是实现良好性能的最关键的方面。NVIDIA Nsight工具将帮助您开发、调试和分析在CPU和GPU上执行<a id="id509" class="calibre1"/>的代码。</p><p class="calibre8"><a id="ch13lvl2sec31" class="calibre1"/>型号转换</p></div></body></html>


<html>
  <head>
    <title>Coalesced transpose via shared memory, NVIDIA parallel for all</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">当保存一个<a id="id510" class="calibre1"/>模型时，产生的数据只是一个数组列表，即权重向量(用于偏差)和矩阵(用于乘法)以及每一层的名称。将一个模型从一个框架转换到另一个框架非常简单:它包括加载一个数字数组和检查层名。下面是几个用C++编写的Caffe深度学习框架的相互转换示例:</h2></div></div></div><p class="calibre8"><a class="calibre1" href="https://github.com/an-kumar/caffe-theano-conversion">https://github.com/an-kumar/caffe-theano-conversion</a></p><div><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="https://github.com/kencoken/caffe-model-convert">https://github.com/kencoken/caffe-model-convert</a></li><li class="listitem"><a class="calibre1" href="https://github.com/piergiaj/caffe-to-theano">https://github.com/piergiaj/caffe-to-theano</a></li><li class="listitem">要在Torch深度学习框架(用Lua编写)和Theano之间转换变量，只需要一个工具就可以将数据从Lua转换到Python NumPy:</li></ul></div><p class="calibre8"><a class="calibre1" href="https://github.com/imodpasteur/lutorpy">https://github.com/imodpasteur/lutorpy</a></p><p class="calibre8">要在Tensorflow和Theano之间转换模型，我建议您使用Keras库，该库将保持最新，并能够在Theano或Tensorflow中训练模型。例如，要将一个模型从Tensorflow转换为Theano，保持您的Keras安装配置有Theano，如我们在<a class="calibre1" title="Chapter 5. Analyzing Sentiment with a Bidirectional LSTM" href="part0060_split_000.html#1P71O2-ccdadb29edc54339afcb9bdf9350ba6b">第5章</a>、<em class="calibre12">使用双向LSTM </em>分析情绪中所见，加载Tensorflow权重，并修改图层名称如下:</p><p class="calibre8">镜像操作序列使我们能够反其道而行之，从无到张量流。</p><div><pre class="programlisting">
<strong class="calibre2">from</strong> keras <strong class="calibre2">import</strong> backend <strong class="calibre2">as</strong> K
<strong class="calibre2">from</strong> keras.utils.conv_utils <strong class="calibre2">import</strong> convert_kernel
<strong class="calibre2">from</strong> keras.models <strong class="calibre2">import</strong> Model

# build your Keras model HERE
# then
model.load_weights('my_weights_tensorflow.h5')

<strong class="calibre2">for</strong> layer <strong class="calibre2">in</strong> model.layers:
   <strong class="calibre2">if</strong> layer.__class__.__name__ <strong class="calibre2">in</strong> ['Convolution1D', 'Convolution2D']:
      original_w = K.get_value(layer.W)
      converted_w = convert_kernel(original_w)
      K.set_value(layer.W, converted_w)

model.save_weights('my_weights_theano.h5')</pre></div><p class="calibre8">在Keras中设计网络的另一个<a id="id511" class="calibre1"/>优势是可以直接在云中训练它们，使用谷歌云<a id="id512" class="calibre1"/>机器学习引擎，用<strong class="calibre2">张量处理单元</strong> ( <strong class="calibre2"> TPU </strong>)构建，这是GPU的替代物，是为机器学习而设计的。</p><p class="calibre8">让我们以<a class="calibre1" title="Chapter 5. Analyzing Sentiment with a Bidirectional LSTM" href="part0060_split_000.html#1P71O2-ccdadb29edc54339afcb9bdf9350ba6b">第5章</a>、<em class="calibre12">用双向LSTM </em>分析情感为例。</p><p class="calibre8">为了在云中训练模型，我在谷歌控制台<a class="calibre1" href="https://console.cloud.google.com/iam-admin/projects">https://console.cloud.google.com/iam-admin/projects</a>中创建了一个名为<em class="calibre12"> DeepLearning Theano </em>的项目，并在该项目的API管理器中，启用机器学习引擎API。一些安装需求可以通过以下网址的说明进行检查:<a class="calibre1" href="https://cloud.google.com/ml-engine/docs/quickstarts/command-line">https://Cloud . Google . com/ml-engine/docs/quick starts/command-line</a>，比如Google Cloud SDK和项目配置。使用<code class="email">gcloud</code> <code class="email">init</code>命令，您的SDK配置可以重新初始化，以切换到<em class="calibre12">deep learning the no</em>项目。</p><p class="calibre8">给定您选择的地区(这里是<code class="email">europe-west1</code>)，让我们将数据上传到云中一个新创建的桶中:</p><p class="calibre8">由于模型是在云中的实例上执行的，因此需要:</p><div><pre class="programlisting">
<strong class="calibre2">gsutil</strong> mb -l europe-west1 gs://keras_sentiment_analysis
<strong class="calibre2">gsutil</strong> cp -r sem_eval2103.train gs://keras_sentiment_analysis/sem_eval2103.train
<strong class="calibre2">gsutil</strong> cp -r sem_eval2103.dev gs://keras_sentiment_analysis/sem_eval2103.dev
<strong class="calibre2">gsutil</strong> cp -r sem_eval2103.test gs://keras_sentiment_analysis/sem_eval2103.test</pre></div><p class="calibre8">修改Python脚本，从远程存储桶而不是本地目录加载文件流，使用库<code class="email">tensorflow.python.lib.io.file_io.FileIO(train_file, mode='r') </code>而不是标准方法<code class="email">open(train_file, mode='r')</code>，两者的模式参数用法相同，“r”表示读取，<code class="email">w</code>表示写入，</p><div><ul class="itemizedlist"><li class="listitem">定义一个<code class="email">setup.py</code>文件来配置云实例环境中需要的库:<div> <pre class="programlisting"> <strong class="calibre2">from</strong> setuptools <strong class="calibre2">import</strong> setup, find_packages  setup(<strong class="calibre2">name</strong>='example5',   <strong class="calibre2">version</strong>='0.1',   <strong class="calibre2">packages</strong>=find_packages(),   <strong class="calibre2">description</strong>='keras on gcloud ml-engine',   <strong class="calibre2">install_requires</strong>=[       'keras',       'h5py',       'nltk'   ],   <strong class="calibre2">zip_safe</strong>=False)</pre> </div></li><li class="listitem">定义云部署配置文件，<code class="email">cloudml-gpu.yaml</code> : <div> <pre class="programlisting">  trainingInput:     scaleTier: CUSTOM     # standard_gpu provides 1 GPU. Change to complex_model_m_gpu for 4 GPUs     masterType: standard_gpu     runtimeVersion: "1.0"</pre> </div></li><li class="listitem">在将培训提交到Google ML Cloud之前，要在本地检查其工作情况，请运行以下命令:</li></ul></div><p class="calibre8">如果本地一切正常，那么让我们把它提交给云:</p><div><pre class="programlisting">
<strong class="calibre2">gcloud</strong> ml-engine local train --module-name 7-google-cloud.bilstm \
  --package-path ./7-google-cloud  -- --job-dir ./7-google-cloud \
  -t sem_eval2103.train -d sem_eval2103.dev -v sem_eval2103.test</pre></div><p class="calibre8">If everything works fine locally, let's submit it to the cloud:</p><div><pre class="programlisting">JOB_NAME="keras_sentiment_analysis_train_$(date +%Y%m%d_%H%M%S)"

<strong class="calibre2">gcloud</strong> ml-engine jobs submit training $JOB_NAME \
          --job-dir gs://keras_sentiment_analysis/$JOB_NAME \
          --runtime-version 1.0 \
          --module-name 7-google-cloud.bilstm  \
          --package-path ./7-google-cloud \
          --region europe-west1 \
          --config=7-google-cloud/cloudml-gpu.yaml \
          -- \
          -t gs://keras_sentiment_analysis/sem_eval2103.train \
          -d gs://keras_sentiment_analysis/sem_eval2103.dev \
          -v gs://keras_sentiment_analysis/sem_eval2103.test

<strong class="calibre2">gcloud</strong> ml-engine jobs describe $JOB_NAME</pre></div><div><img src="img/00272.jpeg" alt="Model conversions" class="calibre9"/></div><p class="calibre10"><a id="note07" class="calibre1"/>注意</p><div><h3 class="title2">注意Google ML Cloud使用Tensorflow作为后端。</h3><p class="calibre8"><a id="ch13lvl1sec113" class="calibre1"/>人工智能的未来</p></div></div></div></body></html>


<html>
  <head>
    <title>The future of artificial intelligence</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre"><div><div><div><div><h1 class="title" id="calibre_pb_0"><a class="calibre1" title="Chapter 2. Classifying Handwritten Digits with a Feedforward Network" href="part0026_split_000.html#OPEK1-ccdadb29edc54339afcb9bdf9350ba6b">第2章</a>、<em class="calibre12">用前馈网络对手写数字进行分类</em>介绍了各种<a id="id514" class="calibre1"/>优化技术(Adam、RMSProp等)并提到了二阶优化技术。概括来说，也要学习更新规则:</h1></div></div></div><p class="calibre8">
<a class="calibre1" title="Chapter 2. Classifying Handwritten Digits with a Feedforward Network" href="part0026_split_000.html#OPEK1-ccdadb29edc54339afcb9bdf9350ba6b">Chapter 2</a>, <em class="calibre12">Classifying Handwritten Digits with a Feedforward Network</em> presented diverse <a id="id514" class="calibre1"/>optimization techniques (Adam, RMSProp, and so on) and mentioned second order optimization techniques. A generalization would be to also learn the update rule:</p><div><img src="img/00273.jpeg" alt="The future of artificial intelligence" class="calibre9"/></div><p class="calibre10">这里，<img src="img/00274.jpeg" alt="The future of artificial intelligence" class="calibre23"/>是优化器<img src="img/00275.jpeg" alt="The future of artificial intelligence" class="calibre23"/>从不同问题实例中学习的参数，一种<em class="calibre12">泛化</em>或<em class="calibre12">转移优化器从问题中学习</em>以更好地学习新问题。在此<em class="calibre12">学习学习</em>或<em class="calibre12">元学习</em>框架下最小化的目标必须优化正确学习的时间，因此，在多个时间步长上定义:</p><p class="calibre8">Here, <img src="img/00274.jpeg" alt="The future of artificial intelligence" class="calibre23"/> is the parameter of the optimizer <img src="img/00275.jpeg" alt="The future of artificial intelligence" class="calibre23"/> to learn from different problem instances, a sort of <em class="calibre12">generalization</em> or <em class="calibre12">transfer learning</em> of the optimizer from problems to learn better on new problems. The objective to minimize under this <em class="calibre12">learning to learn</em> or <em class="calibre12">meta-learning</em> framework has to optimize the time to learn correctly and, consequently, be defined on multiple timesteps:</p><div><img src="img/00276.jpeg" alt="The future of artificial intelligence" class="calibre9"/></div><p class="calibre10">其中:</p><p class="calibre8">Where:</p><div><img src="img/00277.jpeg" alt="The future of artificial intelligence" class="calibre9"/></div><p class="calibre10">递归神经网络可用作优化器模型<img src="img/00275.jpeg" alt="The future of artificial intelligence" class="calibre23"/>。这种解决多目标优化问题的泛化技术总体上提高了神经网络的学习速率。</p><p class="calibre8">研究人员<a id="id515" class="calibre1"/>已经向前看了一步，寻找通用人工智能，其目标是建立一个人类水平的技能集，有能力以渐进的方式改善自己并获得新技能，使用其<strong class="calibre2">固有的</strong>和以前学习的技能来寻找新优化问题的解决方案。</p><p class="calibre8">一项<strong class="calibre2">技能</strong>可以被定义为一种智能工具，用来缩小或限制搜索空间，并限制机器人在无限可能性世界中的行为。</p><p class="calibre8">构建一个<strong class="calibre2">通用人工智能</strong>需要你定义具有内在技能的智能架构，这将由程序员硬编码到机器人中，并帮助解决更小的子问题，以及定义获得新技能的顺序，可以在人工智能的<strong class="calibre2">学校中教授的<strong class="calibre2">课程路线图</strong>。<strong class="calibre2">渐进学习</strong>使用更简单的技能逐渐学习技能，而<strong class="calibre2">引导式学习</strong>涉及到一个已经发现技能并将它们教给其他人工智能的老师。</strong></p><p class="calibre8">在自然语言翻译任务中，较小的网络已经被证明可以从较大的网络中学习得更快更好，较大的网络是<em class="calibre12"> mentor </em>，它可以学习翻译并产生供较小网络学习的翻译，而不是直接从一组真实的人工翻译中学习。</p><p class="calibre8">On natural language translation tasks, smaller networks have been proven to learn faster and better from a bigger network, the <em class="calibre12">mentor</em>, which would have learned to translate and produce the translations for the smaller network to learn from, rather than learning directly from a real set of human translations.</p><div><img src="img/00278.jpeg" alt="The future of artificial intelligence" class="calibre9"/></div><p class="calibre10">上图代表GoodAI Roadmap Institute评估AI的学习路线图。</p><p class="calibre8">自我探索、与导师交流以及整合积极和消极的<a id="id516" class="calibre1"/>反馈是自主智能自我发展的想法之一，当前的深度学习网络为这一未来开辟了道路。</p><p class="calibre8">在朝着这一目标努力的公司中，值得一提的是GoodAI，以及亚马逊的Echo产品和底层语音控制助理技术Alexa，它已经学会了10，000多种技能，以帮助你组织你的生活。Alexa的知识已经变得如此庞大，以至于很难深入其中并找到它的局限性。开发人员的测试环境使他们能够将这些技能插入到更高层次的智能工具中:</p><p class="calibre8">Among the companies that work toward this goal, it would be worth to quote GoodAI, as well as Amazon with its Echo product and the underlying voice control assistant technology, Alexa, that has already learned more than 10,000 skills in order to help you organize your life. Alexa's knowledge has become so vast that it becomes hard to dive deep into it and find its limitations. A test environment for developers enables them to insert <a id="id517" class="calibre1"/>these skills into intelligence tools of higher level:</p><div><img src="img/00279.jpeg" alt="The future of artificial intelligence" class="calibre9"/></div><p class="calibre10"><a id="ch13lvl1sec114" class="calibre1"/>延伸阅读</p></div></body></html>


<html>
  <head>
    <title>Further reading</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre"><div><div><div><div><h1 class="title" id="calibre_pb_0">可以参考以下文章了解更多:</h1></div></div></div><p class="calibre8"><em class="calibre12">安E</em>T22】asy CUDA C和C++ ，<a class="calibre1" href="https://devblogs.nvidia.com/parallelforall/easy-introduction-cuda-c-and-c/">https://dev blogs . NVIDIA . com/parallel forall/easy-Introduction-CUDA-C-and-C/</a></p><div><ul class="itemizedlist"><li class="listitem"><em class="calibre12">如何在CUDA C/C++内核中高效访问全局内存</em><em class="calibre12"/>，<a class="calibre1" href="https://devblogs.nvidia.com/parallelforall/how-access-global-memory-efficiently-cuda-c-kernels/">https://dev blogs . NVIDIA . com/parallel forall/How-Access-Global-Memory-efficient-CUDA-C-Kernels/</a></li><li class="listitem"><em class="calibre12">在CUDA C/C++中使用共享内存</em>，<a class="calibre1" href="https://devblogs.nvidia.com/parallelforall/using-shared-memory-cuda-cc/">https://dev blogs . NVIDIA . com/parallel forall/Using-Shared-Memory-CUDA-cc/</a></li><li class="listitem"><em class="calibre12"> Just another Tensorflow初学者指南(Par</em><em class="calibre12">T4-Google Cloud ML+GUP+Keras)</em><a class="calibre1" href="http://liufuyang.github.io/2017/04/02/just-another-tensorflow-beginner-guide-4.html">http://Liu Fuyang . github . io/2017/04/02/Just-another-tensor flow-初学者指南-4.html </a></li><li class="listitem">学习如何通过梯度下降来学习，Marcin Andrychowicz，Misha Denil，Sergio Gomez，Matthew W. Hoffman，大卫·普法乌，Tom Schaul，Brendan Shillingford和Nando de Freitas，2016年</li><li class="listitem">搜索通用人工智能的框架，Marek Rosa和Jan Feyereisl，GoodAI Collective，2016年</li><li class="listitem"><a id="ch13lvl1sec115" class="calibre1"/>总结</li></ul></div></div></body></html>


<html>
  <head>
    <title>Summary</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre"><div><div><div><div><h1 class="title" id="calibre_pb_0">这一章总结了我们对深度学习的概述。</h1></div></div></div><p class="calibre8">在Python和C中为CPU和GPU的第一组Theano扩展已经在这里公开，为计算图创建新的操作符。</p><p class="calibre8">将学习到的模型从一个框架转换到另一个框架并不是一项复杂的任务。Keras是一个高级库，在本书中多次出现，作为Theano引擎之上的抽象，它提供了一种简单的方法来使用Theano和Tensorflow，以及在Google ML云中推动模型的训练。</p><p class="calibre8">最后，本书中介绍的所有网络都是普通智能的基础，普通智能可以使用这些第一技能，如视觉或语言理解和生成，来学习更广泛的技能，仍然是从现实世界数据或生成的数据中获得的经验。</p><p class="calibre8">索引</p></div></body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div/><div><h1 class="title" id="calibre_pb_0">A</h1>
      <h2 class="calibre30">AdaDelta / <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></h2>
      <ul class="itemizedlist"><li class="listitem">Adagrad / <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li>
        <li class="listitem">亚当/ <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li>
        <li class="listitem">AlphaGo / <a title="Q-learning" class="calibre1" href="part0106.html#352RK2-ccdadb29edc54339afcb9bdf9350ba6b"> Q-learning </a></li>
        <li class="listitem">类比推理/ <a title="Evaluating embeddings – analogical reasoning" class="calibre1" href="part0045.html#1AT9A2-ccdadb29edc54339afcb9bdf9350ba6b">评估嵌入——类比推理</a></li>
        <li class="listitem">体系结构</li>
        <li class="listitem">设计，用于模型/ <a title="Designing the architecture for the model" class="calibre1" href="part0062_split_000.html#1R42S2-ccdadb29edc54339afcb9bdf9350ba6b">设计模型的架构</a><ul class="itemizedlist1"><li class="listitem">词语的矢量表示法/ <a title="Vector representations of words" class="calibre1" href="part0062_split_000.html#1R42S2-ccdadb29edc54339afcb9bdf9350ba6b">词语的矢量表示法</a></li><li class="listitem">句子表征，使用bi-LSTM / <a title="Sentence representation using bi-LSTM" class="calibre1" href="part0062_split_000.html#1R42S2-ccdadb29edc54339afcb9bdf9350ba6b">句子表征使用bi-LSTM </a></li><li class="listitem">用softmax分类器输出概率/ <a title="Outputting probabilities with the softmax classifier" class="calibre1" href="part0062_split_000.html#1R42S2-ccdadb29edc54339afcb9bdf9350ba6b">用softmax分类器输出概率</a></li><li class="listitem">人工智能</li></ul></li>
        <li class="listitem">未来/ <a title="The future of artificial intelligence" class="calibre1" href="part0121.html#3JCK21-ccdadb29edc54339afcb9bdf9350ba6b">人工智能的未来</a><ul class="itemizedlist1"><li class="listitem">计算语言学协会(ACL) / <a title="Seq2seq for translation" class="calibre1" href="part0084.html#2G3F81-ccdadb29edc54339afcb9bdf9350ba6b"> Seq2seq翻译</a></li></ul></li>
        <li class="listitem">异步梯度下降/ <a title="Training stability" class="calibre1" href="part0108.html#36VSO2-ccdadb29edc54339afcb9bdf9350ba6b">训练稳定性</a></li>
        <li class="listitem">注意机制</li>
        <li class="listitem">可区分的/ <a title="Differentiable mechanism of attention" class="calibre1" href="part0091_split_000.html#2MP362-ccdadb29edc54339afcb9bdf9350ba6b">可区分的注意机制</a><ul class="itemizedlist1"><li class="listitem">关于/ <a title="Differentiable mechanism of attention" class="calibre1" href="part0091_split_000.html#2MP362-ccdadb29edc54339afcb9bdf9350ba6b">注意的可分化机制</a></li><li class="listitem">翻译/ <a title="Better translations with attention mechanism" class="calibre1" href="part0091_split_000.html#2MP362-ccdadb29edc54339afcb9bdf9350ba6b">具有注意力机制的更好的翻译</a></li><li class="listitem">注释图像/ <a title="Better annotate images with attention mechanism" class="calibre1" href="part0091_split_000.html#2MP362-ccdadb29edc54339afcb9bdf9350ba6b">用注意力机制更好地注释图像</a></li><li class="listitem">汽车编码器/ <a title="Deep belief bets" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">深度信念赌注</a></li></ul></li>
        <li class="listitem">自动微分/ <a title="Functions and automatic differentiation" class="calibre1" href="part0022.html#KVCC1-ccdadb29edc54339afcb9bdf9350ba6b">功能和自动微分</a></li>
        <li class="listitem">B</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_1">反向传播/ <a title="Backpropagation and stochastic gradient descent" class="calibre1" href="part0031.html#TI1E1-ccdadb29edc54339afcb9bdf9350ba6b">反向传播和随机梯度下降</a></h2>
      <ul class="itemizedlist"><li class="listitem">穿越时间的反向传播(BPTT) / <a title="Simple recurrent network" class="calibre1" href="part0053_split_000.html#1IHDQ2-ccdadb29edc54339afcb9bdf9350ba6b">简单递归网络</a></li>
        <li class="listitem">基本线性代数子程序(BLAS) / <a title="Theano Op in Python for the GPU" class="calibre1" href="part0117.html#3FIHQ1-ccdadb29edc54339afcb9bdf9350ba6b">用于GPU的Python中的no Op</a></li>
        <li class="listitem">批量归一化/ <a title="Batch normalization" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">批量归一化</a></li>
        <li class="listitem">批量归一化层/ <a title="Batch normalization" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">批量归一化</a></li>
        <li class="listitem">贝叶斯网络理论/<a title="Dropout for RNN" class="calibre1" href="part0096_split_000.html#2RHM01-ccdadb29edc54339afcb9bdf9350ba6b">RNN辍学</a></li>
        <li class="listitem">波束搜索算法/ <a title="Improving efficiency of sequence-to-sequence network" class="calibre1" href="part0086.html#2I0GC1-ccdadb29edc54339afcb9bdf9350ba6b">提高时序网络效率</a></li>
        <li class="listitem">广播/ <a title="Elementwise operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">元素式操作符</a></li>
        <li class="listitem">C</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_2">字符错误率(CER) / <a title="Metrics for natural language performance" class="calibre1" href="part0054.html#1JFUC1-ccdadb29edc54339afcb9bdf9350ba6b">自然语言性能指标</a></h2>
      <ul class="itemizedlist"><li class="listitem">合并转置</li>
        <li class="listitem">通过共享内存/ <a title="Coalesced transpose via shared memory, NVIDIA parallel for all" class="calibre1" href="part0120_split_000.html#3IE3G2-ccdadb29edc54339afcb9bdf9350ba6b">通过共享内存合并转置，所有NVIDIA并行</a><ul class="itemizedlist1"><li class="listitem">通过NVIDIA并行/ <a title="Coalesced transpose via shared memory, NVIDIA parallel for all" class="calibre1" href="part0120_split_000.html#3IE3G2-ccdadb29edc54339afcb9bdf9350ba6b">合并转置通过共享内存，NVIDIA并行用于所有</a></li><li class="listitem">车型转换/ <a title="Model conversions" class="calibre1" href="part0120_split_000.html#3IE3G2-ccdadb29edc54339afcb9bdf9350ba6b">车型转换</a></li><li class="listitem">图像的条件随机场(CRF) / <a title="Deconvolutions for images" class="calibre1" href="part0087.html#2IV0U2-ccdadb29edc54339afcb9bdf9350ba6b">去卷积</a></li></ul></li>
        <li class="listitem">连续单词包(CBOW) / <a title="Encoding and embedding" class="calibre1" href="part0040_split_000.html#164MG1-ccdadb29edc54339afcb9bdf9350ba6b">编码和嵌入</a></li>
        <li class="listitem">连续词袋模型/ <a title="Continuous Bag of Words model" class="calibre1" href="part0042.html#181NK2-ccdadb29edc54339afcb9bdf9350ba6b">连续词袋模型</a></li>
        <li class="listitem">控制器/ <a title="Store and retrieve information in Neural Turing Machines" class="calibre1" href="part0092.html#2NNJO2-ccdadb29edc54339afcb9bdf9350ba6b">在神经图灵机中存储和检索信息</a></li>
        <li class="listitem">卷积神经网络(CNN) / <a title="Encoding and embedding" class="calibre1" href="part0040_split_000.html#164MG1-ccdadb29edc54339afcb9bdf9350ba6b">编码和嵌入</a></li>
        <li class="listitem">卷积/ <a title="Convolutions and max layers" class="calibre1" href="part0033.html#VF2I2-ccdadb29edc54339afcb9bdf9350ba6b">卷积和最大层数</a></li>
        <li class="listitem">成本函数/ <a title="Cost function and errors" class="calibre1" href="part0030.html#SJGS1-ccdadb29edc54339afcb9bdf9350ba6b">成本函数和误差</a></li>
        <li class="listitem">库达</li>
        <li class="listitem">URL，用于下载/ <a title="GPU drivers and libraries" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b"> GPU驱动程序和库</a><ul class="itemizedlist1"><li class="listitem">D</li></ul></li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_3">数据增强/ <a title="Data augmentation" class="calibre1" href="part0080.html#2C9D01-ccdadb29edc54339afcb9bdf9350ba6b">数据增强</a></h2>
      <ul class="itemizedlist"><li class="listitem">数据集/ <a title="Dataset" class="calibre1" href="part0041.html#173721-ccdadb29edc54339afcb9bdf9350ba6b">数据集</a></li>
        <li class="listitem">对于自然语言/ <a title="A dataset for natural language" class="calibre1" href="part0052.html#1HIT82-ccdadb29edc54339afcb9bdf9350ba6b">自然语言数据集</a><ul class="itemizedlist1"><li class="listitem">字符级/ <a title="A dataset for natural language" class="calibre1" href="part0052.html#1HIT82-ccdadb29edc54339afcb9bdf9350ba6b">自然语言数据集</a></li><li class="listitem">单词级/ <a title="A dataset for natural language" class="calibre1" href="part0052.html#1HIT82-ccdadb29edc54339afcb9bdf9350ba6b">自然语言数据集</a></li><li class="listitem">图像的去卷积</li></ul></li>
        <li class="listitem">深深的信念赌注/ <a title="Deep belief bets" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">深深的信念赌注</a></li>
        <li class="listitem">深度信念网络(DBN) / <a title="Deep belief bets" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">深度信念赌注</a></li>
        <li class="listitem">Deeplearning.net·泰阿诺</li>
        <li class="listitem">参考文献/ <a title="Related articles" class="calibre1" href="part0038.html#147LC1-ccdadb29edc54339afcb9bdf9350ba6b">相关文章</a><ul class="itemizedlist1"><li class="listitem">深掩模网络/ <a title="Deconvolutions for images" class="calibre1" href="part0087.html#2IV0U2-ccdadb29edc54339afcb9bdf9350ba6b">图像去卷积</a></li></ul></li>
        <li class="listitem">DeepMind算法/ <a title="Q-learning" class="calibre1" href="part0106.html#352RK2-ccdadb29edc54339afcb9bdf9350ba6b"> Q-learning </a></li>
        <li class="listitem">深Q网/ <a title="Deep Q-network" class="calibre1" href="part0107.html#361C61-ccdadb29edc54339afcb9bdf9350ba6b">深Q网</a></li>
        <li class="listitem">深度过渡网络/<a title="Deep approaches for RNN" class="calibre1" href="part0097.html#2SG6I1-ccdadb29edc54339afcb9bdf9350ba6b">RNN的深度方法</a></li>
        <li class="listitem">深度跃迁轮回网/ <a title="Deep transition recurrent network" class="calibre1" href="part0099.html#2UD7M1-ccdadb29edc54339afcb9bdf9350ba6b">深度跃迁轮回网</a></li>
        <li class="listitem">密集连接/ <a title="Dense connections" class="calibre1" href="part0078.html#2ACBS1-ccdadb29edc54339afcb9bdf9350ba6b">密集连接</a></li>
        <li class="listitem">维度操作符/ <a title="Dimension manipulation operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">维度操作符</a></li>
        <li class="listitem">辍学/ <a title="Dropout" class="calibre1" href="part0035.html#11C3M1-ccdadb29edc54339afcb9bdf9350ba6b">辍学</a></li>
        <li class="listitem">E</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_4">元素式操作符/ <a title="Elementwise operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">元素式操作符</a></h2>
      <ul class="itemizedlist"><li class="listitem">嵌入/ <a title="Encoding and embedding" class="calibre1" href="part0040_split_000.html#164MG1-ccdadb29edc54339afcb9bdf9350ba6b">编码和嵌入</a></li>
        <li class="listitem">编码/ <a title="Encoding and embedding" class="calibre1" href="part0040_split_000.html#164MG1-ccdadb29edc54339afcb9bdf9350ba6b">编码和嵌入</a></li>
        <li class="listitem">情景记忆</li>
        <li class="listitem">具有动态记忆网络/ <a title="Episodic memory with dynamic memory networks" class="calibre1" href="part0093_split_000.html#2OM4A1-ccdadb29edc54339afcb9bdf9350ba6b">具有动态记忆网络的情节记忆</a><ul class="itemizedlist1"><li class="listitem">错误/ <a title="Cost function and errors" class="calibre1" href="part0030.html#SJGS1-ccdadb29edc54339afcb9bdf9350ba6b">成本函数和错误</a></li></ul></li>
        <li class="listitem">外部记忆库/ <a title="Store and retrieve information in Neural Turing Machines" class="calibre1" href="part0092.html#2NNJO2-ccdadb29edc54339afcb9bdf9350ba6b">在神经图灵机</a>中存储和检索信息</li>
        <li class="listitem">F</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_5">功能/ <a title="Functions and automatic differentiation" class="calibre1" href="part0022.html#KVCC1-ccdadb29edc54339afcb9bdf9350ba6b">功能和自动微分</a></h2>
      <ul class="itemizedlist"><li class="listitem">G</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_6">门控循环网络/ <a title="Gated recurrent network" class="calibre1" href="part0053_split_000.html#1IHDQ2-ccdadb29edc54339afcb9bdf9350ba6b">门控循环网络</a></h2>
      <ul class="itemizedlist"><li class="listitem">通用矩阵到矩阵乘法(GEMM) / <a title="Theano Op in Python for the GPU" class="calibre1" href="part0117.html#3FIHQ1-ccdadb29edc54339afcb9bdf9350ba6b">用于GPU的Python中的no运算</a></li>
        <li class="listitem">通用矩阵到向量乘法(GEMV) / <a title="Theano Op in Python for the GPU" class="calibre1" href="part0117.html#3FIHQ1-ccdadb29edc54339afcb9bdf9350ba6b">用于GPU的Python中的no运算</a></li>
        <li class="listitem">生成对抗网络</li>
        <li class="listitem">关于/ <a title="Generative adversarial networks" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">生成性对抗网络</a><ul class="itemizedlist1"><li class="listitem">改善/ <a title="Improve GANs" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">改善GANs </a></li><li class="listitem">生成模型</li></ul></li>
        <li class="listitem">关于/ <a title="Generative models" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">创成式模型</a><ul class="itemizedlist1"><li class="listitem">受限玻尔兹曼机/ <a title="Restricted Boltzmann Machines" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">受限玻尔兹曼机</a></li><li class="listitem">深深的信念赌注/ <a title="Deep belief bets" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">深深的信念赌注</a></li><li class="listitem">生成对抗网络(GANs) / <a title="Generative adversarial networks" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">生成对抗网络</a></li><li class="listitem">全球平均池/ <a title="Global average pooling" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">全球平均池</a></li></ul></li>
        <li class="listitem">图/ <a title="Graphs and symbolic computing" class="calibre1" href="part0019.html#I3QM2-ccdadb29edc54339afcb9bdf9350ba6b">图与符号计算</a></li>
        <li class="listitem">贪婪方法/ <a title="Deep Q-network" class="calibre1" href="part0107.html#361C61-ccdadb29edc54339afcb9bdf9350ba6b">深度Q-网络</a></li>
        <li class="listitem">H</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_7">公路网设计原则/ <a title="Highway networks design principle" class="calibre1" href="part0100.html#2VBO81-ccdadb29edc54339afcb9bdf9350ba6b">公路网设计原则</a></h2>
      <ul class="itemizedlist"><li class="listitem">主机代码/<a title="Theano Op in C for GPU" class="calibre1" href="part0119.html#3HFIU2-ccdadb29edc54339afcb9bdf9350ba6b">GPU的C语言中的no操作</a></li>
        <li class="listitem">我</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_8">身份连接/ <a title="Residual connections" class="calibre1" href="part0076.html#28FAO2-ccdadb29edc54339afcb9bdf9350ba6b">剩余连接</a></h2>
      <ul class="itemizedlist"><li class="listitem">身份连接/ <a title="Highway networks design principle" class="calibre1" href="part0100.html#2VBO81-ccdadb29edc54339afcb9bdf9350ba6b">公路网设计原则</a></li>
        <li class="listitem">形象</li>
        <li class="listitem">图像去卷积/ <a title="Deconvolutions for images" class="calibre1" href="part0087.html#2IV0U2-ccdadb29edc54339afcb9bdf9350ba6b">去卷积</a><ul class="itemizedlist1"><li class="listitem">图像的概念/ <a title="Deconvolutions for images" class="calibre1" href="part0087.html#2IV0U2-ccdadb29edc54339afcb9bdf9350ba6b">去卷积</a></li></ul></li>
        <li class="listitem">独立分量分析(ICA) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a></li>
        <li class="listitem">推论/ <a title="Inference" class="calibre1" href="part0036.html#12AK81-ccdadb29edc54339afcb9bdf9350ba6b">推论</a></li>
        <li class="listitem">内部协变量移位/ <a title="Batch normalization" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">批量归一化</a></li>
        <li class="listitem">联合交集(IOU) / <a title="Region-based localization networks" class="calibre1" href="part0072.html#24L8G1-ccdadb29edc54339afcb9bdf9350ba6b">基于区域的定位网络</a></li>
        <li class="listitem">K</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_9">克拉斯</h2>
      <ul class="itemizedlist"><li class="listitem">安装/ <a title="Installing and configuring Keras" class="calibre1" href="part0060_split_000.html#1P71O2-ccdadb29edc54339afcb9bdf9350ba6b">安装和配置Keras </a><ul class="itemizedlist1"><li class="listitem">配置/ <a title="Installing and configuring Keras" class="calibre1" href="part0060_split_000.html#1P71O2-ccdadb29edc54339afcb9bdf9350ba6b">安装和配置Keras </a></li><li class="listitem">编程/ <a title="Programming with Keras" class="calibre1" href="part0060_split_000.html#1P71O2-ccdadb29edc54339afcb9bdf9350ba6b">用Keras编程</a></li><li class="listitem">塞姆瓦尔2013年数据集/ <a title="SemEval 2013 dataset" class="calibre1" href="part0060_split_000.html#1P71O2-ccdadb29edc54339afcb9bdf9350ba6b">塞姆瓦尔2013年数据集</a></li><li class="listitem">模型，训练/ <a title="Compiling and training the model" class="calibre1" href="part0063.html#1S2JE1-ccdadb29edc54339afcb9bdf9350ba6b">编译和训练模型</a></li><li class="listitem">模型，编译/ <a title="Compiling and training the model" class="calibre1" href="part0063.html#1S2JE1-ccdadb29edc54339afcb9bdf9350ba6b">编译和训练模型</a></li><li class="listitem">内核/ <a title="Theano Op in C for GPU" class="calibre1" href="part0119.html#3HFIU2-ccdadb29edc54339afcb9bdf9350ba6b">用于GPU的C语言中的操作</a></li></ul></li>
        <li class="listitem">L</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_10">千层面</h2>
      <ul class="itemizedlist"><li class="listitem">MNIST CNN模特/ <a title="MNIST CNN model with Lasagne" class="calibre1" href="part0069_split_000.html#21PMQ2-ccdadb29edc54339afcb9bdf9350ba6b"> MNIST CNN模特配千层面</a><ul class="itemizedlist1"><li class="listitem">潜在语义分析/索引(LSA / LSI) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习嵌入</a></li></ul></li>
        <li class="listitem">图层输入归一化/ <a title="Batch normalization" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">批量归一化</a></li>
        <li class="listitem">习得嵌入</li>
        <li class="listitem">可视化/ <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a><ul class="itemizedlist1"><li class="listitem">线性代数算子/ <a title="Linear algebra operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">线性代数算子</a></li></ul></li>
        <li class="listitem">线性判别分析(LDA) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a></li>
        <li class="listitem">本地化网络</li>
        <li class="listitem">关于/ <a title="A localization network" class="calibre1" href="part0070_split_000.html#22O7C2-ccdadb29edc54339afcb9bdf9350ba6b">一个本地化网络</a><ul class="itemizedlist1"><li class="listitem">递归神经网络，应用于图像/ <a title="Recurrent neural net applied to images" class="calibre1" href="part0070_split_000.html#22O7C2-ccdadb29edc54339afcb9bdf9350ba6b">递归神经网络应用于图像</a></li><li class="listitem">局部线性嵌入(LLE) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a></li></ul></li>
        <li class="listitem">长时短时记忆(LSTM) / <a title="Sentence representation using bi-LSTM" class="calibre1" href="part0062_split_000.html#1R42S2-ccdadb29edc54339afcb9bdf9350ba6b">使用双LSTM的句子表征</a></li>
        <li class="listitem">环</li>
        <li class="listitem">在符号计算中/ <a title="Loops in symbolic computing" class="calibre1" href="part0023.html#LTSU2-ccdadb29edc54339afcb9bdf9350ba6b">循环在符号计算中</a><ul class="itemizedlist1"><li class="listitem">损失比较</li></ul></li>
        <li class="listitem">培训/ <a title="Training loss comparison" class="calibre1" href="part0055.html#1KEEU1-ccdadb29edc54339afcb9bdf9350ba6b">培训损失对比</a><ul class="itemizedlist1"><li class="listitem">损失函数</li></ul></li>
        <li class="listitem">分类/ <a title="Classification loss function" class="calibre1" href="part0028.html#QMFO1-ccdadb29edc54339afcb9bdf9350ba6b">分类损失函数</a><ul class="itemizedlist1"><li class="listitem">LSTM网/ <a title="LSTM network" class="calibre1" href="part0053_split_000.html#1IHDQ2-ccdadb29edc54339afcb9bdf9350ba6b"> LSTM网</a></li></ul></li>
        <li class="listitem">M</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_11">最大层数/ <a title="Convolutions and max layers" class="calibre1" href="part0033.html#VF2I2-ccdadb29edc54339afcb9bdf9350ba6b">卷积和最大层数</a></h2>
      <ul class="itemizedlist"><li class="listitem">内存/ <a title="Memory and variables" class="calibre1" href="part0021.html#K0RQ1-ccdadb29edc54339afcb9bdf9350ba6b">内存和变量</a></li>
        <li class="listitem">内存网络</li>
        <li class="listitem">关于/ <a title="Memory networks" class="calibre1" href="part0093_split_000.html#2OM4A1-ccdadb29edc54339afcb9bdf9350ba6b">内存网络</a><ul class="itemizedlist1"><li class="listitem">具有动态记忆网络的情节记忆/ <a title="Episodic memory with dynamic memory networks" class="calibre1" href="part0093_split_000.html#2OM4A1-ccdadb29edc54339afcb9bdf9350ba6b">具有动态记忆网络的情节记忆</a></li><li class="listitem">MNIST CNN模型</li></ul></li>
        <li class="listitem">配千层面/ <a title="MNIST CNN model with Lasagne" class="calibre1" href="part0069_split_000.html#21PMQ2-ccdadb29edc54339afcb9bdf9350ba6b"> MNIST CNN模特配千层面</a><ul class="itemizedlist1"><li class="listitem">MNIST数据集/<a title="The MNIST dataset" class="calibre1" href="part0026_split_000.html#OPEK1-ccdadb29edc54339afcb9bdf9350ba6b">MNIST数据集</a></li></ul></li>
        <li class="listitem">模型</li>
        <li class="listitem">训练/ <a title="Training the model" class="calibre1" href="part0043.html#190862-ccdadb29edc54339afcb9bdf9350ba6b">训练模特</a><ul class="itemizedlist1"><li class="listitem">编译，在Keras / <a title="Compiling and training the model" class="calibre1" href="part0063.html#1S2JE1-ccdadb29edc54339afcb9bdf9350ba6b">中编译和训练模型</a></li><li class="listitem">培训，在Keras / <a title="Compiling and training the model" class="calibre1" href="part0063.html#1S2JE1-ccdadb29edc54339afcb9bdf9350ba6b">中编译和培训模型</a></li><li class="listitem">评估/ <a title="Evaluating the model" class="calibre1" href="part0064.html#1T1401-ccdadb29edc54339afcb9bdf9350ba6b">评估模型</a></li><li class="listitem">加载/ <a title="Saving and loading the model" class="calibre1" href="part0065.html#1TVKI1-ccdadb29edc54339afcb9bdf9350ba6b">保存并加载模型</a></li><li class="listitem">保存/ <a title="Saving and loading the model" class="calibre1" href="part0065.html#1TVKI1-ccdadb29edc54339afcb9bdf9350ba6b">保存并加载模型</a></li><li class="listitem">示例，执行/ <a title="Running the example" class="calibre1" href="part0066.html#1UU541-ccdadb29edc54339afcb9bdf9350ba6b">运行示例</a></li><li class="listitem">模型崩溃/ <a title="Improve GANs" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">改进GANs </a></li></ul></li>
        <li class="listitem">修改后的国家标准与技术研究所(MNIST)/<a title="The MNIST dataset" class="calibre1" href="part0026_split_000.html#OPEK1-ccdadb29edc54339afcb9bdf9350ba6b">MNIST数据集</a></li>
        <li class="listitem">动量/ <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化等更新规则</a></li>
        <li class="listitem">蒙特卡罗树搜索(MCTS) / <a title="Q-learning" class="calibre1" href="part0106.html#352RK2-ccdadb29edc54339afcb9bdf9350ba6b"> Q-learning </a></li>
        <li class="listitem">多GPU / <a title="Multi-GPU" class="calibre1" href="part0079.html#2BASE1-ccdadb29edc54339afcb9bdf9350ba6b">多GPU </a></li>
        <li class="listitem">多层感知器(MLP) / <a title="Multiple layer model" class="calibre1" href="part0032.html#UGI02-ccdadb29edc54339afcb9bdf9350ba6b">多层模型</a></li>
        <li class="listitem">多维标度(MDS) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a></li>
        <li class="listitem">多模态深度学习/ <a title="Multimodal deep learning" class="calibre1" href="part0088.html#2JTHG1-ccdadb29edc54339afcb9bdf9350ba6b">多模态深度学习</a></li>
        <li class="listitem">多层模型/ <a title="Multiple layer model" class="calibre1" href="part0032.html#UGI02-ccdadb29edc54339afcb9bdf9350ba6b">多层模型</a></li>
        <li class="listitem">普通</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_12">自然图像数据集</h2>
      <ul class="itemizedlist"><li class="listitem">关于/ <a title="Natural image datasets" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">自然图像数据集</a><ul class="itemizedlist1"><li class="listitem">批量标准化/ <a title="Batch normalization" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">批量标准化</a></li><li class="listitem">全球平均池/ <a title="Global average pooling" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">全球平均池</a></li><li class="listitem">自然语言表现</li></ul></li>
        <li class="listitem">/ <a title="Metrics for natural language performance" class="calibre1" href="part0054.html#1JFUC1-ccdadb29edc54339afcb9bdf9350ba6b">自然语言表现指标</a><ul class="itemizedlist1"><li class="listitem">自然语言处理(NLP) / <a title="Sequence-to-sequence networks for natural language processing" class="calibre1" href="part0083_split_000.html#2F4UM2-ccdadb29edc54339afcb9bdf9350ba6b">用于自然语言处理的序列到序列网络</a></li></ul></li>
        <li class="listitem"><a title="Restricted Boltzmann Machines" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">负粒子/受限玻尔兹曼机</a></li>
        <li class="listitem">内斯特罗夫加速梯度/ <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li>
        <li class="listitem">网络输入归一化/ <a title="Batch normalization" class="calibre1" href="part0075_split_000.html#27GQ61-ccdadb29edc54339afcb9bdf9350ba6b">批量归一化</a></li>
        <li class="listitem">神经机器翻译(NMT) / <a title="Weight tying" class="calibre1" href="part0048.html#1DOR01-ccdadb29edc54339afcb9bdf9350ba6b">权重平手</a></li>
        <li class="listitem">神经网络语言模型(NNLM) / <a title="Weight tying" class="calibre1" href="part0048.html#1DOR01-ccdadb29edc54339afcb9bdf9350ba6b">权重捆绑</a></li>
        <li class="listitem">神经图灵机(NTM)</li>
        <li class="listitem">在/ <a title="Store and retrieve information in Neural Turing Machines" class="calibre1" href="part0092.html#2NNJO2-ccdadb29edc54339afcb9bdf9350ba6b">中检索信息在神经图灵机</a>中存储和检索信息<ul class="itemizedlist1"><li class="listitem">在/ <a title="Store and retrieve information in Neural Turing Machines" class="calibre1" href="part0092.html#2NNJO2-ccdadb29edc54339afcb9bdf9350ba6b">中存储信息在神经图灵机</a>中存储和检索信息</li><li class="listitem">关于/ <a title="Store and retrieve information in Neural Turing Machines" class="calibre1" href="part0092.html#2NNJO2-ccdadb29edc54339afcb9bdf9350ba6b">在神经图灵机中存储和检索信息</a></li><li class="listitem">O</li></ul></li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_13">脱产培训/ <a title="Training stability" class="calibre1" href="part0108.html#36VSO2-ccdadb29edc54339afcb9bdf9350ba6b">培训稳定性</a></h2>
      <ul class="itemizedlist"><li class="listitem">在线培训/ <a title="Training stability" class="calibre1" href="part0108.html#36VSO2-ccdadb29edc54339afcb9bdf9350ba6b">培训稳定性</a></li>
        <li class="listitem">开放式人工智能健身房</li>
        <li class="listitem">关于/ <a title="Simulation environments" class="calibre1" href="part0105.html#344B21-ccdadb29edc54339afcb9bdf9350ba6b">模拟环境</a><ul class="itemizedlist1"><li class="listitem">URL / <a title="Simulation environments" class="calibre1" href="part0105.html#344B21-ccdadb29edc54339afcb9bdf9350ba6b">模拟环境</a></li><li class="listitem">最佳状态值函数v(s)/<a title="Q-learning" class="calibre1" href="part0106.html#352RK2-ccdadb29edc54339afcb9bdf9350ba6b">Q-学习</a></li></ul></li>
        <li class="listitem">优化/ <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li>
        <li class="listitem">无词汇(OOV) / <a title="Preprocessing text data" class="calibre1" href="part0061.html#1Q5IA2-ccdadb29edc54339afcb9bdf9350ba6b">预处理文本数据</a></li>
        <li class="listitem">P</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_14">词性(POS)/<a title="Applications of RNN" class="calibre1" href="part0057.html#1MBG21-ccdadb29edc54339afcb9bdf9350ba6b">RNN的应用</a></h2>
      <ul class="itemizedlist"><li class="listitem">团</li>
        <li class="listitem">参考链接/ <a title="Multi-GPU" class="calibre1" href="part0079.html#2BASE1-ccdadb29edc54339afcb9bdf9350ba6b">多GPU </a><ul class="itemizedlist1"><li class="listitem">政策梯度(PG)</li></ul></li>
        <li class="listitem">关于/ <a title="Policy gradients with REINFORCE algorithms" class="calibre1" href="part0109.html#37UDA2-ccdadb29edc54339afcb9bdf9350ba6b">采用强化算法的策略梯度</a><ul class="itemizedlist1"><li class="listitem">使用增强算法/ <a title="Policy gradients with REINFORCE algorithms" class="calibre1" href="part0109.html#37UDA2-ccdadb29edc54339afcb9bdf9350ba6b">使用增强算法的策略梯度</a></li><li class="listitem">策略网络/ <a title="Policy gradients with REINFORCE algorithms" class="calibre1" href="part0109.html#37UDA2-ccdadb29edc54339afcb9bdf9350ba6b">具有增强算法的策略梯度</a></li></ul></li>
        <li class="listitem">正负相位/ <a title="Restricted Boltzmann Machines" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">受限玻尔兹曼机</a></li>
        <li class="listitem">预言</li>
        <li class="listitem">示例/ <a title="Example of predictions" class="calibre1" href="part0056.html#1LCVG1-ccdadb29edc54339afcb9bdf9350ba6b">预测示例</a><ul class="itemizedlist1"><li class="listitem">主成分分析(PCA) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a></li></ul></li>
        <li class="listitem">Q</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_15">Q-learning / <a title="Q-learning" class="calibre1" href="part0106.html#352RK2-ccdadb29edc54339afcb9bdf9350ba6b"> Q-learning </a></h2>
      <ul class="itemizedlist"><li class="listitem">定量分析/ <a title="Evaluating embeddings – quantitative analysis" class="calibre1" href="part0046.html#1BRPS1-ccdadb29edc54339afcb9bdf9350ba6b">评估嵌入——定量分析</a></li>
        <li class="listitem">稀有</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_16">循环高速公路网(RHN) / <a title="Recurrent Highway Networks" class="calibre1" href="part0101.html#30A8Q1-ccdadb29edc54339afcb9bdf9350ba6b">循环高速公路网</a></h2>
      <ul class="itemizedlist"><li class="listitem">递归神经网络(RNN) / <a title="Encoding and embedding" class="calibre1" href="part0040_split_000.html#164MG1-ccdadb29edc54339afcb9bdf9350ba6b">编码和嵌入</a></li>
        <li class="listitem">递归神经网络(RNN)</li>
        <li class="listitem">对RNN的需求<ul class="itemizedlist1"><li class="listitem">关于/ <a title="Need for RNN" class="calibre1" href="part0051_split_000.html#1GKCM1-ccdadb29edc54339afcb9bdf9350ba6b">需要RNN </a></li><li class="listitem">申请/<a title="Applications of RNN" class="calibre1" href="part0057.html#1MBG21-ccdadb29edc54339afcb9bdf9350ba6b">RNN的申请</a></li><li class="listitem">归约算子/ <a title="Reduction operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">归约算子</a></li></ul></li>
        <li class="listitem">基于区域的定位网络/ <a title="Region-based localization networks" class="calibre1" href="part0072.html#24L8G1-ccdadb29edc54339afcb9bdf9350ba6b">基于区域的定位网络</a></li>
        <li class="listitem">区域提议网络(RPN) / <a title="Region-based localization networks" class="calibre1" href="part0072.html#24L8G1-ccdadb29edc54339afcb9bdf9350ba6b">基于区域的定位网络</a></li>
        <li class="listitem">强化学习任务/ <a title="Reinforcement learning tasks" class="calibre1" href="part0104_split_000.html#335QG1-ccdadb29edc54339afcb9bdf9350ba6b">强化学习任务</a></li>
        <li class="listitem">回放记忆/ <a title="Training stability" class="calibre1" href="part0108.html#36VSO2-ccdadb29edc54339afcb9bdf9350ba6b">训练稳定性</a></li>
        <li class="listitem">剩余块/ <a title="Residual connections" class="calibre1" href="part0076.html#28FAO2-ccdadb29edc54339afcb9bdf9350ba6b">剩余连接</a></li>
        <li class="listitem">剩余连接/ <a title="Residual connections" class="calibre1" href="part0076.html#28FAO2-ccdadb29edc54339afcb9bdf9350ba6b">剩余连接</a></li>
        <li class="listitem">残差/ <a title="Residual connections" class="calibre1" href="part0076.html#28FAO2-ccdadb29edc54339afcb9bdf9350ba6b">残差连接</a></li>
        <li class="listitem">受限玻尔兹曼机/ <a title="Restricted Boltzmann Machines" class="calibre1" href="part0112_split_000.html#3APV02-ccdadb29edc54339afcb9bdf9350ba6b">受限玻尔兹曼机</a></li>
        <li class="listitem">RMSProp / <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li>
        <li class="listitem">RNN</li>
        <li class="listitem">辍学/<a title="Dropout for RNN" class="calibre1" href="part0096_split_000.html#2RHM01-ccdadb29edc54339afcb9bdf9350ba6b">RNN辍学</a><ul class="itemizedlist1"><li class="listitem">RNN的深层方法</li><li class="listitem">S</li></ul></li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_17">SegNet网络/ <a title="Deconvolutions for images" class="calibre1" href="part0087.html#2IV0U2-ccdadb29edc54339afcb9bdf9350ba6b">图像去卷积</a></h2>
      <ul class="itemizedlist"><li class="listitem">半监督学习/半监督学习<a title="Semi-supervised learning" class="calibre1" href="part0113.html#3BOFI1-ccdadb29edc54339afcb9bdf9350ba6b"/></li>
        <li class="listitem">序列间(Seq2seq)网络</li>
        <li class="listitem">用于自然语言处理/ <a title="Sequence-to-sequence networks for natural language processing" class="calibre1" href="part0083_split_000.html#2F4UM2-ccdadb29edc54339afcb9bdf9350ba6b">用于自然语言处理的序列到序列网络</a><ul class="itemizedlist1"><li class="listitem">关于/ <a title="Sequence-to-sequence networks for natural language processing" class="calibre1" href="part0083_split_000.html#2F4UM2-ccdadb29edc54339afcb9bdf9350ba6b">用于自然语言处理的序列对序列网络</a>，<a title="Seq2seq for translation" class="calibre1" href="part0084.html#2G3F81-ccdadb29edc54339afcb9bdf9350ba6b">用于翻译的seq 2 seq</a></li><li class="listitem">用于翻译/ <a title="Seq2seq for translation" class="calibre1" href="part0084.html#2G3F81-ccdadb29edc54339afcb9bdf9350ba6b"> Seq2seq用于翻译</a></li><li class="listitem">对于聊天机器人/ <a title="Seq2seq for chatbots" class="calibre1" href="part0085.html#2H1VQ1-ccdadb29edc54339afcb9bdf9350ba6b"> Seq2seq对于聊天机器人</a></li><li class="listitem">效率，提高/ <a title="Improving efficiency of sequence-to-sequence network" class="calibre1" href="part0086.html#2I0GC1-ccdadb29edc54339afcb9bdf9350ba6b">提高时序网络的效率</a></li><li class="listitem">SharpMask / <a title="Deconvolutions for images" class="calibre1" href="part0087.html#2IV0U2-ccdadb29edc54339afcb9bdf9350ba6b">图像去卷积</a></li></ul></li>
        <li class="listitem">简单循环网络</li>
        <li class="listitem">关于/ <a title="Simple recurrent network" class="calibre1" href="part0053_split_000.html#1IHDQ2-ccdadb29edc54339afcb9bdf9350ba6b">简单递归网络</a><ul class="itemizedlist1"><li class="listitem">LSTM网/ <a title="LSTM network" class="calibre1" href="part0053_split_000.html#1IHDQ2-ccdadb29edc54339afcb9bdf9350ba6b"> LSTM网</a></li><li class="listitem">门控递归网络/ <a title="Gated recurrent network" class="calibre1" href="part0053_split_000.html#1IHDQ2-ccdadb29edc54339afcb9bdf9350ba6b">门控递归网络</a></li><li class="listitem">模拟环境/ <a title="Simulation environments" class="calibre1" href="part0105.html#344B21-ccdadb29edc54339afcb9bdf9350ba6b">模拟环境</a></li></ul></li>
        <li class="listitem">单层线性模型/ <a title="Single-layer linear model" class="calibre1" href="part0029.html#RL0A1-ccdadb29edc54339afcb9bdf9350ba6b">单层线性模型</a></li>
        <li class="listitem">单指令多数据(SIMD)/<a title="Theano Op in C for GPU" class="calibre1" href="part0119.html#3HFIU2-ccdadb29edc54339afcb9bdf9350ba6b">GPU的C语言中的no运算</a></li>
        <li class="listitem">空间变压器网络(STN) / <a title="A localization network" class="calibre1" href="part0070_split_000.html#22O7C2-ccdadb29edc54339afcb9bdf9350ba6b">一个定位网络</a></li>
        <li class="listitem">稳定性</li>
        <li class="listitem">训练/ <a title="Training stability" class="calibre1" href="part0108.html#36VSO2-ccdadb29edc54339afcb9bdf9350ba6b">训练稳定性</a><ul class="itemizedlist1"><li class="listitem">堆叠递归网络/ <a title="Stacked recurrent networks" class="calibre1" href="part0098.html#2TEN42-ccdadb29edc54339afcb9bdf9350ba6b">堆叠递归网络</a></li></ul></li>
        <li class="listitem">状态-行动价值网络/ <a title="Deep Q-network" class="calibre1" href="part0107.html#361C61-ccdadb29edc54339afcb9bdf9350ba6b">深度Q-网络</a></li>
        <li class="listitem">状态值网络/ <a title="Policy gradients with REINFORCE algorithms" class="calibre1" href="part0109.html#37UDA2-ccdadb29edc54339afcb9bdf9350ba6b">具有增强算法的策略梯度</a></li>
        <li class="listitem">状态值/<a title="Q-learning" class="calibre1" href="part0106.html#352RK2-ccdadb29edc54339afcb9bdf9350ba6b">Q-学习</a></li>
        <li class="listitem">随机深度/ <a title="Stochastic depth" class="calibre1" href="part0077.html#29DRA1-ccdadb29edc54339afcb9bdf9350ba6b">随机深度</a></li>
        <li class="listitem">随机梯度下降(SGD) / <a title="Backpropagation and stochastic gradient descent" class="calibre1" href="part0031.html#TI1E1-ccdadb29edc54339afcb9bdf9350ba6b">反向传播和随机梯度下降</a>，<a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li>
        <li class="listitem">流式多处理器(SM) / <a title="Theano Op in C for GPU" class="calibre1" href="part0119.html#3HFIU2-ccdadb29edc54339afcb9bdf9350ba6b">面向GPU的C #处理器</a></li>
        <li class="listitem">符号计算/ <a title="Graphs and symbolic computing" class="calibre1" href="part0019.html#I3QM2-ccdadb29edc54339afcb9bdf9350ba6b">图形和符号计算</a></li>
        <li class="listitem">循环中的/ <a title="Loops in symbolic computing" class="calibre1" href="part0023.html#LTSU2-ccdadb29edc54339afcb9bdf9350ba6b">循环中的符号计算</a><ul class="itemizedlist1"><li class="listitem">T</li></ul></li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_18">t-分布式随机邻居嵌入(t-SNE) / <a title="Visualizing the learned embeddings" class="calibre1" href="part0044.html#19UOO1-ccdadb29edc54339afcb9bdf9350ba6b">可视化学习到的嵌入</a></h2>
      <ul class="itemizedlist"><li class="listitem">张量处理单元(TPU) / <a title="Model conversions" class="calibre1" href="part0120_split_000.html#3IE3G2-ccdadb29edc54339afcb9bdf9350ba6b">模型转换</a></li>
        <li class="listitem">张量</li>
        <li class="listitem">需求/ <a title="The need for tensors" class="calibre1" href="part0016_split_000.html#F8901-ccdadb29edc54339afcb9bdf9350ba6b">对张量的需求</a><ul class="itemizedlist1"><li class="listitem">关于/ <a title="Tensors" class="calibre1" href="part0018.html#H5A41-ccdadb29edc54339afcb9bdf9350ba6b">张量</a></li><li class="listitem">对/ <a title="Operations on tensors" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">的运算对张量</a>的运算</li><li class="listitem">尺寸操作符/ <a title="Dimension manipulation operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">尺寸操作符</a></li><li class="listitem">元素式运算符/ <a title="Elementwise operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">元素式运算符</a></li><li class="listitem">归约运算符/ <a title="Reduction operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">归约运算符</a></li><li class="listitem">线性代数算子/ <a title="Linear algebra operators" class="calibre1" href="part0020_split_000.html#J2B82-ccdadb29edc54339afcb9bdf9350ba6b">线性代数算子</a></li><li class="listitem">文本数据</li></ul></li>
        <li class="listitem">预处理/ <a title="Preprocessing text data" class="calibre1" href="part0061.html#1Q5IA2-ccdadb29edc54339afcb9bdf9350ba6b">预处理文本数据</a><ul class="itemizedlist1"><li class="listitem">Theano</li></ul></li>
        <li class="listitem">安装/ <a title="Installing and loading Theano" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">安装和装载编号</a><ul class="itemizedlist1"><li class="listitem">装载/ <a title="Installing and loading Theano" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">安装和装载天线</a></li><li class="listitem">康达包/ <a title="Conda package and environment manager" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">康达包和环境管理器</a></li><li class="listitem">环境管理器/ <a title="Conda package and environment manager" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b"> Conda包和环境管理器</a></li><li class="listitem">在CPU上安装/ <a title="Installing and running Theano on CPU" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">在CPU上安装并运行no</a></li><li class="listitem">在CPU上执行/ <a title="Installing and running Theano on CPU" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">在CPU上安装并运行ano</a></li><li class="listitem">GPU驱动程序/ <a title="GPU drivers and libraries" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b"> GPU驱动程序和库</a></li><li class="listitem">GPU库/ <a title="GPU drivers and libraries" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b"> GPU驱动程序和库</a></li><li class="listitem">在GPU上安装/ <a title="Installing and running Theano on GPU" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">在GPU上安装和运行ano</a></li><li class="listitem">在GPU上执行/ <a title="Installing and running Theano on GPU" class="calibre1" href="part0017_split_000.html#G6PI1-ccdadb29edc54339afcb9bdf9350ba6b">在GPU上安装并运行ano</a></li><li class="listitem">调试/ <a title="Configuration, profiling and debugging" class="calibre1" href="part0024.html#MSDG1-ccdadb29edc54339afcb9bdf9350ba6b">配置、剖析和调试</a></li><li class="listitem">剖析/ <a title="Configuration, profiling and debugging" class="calibre1" href="part0024.html#MSDG1-ccdadb29edc54339afcb9bdf9350ba6b">配置、剖析和调试</a></li><li class="listitem">配置/ <a title="Configuration, profiling and debugging" class="calibre1" href="part0024.html#MSDG1-ccdadb29edc54339afcb9bdf9350ba6b">配置、分析和调试</a></li><li class="listitem">Theano Op</li></ul></li>
        <li class="listitem">在Python中，for CPU/<a title="Theano Op in Python for CPU" class="calibre1" href="part0116_split_000.html#3EK181-ccdadb29edc54339afcb9bdf9350ba6b">the no Op在Python中，for CPU </a><ul class="itemizedlist1"><li class="listitem">在Python中，对于GPU / <a title="Theano Op in Python for the GPU" class="calibre1" href="part0117.html#3FIHQ1-ccdadb29edc54339afcb9bdf9350ba6b">在Python中对于GPU的no Op</a></li><li class="listitem">在C语言中，对于CPU / <a title="Theano Op in C for CPU" class="calibre1" href="part0118.html#3GH2C2-ccdadb29edc54339afcb9bdf9350ba6b">在C语言中对于CPU </a>没有运算</li><li class="listitem">用于GPU的C语言/ <a title="Theano Op in C for GPU" class="calibre1" href="part0119.html#3HFIU2-ccdadb29edc54339afcb9bdf9350ba6b">用于GPU的C语言中的no Op</a></li><li class="listitem">托尔茨</li></ul></li>
        <li class="listitem">URL / <a title="Simulation environments" class="calibre1" href="part0105.html#344B21-ccdadb29edc54339afcb9bdf9350ba6b">模拟环境</a><ul class="itemizedlist1"><li class="listitem">培训项目</li></ul></li>
        <li class="listitem">培训计划的结构<ul class="itemizedlist1"><li class="listitem">脚本环境，设置/ <a title="Structure of a training program" class="calibre1" href="part0027.html#PNV61-ccdadb29edc54339afcb9bdf9350ba6b">培训计划的结构</a></li><li class="listitem">数据，加载/ <a title="Structure of a training program" class="calibre1" href="part0027.html#PNV61-ccdadb29edc54339afcb9bdf9350ba6b">培训计划的结构</a></li><li class="listitem">数据，预处理/ <a title="Structure of a training program" class="calibre1" href="part0027.html#PNV61-ccdadb29edc54339afcb9bdf9350ba6b">培训计划的结构</a></li><li class="listitem">培训计划的模型、建筑/ <a title="Structure of a training program" class="calibre1" href="part0027.html#PNV61-ccdadb29edc54339afcb9bdf9350ba6b">结构</a></li><li class="listitem">培训/ <a title="Structure of a training program" class="calibre1" href="part0027.html#PNV61-ccdadb29edc54339afcb9bdf9350ba6b">培训计划的结构</a></li><li class="listitem">U</li></ul></li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_19">无监督学习</h2>
      <ul class="itemizedlist"><li class="listitem">协同定位/ <a title="Unsupervised learning with co-localization" class="calibre1" href="part0071.html#23MNU1-ccdadb29edc54339afcb9bdf9350ba6b">协同定位的无监督学习</a><ul class="itemizedlist1"><li class="listitem">更新规则/ <a title="Optimization and other update rules" class="calibre1" href="part0037.html#1394Q2-ccdadb29edc54339afcb9bdf9350ba6b">优化和其他更新规则</a></li></ul></li>
        <li class="listitem">V</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_20">验证数据集</h2>
      <ul class="itemizedlist"><li class="listitem">训练/ <a title="Training" class="calibre1" href="part0034.html#10DJ42-ccdadb29edc54339afcb9bdf9350ba6b">训练</a><ul class="itemizedlist1"><li class="listitem">变量/ <a title="Memory and variables" class="calibre1" href="part0021.html#K0RQ1-ccdadb29edc54339afcb9bdf9350ba6b">内存和变量</a></li></ul></li>
        <li class="listitem">变分RNN/<a title="Dropout for RNN" class="calibre1" href="part0096_split_000.html#2RHM01-ccdadb29edc54339afcb9bdf9350ba6b">RNN辍学</a></li>
        <li class="listitem">W</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_21">重量捆绑(WT) / <a title="Weight tying" class="calibre1" href="part0048.html#1DOR01-ccdadb29edc54339afcb9bdf9350ba6b">重量捆绑</a></h2>
      <ul class="itemizedlist"><li class="listitem">单词嵌入</li>
        <li class="listitem">应用/ <a title="Application of word embeddings" class="calibre1" href="part0047.html#1CQAE1-ccdadb29edc54339afcb9bdf9350ba6b">单词嵌入的应用</a><ul class="itemizedlist1"><li class="listitem">单词错误率(WER) / <a title="Metrics for natural language performance" class="calibre1" href="part0054.html#1JFUC1-ccdadb29edc54339afcb9bdf9350ba6b">自然语言表现指标</a></li></ul></li>
        <li class="listitem">Y</li>
      </ul></div>
  </body></html>


<html>
  <head>
    <title>Index</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3M85O0-ccdadb29edc54339afcb9bdf9350ba6b" class="calibre">
<div><h2 class="title1" id="calibre_pb_22">你只看到一次(YOLO)架构/ <a title="Region-based localization networks" class="calibre1" href="part0072.html#24L8G1-ccdadb29edc54339afcb9bdf9350ba6b">基于地区的本地化网络</a></h2>
      <ul class="itemizedlist"><li class="listitem">You Only See Once (YOLO) architecture / <a title="Region-based localization networks" class="calibre1" href="part0072.html#24L8G1-ccdadb29edc54339afcb9bdf9350ba6b">Region-based localization networks</a></li>
      </ul></div>
  </body></html>
</body></html>