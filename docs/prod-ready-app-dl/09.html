<html><head/><body>





	

		<title>B18522_07</title>

		

	

	

		<div><h1 id="_idParaDest-153" class="chapter-number"><a id="_idTextAnchor162"/> 7</h1>

			<h1 id="_idParaDest-154"><a id="_idTextAnchor163"/>揭示深度学习模型的秘密</h1>

			<p>到目前为止，我们已经描述了如何构建和高效训练一个<strong class="bold">深度学习</strong>(<strong class="bold">D1</strong>)模型。然而，模型训练通常涉及多次迭代，因为只存在关于如何为给定任务正确配置训练的粗略指导。</p>

			<p>在本章中，我们将介绍超参数调整，这是找到正确训练配置的最标准的过程。当我们指导您完成超参数调整的步骤时，我们将介绍调整过程中采用的流行搜索算法(网格搜索、随机搜索和贝叶斯优化)。我们还将研究可解释的人工智能领域，这是理解模型在预测过程中做什么的过程。我们将描述这个领域中最常见的三种技术:<strong class="bold">置换特征重要性</strong> ( <strong class="bold"> PFI </strong>)、<strong class="bold">沙普利加法解释</strong> ( <strong class="bold"> SHAP </strong>)、<strong class="bold">局部可解释模型不可知解释</strong> ( <strong class="bold"> LIME </strong>)。</p>

			<p>在本章中，我们将讨论以下主要话题:</p>

			<ul>

				<li>使用超参数调整获得最佳性能模型</li>

				<li>用可解释的人工智能理解模型的行为</li>

			</ul>

			<h1 id="_idParaDest-155"><a id="_idTextAnchor164"/>技术要求</h1>

			<p>你可以从本书的GitHub资源库下载本章的补充材料，网址为<a href="https://github.com/PacktPublishing/Production-Ready-Applied-Deep-Learning/tree/main/Chapter_7">https://GitHub . com/packt publishing/Production-Ready-Applied-Deep-Learning/tree/main/Chapter _ 7</a>。</p>

			<h1 id="_idParaDest-156"><a id="_idTextAnchor165"/>使用超参数调整获得最佳性能模型</h1>

			<p>正如<a href="B18522_03.xhtml#_idTextAnchor062"> <em class="italic">第三章</em></a><em class="italic">中所描述的<a id="_idIndexMarker798"/>开发一个强大的深度学习模型</em>，要获得一个为底层任务提取正确模式的DL模型，需要适当配置多个组件。虽然构建正确的模型架构通常会引入许多困难，但是设置适当的模型训练是大多数人都在努力应对的另一个挑战。</p>

			<p>在<strong class="bold">机器学习</strong>(<strong class="bold">ML</strong>)<em class="italic">a</em><strong class="bold">超参数</strong> <em class="italic">是指控制学习过程</em>的任何参数。在许多情况下，数据科学家通常关注与模型相关的超参数，如特定类型的层数、学习率或优化器类型。然而，超参数还包括数据相关的配置，如应用的增强类型和模型训练的采样策略。改变一组超参数并了解性能变化，从而为目标任务找到正确的一组超参数的迭代过程称为<em class="italic">超参数调整</em>。准确地说，您将拥有一组想要探索的超参数。对于每次迭代，一个或多个超参数将被<a id="_idIndexMarker802"/>不同地配置，一个新的模型将用调整后的设置进行训练。在迭代过程之后，用于最佳模型的超参数配置将是最终输出。</p>

			<p>在本章中，我们将学习超参数调整的各种技术和工具。</p>

			<h2 id="_idParaDest-157"><a id="_idTextAnchor166"/>超参数调谐技术</h2>

			<p><em class="italic">超参数调谐技术可能因目标超参数值的选择方式而异</em>。在<a id="_idIndexMarker803"/>各种技术中，我们将<a id="_idIndexMarker804"/>集中在最常见的技术上:<strong class="bold">网格搜索</strong>、<strong class="bold">随机搜索</strong>和<strong class="bold">贝叶斯优化</strong>。</p>

			<h3>网格搜索</h3>

			<p>最基本的方法是被称为网格搜索的<a id="_idIndexMarker805"/>，其中每个可能的值被逐一评估<em class="italic">。例如，如果您想探索一个从0到1、增量为0.25的学习率，那么网格搜索将为每个<a id="_idIndexMarker806"/>可能的学习率(0.25、0.5、0.75和1)训练模型，并选择生成最佳模型的学习率。</em></p>

			<h3>随机搜索</h3>

			<p>另一方面，<em class="italic">随机搜索为超参数生成随机值，并重复训练，直到达到最大实验次数</em>。如果我们将上一节中的示例转换为随机搜索，我们必须定义<a id="_idIndexMarker807"/>最大实验次数和学习率的界限。在这个例子中，我们将设置<a id="_idIndexMarker808"/>最大值为5，边界为0到1。然后，随机搜索将在0和1之间选择一个随机值，并用选择的学习率训练一个模型。这个过程将重复5次，并且产生最佳模型的学习率将被选择作为超参数调整的输出。</p>

			<p>为了帮助您理解，下图总结了网格搜索和随机搜索之间的区别:</p>

			<div><div><img src="img/B18522_07_01.jpg" alt="Figure 7.1 – The difference between grid search and random search&#13;&#10;"/>

				</div>

			</div>

			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">图7.1-网格搜索和随机搜索的区别</p>

			<p>在上图中，<em class="italic"> x </em>和<em class="italic"> y </em>表示两个不同的超参数。每个轴上的紫色和绿色图形表示每个超参数的模型性能变化。</p>

			<p>虽然网格搜索和随机搜索易于实现，但它们都有一个共同的限制:它们不能保证目标超参数的最佳值。这个问题主要来自于在选择下一个要探索的值时没有考虑前面的结果。为了克服这个问题，一种新的搜索算法被引入:贝叶斯优化。</p>

			<h3>贝叶斯优化</h3>

			<p>贝叶斯优化的思想很简单:<em class="italic">在整个超参数调整过程中，构建并调整映射超参数和底层模型之间关系的代理模型，以便我们可以选择最有可能引导我们从下面的实验</em>中更好地理解关系的超参数值。使用生成的代理<a id="_idIndexMarker809"/>模型，我们可以选择超参数值，这可能会给我们一个更好的模型。</p>

			<p>有很多方法可以建立一个代理模型。如果我们假设该关系可以表示为线性函数，那么代理模型生成过程将简单地是线性回归。在现实中，关系要复杂得多，最成功的技术是使用高斯过程回归。这里，我们假设这种关系可以用一组正态分布来表示。换句话说，我们选择的每个值都是从多元正态分布中随机选取的。如果我们想了解贝叶斯优化的每个细节，我们需要引入多个概率和数学术语。我们相信，本节中的高级描述和下一节中的完整示例将足以让您使用贝叶斯优化来应用超参数调优。如果你<a id="_idIndexMarker811"/>想了解贝叶斯优化背后的理论，请前往<a href="https://ieeexplore.ieee.org/abstract/document/7352306">https://ieeexplore.ieee.org/abstract/document/7352306</a>。</p>

			<h2 id="_idParaDest-158"><a id="_idTextAnchor167"/>超参数调整工具</h2>

			<p>由于超参数调整<a id="_idIndexMarker812"/>在ML项目中起着重要的作用，许多<a id="_idIndexMarker813"/>库被设计成<a id="_idIndexMarker814"/>简化<a id="_idIndexMarker815"/>该过程。<a id="_idIndexMarker816"/>热门<a id="_idIndexMarker817"/>如下:</p>

			<ul>

				<li><strong class="bold">Scikit-Optimize</strong>:<a href="https://scikit-optimize.github.io">https://Scikit-Optimize . github . io</a></li>

				<li><strong class="bold">Optuna</strong>:【https://optuna.org T2】</li>

				<li><strong class="bold">hyperpt</strong>:<a href="http://hyperopt.github.io">http://hyperpt . github . io</a></li>

				<li><strong class="bold">雷调</strong>:<a href="https://docs.ray.io/en/latest/tune/index.html">https://docs.ray.io/en/latest/tune/index.html</a></li>

				<li><strong class="bold">贝叶斯优化</strong>:<a href="https://github.com/fmfn/BayesianOptimization">https://github.com/fmfn/BayesianOptimization</a></li>

				<li><strong class="bold">公制优化引擎</strong> ( <strong class="bold">教育部</strong>):<a href="https://github.com/Yelp/MOE">https://github.com/Yelp/MOE</a></li>

				<li><strong class="bold">留兰香</strong>:<a href="https://github.com/HIPS/Spearmint">https://github.com/HIPS/Spearmint</a></li>

				<li><strong class="bold">GPyOpt</strong>:<a href="https://github.com/SheffieldML/GPyOpt">https://github.com/SheffieldML/GPyOpt</a></li>

				<li><strong class="bold">SigOpt</strong>:<a href="https://sigopt.com/">https://sigopt.com</a></li>

				<li><strong class="bold">弗拉姆</strong>:<a href="https://github.com/microsoft/FLAML">https://github.com/microsoft/FLAML</a></li>

				<li><strong class="bold">https://github.com/dragonfly/dragonfly</strong>:<a href="https://github.com/dragonfly/dragonfly">蜻蜓</a></li>

				<li>https://github.com/automl/HpBandSter</li>

				<li><strong class="bold">奈弗格勒</strong>:<a href="https://github.com/facebookresearch/nevergrad">https://github.com/facebookresearch/nevergrad</a></li>

				<li><strong class="bold">ZOOpt</strong>:<a href="https://github.com/polixir/ZOOpt">https://github.com/polixir/ZOOpt</a></li>

				<li><strong class="bold">https://github.com/huawei-noah/HEBO/tree/master/HEBO</strong>:<a href="https://github.com/huawei-noah/HEBO/tree/master/HEBO">何波</a></li>

				<li><strong class="bold">SageMaker</strong>:<a href="https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-how-it-works.html">https://docs . AWS . Amazon . com/SageMaker/latest/DG/automatic-model-tuning-how-it-works . html</a></li>

			</ul>

			<p>在各种工具中，我们<a id="_idIndexMarker818"/>将查看Ray Tune，因为我们在<a href="B18522_06.xhtml#_idTextAnchor133"> <em class="italic">第6章</em> </a>、<em class="italic">高效模型训练</em>、<em class="italic">使用Ray </em>训练模型一节中介绍了如何使用Ray <a id="_idIndexMarker819"/>进行分布式训练。</p>

			<h3>使用光线调节的超参数调节</h3>

			<p>作为为跨机器扩展Python工作负载而开发的框架<a id="_idIndexMarker820"/>Ray的一部分，Ray Tune是为大规模实验执行和超参数<a id="_idIndexMarker821"/>调优而设计的。在本节中，我们将带您了解如何使用<strong class="bold">射线调节</strong>来配置和安排超参数调节。尽管这些示例是为模型训练功能的抽象表示而设计的，但Ray Tune的设置和文档足够清晰<a id="_idIndexMarker822"/>，以至于在本节的最后<a id="_idIndexMarker823"/>自然会出现<strong class="bold"> PyTorch </strong>和<strong class="bold">tensor flow</strong>(<strong class="bold">TF</strong>)集成。</p>

			<p>首先，我们将看看光线调的基础。Ray Tune的核心功能来自于<code>tune.run</code>函数，它管理所有的实验、日志和检查点。下面的代码片段演示了<code>tune.run</code>函数的基本<a id="_idIndexMarker824"/>用法:</p>

			<pre class="source-code">

from ray import tune

def tr_function(conf):

    num_iterations = conf["num_it"]

    for i in range(num_iterations):

        … // training logic

        tune.report(mean_accuracy=acc)

tune.run(

    run_or_experiment=tr_function

    conf={"num_it": tune.grid_search([10, 20, 30, 40])})</pre>

			<p><code>tune.run</code>函数接收<code>run_or_experiment</code>和<code>conf</code>，前者定义训练逻辑，后者<a id="_idIndexMarker825"/>配置超参数调整。实验的数量取决于<code>conf</code>中为每个超参数提供的搜索功能的类型。在前面的例子中，我们有<code>tune.grid_search([10, 20, 30, 40])</code>，它将启动四个实验，每个实验都运行为<code>run_or_experiment</code> ( <code>tr_function</code>)提供的函数，其值为<code>num_iterations</code>。在<code>tr_function</code>中，我们可以通过<code>conf</code>参数访问分配的超参数。值得一提的是，Ray Tune提供了大量的<a id="_idIndexMarker826"/>采样方法(<a href="https://docs.ray.io/en/latest/tune/api_docs/search_space.html#tune-sample-docs">https://docs . Ray . io/en/latest/Tune/API _ docs/search _ space . html # Tune-sample-docs</a>)。</p>

			<p>作为<code>tune.suggest</code>的一部分，Ray Tune集成了许多开源优化库，为超参数调整提供了各种最先进的搜索算法。流行的包括HyperOpt，贝叶斯优化，Scitkit-Optimize和Optuna。完整的名单可以在https://docs.ray.io/en/latest/tune/api_docs/suggestion.html找到。在下面的例子中，我们将描述如何使用<code>BayesOptSearch</code>，顾名思义，它实现了贝叶斯优化:</p>

			<pre class="source-code">

from ray import tune

from ray.tune.suggest.bayesopt import BayesOptSearch

conf = {"num_it": tune.randint(100, 200)}

bayesopt = BayesOptSearch(metric="mean_accuracy", mode="max")

tune.run(

    run_or_experiment=tr_function

    config = conf,

    search_alg = bayesopt)</pre>

			<p>在前面的代码<a id="_idIndexMarker827"/>片段中，我们为<code>search_alg</code>参数提供了一个<code>BayesOptSearch</code>的实例。这个例子将尝试<a id="_idIndexMarker828"/>找到<code>num_iterations</code>，这将为我们提供一个最高<code>mean_accuracy</code>的模型。</p>

			<p><code>tune.run</code>的另一个关键参数是<code>stop</code>。这个参数可以接受一个字典、一个函数或者一个定义停止标准的<code>Stopper</code>对象。如果是字典，key必须是<code>run_or_experiment</code>函数返回结果中的字段之一。如果它是一个函数，它应该返回一个布尔值，一旦满足停止条件，这个布尔值就变成<code>True</code>。以下示例描述了这两种情况:</p>

			<pre class="source-code">

# dictionary-based stop

tune.run(tr_function,

        stop={"training_iteration": 20, 

              "mean_accuracy": 0.96})

# function-based stop

def stp_function(trial_id, result):

    return result["training_iteration"] &gt; 20 or

           result["mean_accuracy"] &gt; 0.96

tune.run(tr_function, stop=stp_function)</pre>

			<p>在基于字典的示例中，如果完成10次迭代或<code>mean_accuracy</code>达到指定值<code>0.96</code>，则每次试验将停止。基于函数的例子实现了<a id="_idIndexMarker829"/>相同的逻辑，但是使用了<code>stp_function</code>函数。关于<code>stopper</code>类用例，可以参考<a href="https://docs.ray.io/en/latest/tune/tutorials/tune-stopping.html#stopping-with-a-class">https://docs . ray . io/en/latest/tune/tutorials/tune-stopping . html # stopping-with-a-class</a>。</p>

			<p><em class="italic">试验是Ray Tune的内部数据结构，包含关于每个实验的元数据</em>(<a href="https://docs.ray.io/en/latest/tune/api_docs/internals.html#trial-objects">https://docs . Ray . io/en/latest/Tune/API _ docs/internals . html # trial-objects</a>)。每个试验都有一个唯一的ID ( <code>trial.trial_id</code>)，可以通过<a id="_idIndexMarker830"/>到<code>trial.config</code>检查其超参数设置。有趣的是，通过<code>tune.run</code>和<code>trial.placement_group_factory</code>的<code>resources_per_trial</code>参数，可以为每次试验分配不同规模的机器资源。此外，<code>num_samples</code>参数可用于控制试验次数。</p>

			<p>您的实验总结可以使用从<code>ray.tune</code>返回的<code>Analysis</code>实例获得。以下代码片段描述了您可以从<code>Analysis</code>实例中检索的一组信息:</p>

			<pre class="source-code">

# last reported results

df = analysis.results_df

# list of trials

trs = analysis.trials

# max accuracy 

max_acc_df = analysis.dataframe(metric="mean_accuracy", mode="max")

# dict mapping for all trials in the experiment

all_dfs = analysis.trial_dataframes</pre>

			<p>您还可以从一个<code>Analysis</code>实例中检索其他有用的信息。完整的细节可以在https://docs.ray.io/en/latest/tune/api_docs/analysis.html找到。</p>

			<p>这就完成了Ray Tune的核心<a id="_idIndexMarker831"/>组件。如果您<a id="_idIndexMarker832"/>想要为您的PyTorch或TF模型训练集成Ray Tune，您必须做的就是调整示例中的<code>tr_function</code>，以便它在记录相关性能指标时训练您的模型。</p>

			<p>总的来说，我们已经探索了超参数调整的不同选项。我们在本节中介绍的工具应该可以帮助我们有效地找到DL模型的最佳配置。</p>

			<p class="callout-heading">要记住的事情</p>

			<p class="callout">a.为一个特定的任务获得一个工作的DL模型需要找到正确的模型架构并使用适当的训练配置。寻找最佳组合的过程称为<a id="_idIndexMarker833"/>超参数调整。</p>

			<p class="callout">b.三种最流行的超参数调整技术是网格搜索、随机搜索和贝叶斯优化。</p>

			<p class="callout">c.流行的超参数调优工具包括Scikit-Optimize、Optuna、Hyperopt、Ray Tune、Bayesian Optimization、MOE、Spearmint、GpyOpt和SigOpt。</p>

			<p>到目前为止，我们将DL模型视为黑盒。超参数调整包括搜索一个未知空间，该空间不能解释模型如何找到基础模式。在下一节中，我们将看看研究人员最近为理解DL的灵活性所做的工作。</p>

			<h1 id="_idParaDest-159">用可解释的人工智能理解模型的行为</h1>

			<p><strong class="bold">交代AI </strong>是<a id="_idIndexMarker834"/>研究的一个非常活跃的领域。在商业环境中，理解人工智能模型很容易带来独特的竞争优势。所谓的<em class="italic">黑盒模型(复杂算法模型)</em>，尽管它们带来了<a id="_idIndexMarker835"/>异常的结果，但由于其隐藏的逻辑而受到普遍批评。高层管理人员很难完全设计基于人工智能的核心业务，因为解释模型和预测不是一件容易的事情。你如何让你的商业伙伴相信一个人工智能模型总是会带来预期的结果？如何确保模型在新数据上仍然有效？模型是如何产生结果的？可解释的人工智能帮助我们解决这些问题。</p>

			<p>在我们继续之前，让我们先来看两个<a id="_idIndexMarker837"/>重要的概念:<strong class="bold">可解释性</strong>和<strong class="bold">可解释性</strong>。起初，它们听起来可能相似。可解释性告诉我们为什么特定的输入会产生特定的模型输出:特定变量对结果的影响。可解释性超越了可解释性；它不仅关注输入和输出之间的因果关系，而且帮助我们理解一个模型作为一个整体是如何工作的，包括它的所有子元素。可解释性也是由三个基本概念驱动的:透明性、再现性和可转移性。这意味着我们应该能够完全理解我们的模型做什么，当数据通过时如何影响模型，并且能够再现结果。</p>

			<p>可解释的人工智能在ML项目的每个步骤中都发挥着作用——开发(解释模型架构和每个超参数的意义)、训练(整个训练过程中模型内的变化)以及推理(结果解释)。在DL模型的情况下，由于网络架构的复杂性、高算法复杂性以及在初始化权重、偏差、正则化和超参数优化时使用随机数，很难实现可解释性。</p>

			<p>在本节中，我们将讨论一些常用于在DL模型背后构建额外可信度的方法:<strong class="bold">置换特征重要性</strong> ( <strong class="bold"> PFI </strong>)、<strong class="bold">特征重要性</strong> ( <strong class="bold"> FI </strong>)、<strong class="bold"> SHapley加法解释</strong> ( <strong class="bold"> SHAP </strong>)和<strong class="bold">局部可解释模型不可知解释</strong> ( <strong class="bold"> LIME </strong>)。所有这些方法都是模型不可知的；它们可以应用于DL模型以及通常用于设置基线评估度量的其他支持ML模型。</p>

			<h2 id="_idParaDest-160"><a id="_idTextAnchor169"/>排列特征重要性</h2>

			<p>神经网络缺乏理解输入特征对预测(模型输出)的影响所需的<a id="_idIndexMarker839"/>内在属性。然而，有一种称为<strong class="bold">置换特征重要性</strong> ( <strong class="bold"> PFI </strong>)的模型不可知方法是为这种困难设计的。<em class="italic">PFI的思想来源于输入特征和输出之间的关系:对于与输出变量高度相关的输入特征，改变其值会增加模型的预测误差</em>。如果关系较弱，模型性能不会受到太大影响。关系强了，业绩就降级了。PFI通常应用于测试集，以更广泛地了解模型对看不见的数据的可解释性。</p>

			<p>PFI的主要缺点是，当数据包含一组相关的输入要素时，它将无法正常工作。在这种情况下，即使更改组中的一个特征，模型性能也不会有太大变化，因为其他特征将保持不变。</p>

			<p>根据这个想法，我们可以完全删除该特性，并测量模型性能。这种<a id="_idIndexMarker840"/>方法称为<strong class="bold">特征重要性</strong> ( <strong class="bold"> FI </strong>)，也称为<strong class="bold">排列重要性</strong> ( <strong class="bold"> PI </strong>)或<strong class="bold">表示降低精确度</strong> ( <strong class="bold"> MDA </strong>)。让我们来看看如何为任何黑盒模型实现FI。</p>

			<h2 id="_idParaDest-161"><a id="_idTextAnchor170"/>功能重要性</h2>

			<p>在本节中，我们将使用<em class="italic"> ELI5 </em> Python包(<a href="https://eli5.readthedocs.io">https://Eli 5 . readthedocs . io</a>)来执行FI分析。它在FI <a id="_idIndexMarker842"/>领域脱颖而出，因为它使用起来非常简单。让我们看一个带有Keras定义模型的TF的最小代码示例(参见<a href="B18522_03.xhtml#_idTextAnchor062"> <em class="italic">第3章</em> </a>，<em class="italic">开发一个强大的深度学习模型</em>，了解模型定义的详细信息):</p>

			<pre class="source-code">

import eli5

from eli5.sklearn import PermutationImportance

def score(self, x, y_true):

    y_pred = model.predict(x)

    return tf.math.sqrt( tf.math.reduce_mean( tf.math.square(y_pred-y_true), axis=-1)) 

perm = PermutationImportance(model, random_state=1, scoring=score).fit(features, labels)

fi_perm=perm.feature_importances_

fi_std=perm.feature_importances_std_</pre>

			<p>如您所见，代码几乎是不言自明的。首先，我们需要为计算目标评估度量的score函数创建一个包装器。然后，<code>tf.keras</code>模型被传递给<code>PermutationImportance</code>类的构造函数。<code>fit</code>函数接受特征和标签，处理FI计算。在此计算之后，我们<a id="_idIndexMarker843"/>可以访问每个特征的平均FI(<code>fi_perm</code>)和置换结果的标准偏差(<code>fi_std</code>)。以下代码片段显示了如何将排列重要性的结果可视化为条形图:</p>

			<pre class="source-code">

plt.figure()

for index, row in enumerate(fi_perm):

    plt.bar(index, 

            fi_perm[index], 

            color="b", 

            yerr=fi_std[index], 

            align="center")

plt.show()</pre>

			<p>如果模型既不是基于scikit-learn也不是基于Keras，则需要使用<code>permutation_importance.get_score_importance</code>函数。以下代码片段描述了如何在PyTorch模型中使用该函数:</p>

			<pre class="source-code">

import numpy as np

from eli5.permutation_importance import get_score_importances

# A trained PyTorch model

black_box_model = ...

def score(X, y):

    y_pred = black_box_model.predict(X)

    return accuracy_score(y, y_pred)

base_score, score_decreases = get_score_importances(score, X, y)

feature_importances = np.mean(score_decreases, axis=0)</pre>

			<p>与<code>PermutationImportance</code>类不同，<code>get_score_importances</code>函数同时接受评分函数、特征和标签。</p>

			<p>接下来，我们<a id="_idIndexMarker844"/>将看看<strong class="bold">沙普利附加解释</strong> ( <strong class="bold"> SHAP </strong>)，这也是一种模型不可知的方法。</p>

			<h2 id="_idParaDest-162"><a id="_idTextAnchor171"/>沙普利加法解释(SHAP)</h2>

			<p>SHAP是一种解释<a id="_idIndexMarker845"/>方法，利用Shapley值来理解给定的黑盒模型。我们不会讨论SHAP所基于的合作博弈理论，但是我们会在一个高层次上讨论这个过程。首先，我们来看看Shapley值的定义:<em class="italic">不同模拟上所有可能联盟的边际贡献平均值</em>。这到底是什么意思？假设一组四个朋友(<em class="italic"> f1 </em>、<em class="italic"> f2 </em>、<em class="italic"> f3 </em>和<em class="italic"> f4 </em>)正在一起努力为一个在线游戏获得最高分。为了计算一个人的Shapley值，我们需要计算边际贡献，这是这个人玩游戏和不玩<a id="_idIndexMarker846"/>游戏时得分的差异。必须对所有可能的子组进行这种计算(<strong class="bold">联盟</strong>)。</p>

			<p>让我们仔细看看。为了计算朋友联盟<em class="italic"> f2 </em>、<em class="italic"> f3 </em>和<em class="italic"> f4 </em>的边际贡献<em class="italic"> f1 </em>，我们需要做以下事情:</p>

			<ol>

				<li>计算所有好友(<em class="italic"> f1 </em>、<em class="italic"> f2 </em>、<em class="italic"> f3 </em>、<em class="italic"> f4 </em>)产生的分数(<em class="italic"> s1 </em>)。</li>

				<li>计算好友<em class="italic"> f2 </em>、<em class="italic"> f3 </em>、<em class="italic"> f4 </em>产生的分数(<em class="italic"> s2 </em>)。</li>

				<li>最后，朋友<em class="italic"> f1 </em>对于朋友联盟<em class="italic"> f2 </em>、<em class="italic"> f3 </em>、<em class="italic"> f4 </em>、【v】的边际贡献等于<em class="italic"> s1-s2 </em>。</li>

			</ol>

			<p>现在，我们需要计算所有子群的边际贡献(不仅仅是朋友联盟；即<em class="italic"> f2 </em>、<em class="italic"> f3 </em>、<em class="italic"> f4 </em>。以下是所有可能的组合:</p>

			<ol>

				<li value="1"><em class="italic"> f1 </em>对<em class="italic">没人</em>出力(<em class="italic"> v1 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f2 </em>对<em class="italic"> f2 </em> ( <em class="italic"> v2 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f3 </em>对<em class="italic"> f3 </em> ( <em class="italic"> v3 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f4 </em>对<em class="italic"> f4 </em> ( <em class="italic"> v4 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f2 </em>和<em class="italic"> f3 </em>对<em class="italic"> f2 </em>和<em class="italic"> f3 </em> ( <em class="italic"> v5 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f2 </em>和<em class="italic"> f4 </em>对<em class="italic"> f2 </em>和<em class="italic"> f4 </em> ( <em class="italic"> v6 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f3 </em>和<em class="italic"> f4 </em>对<em class="italic"> f3 </em>和<em class="italic"> f4 </em> ( <em class="italic"> v7 </em>)</li>

				<li><em class="italic"> f1 </em>和<em class="italic"> f2 </em>和<em class="italic"> f3 </em>和<em class="italic"> f4 </em>对<em class="italic"> f2 </em>和<em class="italic"> f3 </em>和<em class="italic"> f4 </em> ( <em class="italic"> v8 </em>)</li>

			</ol>

			<p>总的来说，<em class="italic"> f1 </em>的Shapley值(<em class="italic"> SV </em>)为<em class="italic"> (v1+v2+...+v8) / 8 </em>。</p>

			<p>为了让我们的结果在统计上合理，我们需要通过多次模拟运行这些计算。你可以看到，如果我们扩展朋友的数量，计算变得极其复杂，导致计算资源的高消耗。所以使用了特定的<a id="_idIndexMarker847"/>近似，导致了<code>shap</code>库(<a href="https://shap.readthedocs.io/en/latest/index.html">https://shap.readthedocs.io/en/latest/index.html</a>)中不同类型的所谓解释器(Shapley值的近似器)。对比沙普利对所有朋友的价值观，可以发现个人对最终得分的贡献。</p>

			<p>如果我们回到DL模型的解释，我们可以看到朋友成为一组特征，分数就是模型性能。考虑到这一点，我们来看看SHAP的解释器，它可以用于DL模型:</p>

			<ul>

				<li><code>KernelExplainer</code>:这是最流行的方法，并且与模型无关。它基于<strong class="bold">局部可解释的模型不可知解释</strong> ( <strong class="bold"> LIME </strong>)，我们将在下一节讨论。</li>

				<li><code>DeepExplainer</code>:这种方法基于深度列表方法，将输出分解到特定的输入上(<a href="https://arxiv.org/abs/1704.02685">https://arxiv.org/abs/1704.02685</a>)。</li>

				<li><code>GradientExplainer</code>:该方法基于积分梯度的扩展(<a href="https://arxiv.org/abs/1703.01365">https://arxiv.org/abs/1703.01365</a>)。</li>

			</ul>

			<p>例如，我们将给出一个将SHAP应用于TF模型的极简代码示例。完整的细节可以在https://shap-lrjball.readthedocs.io/en/latest/index.html的官方文档中找到:</p>

			<pre class="source-code">

import shap

# initialize visualization

shap.initjs()

model = … # tf.keras model or PyTorch model (nn.Module) 

explainer = shap.KernelExplainer(model, sampled_data)

shap_values = explainer.shap_values(data, nsamples=300)

shap.force_plot(explainer.expected_value, shap_values, data)

shap.summary_plot(shap_values, sampled_data, feature_names=names, plot_type="bar")</pre>

			<p>对于PyTorch模型，您需要将您的模型包装在一个包装器中，以将输入和输出转换成<a id="_idIndexMarker848"/>正确的类型(<code>f=lambda x: model(torch.autograd.Variable(torch.from_numpy(x))).detach().numpy()</code>)。在前面的例子中，我们已经定义了<code>KernelExplainer</code>，它接受一个DL模型和<code>sampled_data</code>作为输入。接下来，我们使用<code>explainer.shap_values</code>函数计算SHAP值(Shapley值的近似值)。在这个例子中，我们使用<code>300</code>扰动样本来估计给定预测的SHAP值。如果我们的<code>sampled_data</code>包含<code>100</code>示例，我们将执行100*300个模型评估。同样，你可以用<code>GradientExplainer</code> ( <code>shap.GradientExplainer(model, sampled_data)</code>)或者<code>DeepExplainer</code> ( <code>shap.DeepExplainer(model, sampled_data)</code>)。<code>sampled_data</code>的大小需要足够大以正确表示分布。在最后几行中，我们使用<code>shap.force_plot</code>功能在附加力布局中可视化SHAP值，使用<code>shap.summary_plot</code>功能<a id="_idIndexMarker849"/>创建全局模型解释图。</p>

			<p>现在，让我们看看石灰法。</p>

			<h2 id="_idParaDest-163"><a id="_idTextAnchor172"/>本地可解释的模型不可知解释(LIME)</h2>

			<p>LIME是一种训练<a id="_idIndexMarker850"/>本地代理模型来解释模型预测的方法。首先，你需要准备一个你想要解读的模型和一个样本。LIME使用您的模型从一组扰动数据中收集预测，并将它们与原始样本进行比较，以分配相似性权重(如果预测与原始样本上的预测越接近，权重越高)。LIME使用由相似性权重加权的特定数量的特征在采样数据上拟合本质上可解释的替代模型。最后，LIME将代理模型解释视为您所选示例的黑盒模型的解释。要执行LIME分析，我们可以使用<code>lime</code>包(<a href="https://lime-ml.readthedocs.io">https://LIME-ml . readthedocs . io</a>)。</p>

			<p>让我们来看一个为DL模型设计的示例:</p>

			<pre class="source-code">

from lime.lime_tabular import LimeTabularExplainer as Lime

from matplotlib import pyplot as plt

expl = Lime(features, mode='classification', class_names=[0, 1])

# explain first sample

exp = expl.explain_instance(x[0], model.predict, num_features=5, top_labels=1)

# show plot

exp.show_in_notebook(show_table=True, show_all=False) </pre>

			<p>在前面的例子中，我们使用了<code>LimeTabularExplainer</code>类。构造器接受训练集、特性、类名和模式类型(<code>'classification'</code>)。类似地，您可以通过提供<code>'regression'</code>模式<a id="_idIndexMarker851"/>类型来设置回归问题的时间。然后，通过展示五个最重要的特征及其影响，我们解释来自测试集的第一个预测(<code>x[0]</code>)。最后，我们从计算的时间解释生成一个图。</p>

			<p class="callout-heading">要记住的事情</p>

			<p class="callout">a.模型可解释性和可解释性是可解释人工智能中的两个关键概念。</p>

			<p class="callout">b.可解释人工智能中流行的模型不可知技术有PFI、FI、SHAP和LIME。</p>

			<p class="callout">c.PFI、FI和SHAP是允许您在局部(单个样本)和全局(一组样本)水平上解释模型的方法。另一方面，LIME侧重于单个样本和相应的模型预测。</p>

			<p>在这一节中，我们解释了可解释人工智能的概念和四种最常见的技术:PFI、FI、SHAP和LIME。</p>

			<h1 id="_idParaDest-164"><a id="_idTextAnchor173"/>总结</h1>

			<p>我们从超参数调谐开始这一章。我们描述了用于超参数调优的三种基本搜索算法(网格搜索、随机搜索和贝叶斯优化)，并介绍了许多可以集成到项目中的工具。在我们列出的工具中，我们讨论了Ray Tune，因为它支持分布式超参数调整，并实现了许多现成的最先进的搜索算法。</p>

			<p>然后，我们讨论了可解释的人工智能。我们解释了最标准的技术(PFI、FI、SHAP和LIME)以及如何使用它们来找出模型的行为如何相对于数据集中的每个要素发生变化。</p>

			<p>在下一章中，我们将把重点转向部署。我们将学习ONNX，一种ML模型的开放格式，并了解如何将TF或PyTorch模型转换为ONNX模型。</p>

		</div>

		<div><div/>

		</div>

	



</body></html>